{"0": {
    "doc": "AdSDK Cache Management",
    "title": "AdSDK Cache Management",
    "content": "The SDK supports a persistent cache with resources related to ad, these can be banners or other resources, depending on the type of ad. In this tutorial, we’ll look at how an application developer can control the cache. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/6.0.0/cache-management.html",
    
    "relUrl": "/6.0.0/cache-management.html"
  },"1": {
    "doc": "AdSDK Cache Management",
    "title": "Section 1: Limiting the cache size",
    "content": "In this section, we will learn how to limit the size of the cache. Step 1 . Let’s open MainScreen.kt and focus on the AdServiceProvider.configure method. When we creating an AdService, we can specify the size of our cache in MB via cacheSize parameter. Let’s set it to 20 MB. Note: The cache size parameter is optional. If you do not specify it, the default cache size is 100 MB. File: MainScreen.kt . // ... class MainViewModel( val adServiceProvider: AdServiceProviderInterface = ServiceLocator.adServiceProvider ) : ViewModel() { // ... fun onLoad(isDataCollectionAllowed: Boolean) { // ... viewModelScope.launch { adServiceProvider .configure( \"1800\", parentCoroutineScope = this, cacheSize = 20u, globalParameters = globalParameters, adRequestGlobalParameters = adRequestGlobalParameters ) .flatMap { adServiceProvider.get() } .onSuccess { adService -&gt; // ... } .get( onSuccess = { _state.value = PresentationState.Loaded(Unit) }, onError = { _state.value = PresentationState.Error(it.description) } ) } } } // ... Step 2 . In addition, the SDK allows you to change the size of the cache over time. You can use AdService.setCacheSize method for this purpose. Note: If the specified cache size is smaller than the size of already cached resources, the cache will delete resources to fit the new specified limit. File: MainScreen.kt . // ... class MainViewModel( val adServiceProvider: AdServiceProviderInterface = ServiceLocator.adServiceProvider ) : ViewModel() { // ... fun onLoad(isDataCollectionAllowed: Boolean) { // ... viewModelScope.launch { adServiceProvider .configure( \"1800\", parentCoroutineScope = this, cacheSize = 20u, globalParameters = globalParameters, adRequestGlobalParameters = adRequestGlobalParameters ) // .onSuccess { // val possibleError = it.setCacheSize(20u).adErrorOrNull() // } .flatMap { adServiceProvider.get() } .onSuccess { adService -&gt; // ... } .get( onSuccess = { _state.value = PresentationState.Loaded(Unit) }, onError = { _state.value = PresentationState.Error(it.description) } ) } } } // ... ",
    "url": "/nextgen-adsdk-android-release/6.0.0/cache-management.html#section-1-limiting-the-cache-size",
    
    "relUrl": "/6.0.0/cache-management.html#section-1-limiting-the-cache-size"
  },"2": {
    "doc": "AdSDK Cache Management",
    "title": "Section 2: Flushing the cache",
    "content": "Although the cache size reached to it limit, SDK will removes resources in FIFO order, sometimes you need to clear the cache completely. In this section, we will learn how we can do this. Step 1 . Let’s imagine a situation in which some ads can be localized. In this case, you would like to clear the entire cache so that when the ad is reloaded, it will be correctly localized. Let’s add the functionality of tracking localization changes. First, we will create the package presentation/screens/main_screen and move MainScreen.kt there. Next, we will create LocaleChangeEffect.kt in presentation/screens/main_screen/components. File: LocaleChangeEffect.kt . @Composable fun LocaleChangeEffect(onLocaleChanged: (Locale) -&gt; Unit) { val configuration = LocalConfiguration.current val locale = configuration.locales[0] val localeTag = locale.toLanguageTag() val previousLocaleTag = rememberSaveable { mutableStateOf&lt;String?&gt;(null) } LaunchedEffect(localeTag) { if (previousLocaleTag.value != null &amp;&amp; previousLocaleTag.value != localeTag) { onLocaleChanged(locale) } previousLocaleTag.value = localeTag } } . Step 2 . Now let’s return to MainScreen.kt and use this effect. File: MainScreen.kt . // ... @Composable fun MainScreen( navController: NavController, viewModel: MainViewModel = viewModel() ) { // ... PresentationStateContainer( uiState, Modifier.fillMaxSize() ) { LocaleChangeEffect { viewModel.onLocaleChange() } // ... } } class MainViewModel( val adServiceProvider: AdServiceProviderInterface = ServiceLocator.adServiceProvider ) : ViewModel() { // ... fun onLoad(isDataCollectionAllowed: Boolean) { // ... } fun onLocaleChange() { } } // ... Step 3 . All we have to do is clear the cache. To do this, we use the AdService.flushCache method. File: MainScreen.kt . // ... class MainViewModel( val adServiceProvider: AdServiceProviderInterface = ServiceLocator.adServiceProvider ) : ViewModel() { // ... fun onLoad(isDataCollectionAllowed: Boolean) { // ... } fun onLocaleChange() { viewModelScope.launch { adServiceProvider.get() .onSuccess { val possibleError = it.flushCache().adErrorOrNull() if (possibleError != null) { Log.e( \"MainViewModel\", \"Error flushing cache: ${possibleError.description}\" ) } } } } } // ... Congratulations, now all ad resources will be removed every time the user changes the language. ",
    "url": "/nextgen-adsdk-android-release/6.0.0/cache-management.html#section-2-flushing-the-cache",
    
    "relUrl": "/6.0.0/cache-management.html#section-2-flushing-the-cache"
  },"3": {
    "doc": "How to use AdSDK with XML views",
    "title": "How to use AdSDK with XML views",
    "content": "Working with AdSDK is no different, as most APIs are not tied to UI frameworks in any way. What you need to pay attention to are the two AdSDK Composable components: Ad and Interstitial. ",
    "url": "/nextgen-adsdk-android-release/6.0.0/compose_with_xml_guide.html",
    
    "relUrl": "/6.0.0/compose_with_xml_guide.html"
  },"4": {
    "doc": "How to use AdSDK with XML views",
    "title": "Use Ad &amp; Interstitial Composable with Views",
    "content": "The major difference when using XML instead of Compose comes when you try to use the Ad or the Interstitial composable, since they are built with Compose. To integrate them into an XML-based layout, you’ll need to use Android’s setContent(). There are several ways to do this. XML . &lt;androidx.compose.ui.platform.ComposeView android:id=\"@+id/composeView1\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; . findViewById&lt;ComposeView&gt;(R.id.composeView1).setContent { Interstitial(interstitialState) } . Code . ComposeView(context).apply { layoutParams = AdsListView.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT ) setContent { Ad(it.data) } } . For more information, you can refer to the Compose documentation. ",
    "url": "/nextgen-adsdk-android-release/6.0.0/compose_with_xml_guide.html#use-ad--interstitial-composable-with-views",
    
    "relUrl": "/6.0.0/compose_with_xml_guide.html#use-ad--interstitial-composable-with-views"
  },"5": {
    "doc": "Create and display inline ads",
    "title": "Create and display inline ads",
    "content": "This tutorial will guide you how to create and display inline ads. An inline ad is an ad created to be displayed in your view hierarchy. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/6.0.0/create-and-display-inline-ads.html",
    
    "relUrl": "/6.0.0/create-and-display-inline-ads.html"
  },"6": {
    "doc": "Create and display inline ads",
    "title": "Section 1: Creating an inline ads",
    "content": "Your AdService is ready for creating advertisements, so in this section, we will create an Advertisement for future ad display. Step 1 . Lets create an AdItem composable and an AdItemState class in presentation/screens/inline_screen/components. Since we plan to display multiple ads in the LazyColumn, we will use it to display a single ad. We pass the AdService to the constructor, which will be used to create the ad later. File: AdItem.kt . @Composable fun AdItem() { Text(text = \"Advertisement should be here\") } class AdItemState( val id: Int, private val adService: AdService ) { suspend fun loadAdvertisement() { } } . Step 2 . To create advertisements, we use the AdService.makeAdvertisement method. The most important parameter now is AdRequest, which describes the request that will be sent to the server to receive ads. Let’s pass it through the constructor and look at it in more detail later. File: AdItem.kt . // ... class AdItemState( val id: Int, private val adService: AdService, private val request: AdRequest ) { suspend fun loadAdvertisement() { adService .makeAdvertisement( adRequest = request, placementType = AdPlacementType.INLINE, // Inline by default targetURLHandler = null, // Can be skipped adEventListener = null // Can be skipped ) } } . Step 3 . The AdService.makeAdvertisement method returns AdResult. If the ad is created and loaded successfully, you will receive the downloaded Advertisement object. You can think of it as a ViewModel that holds the data and state of your ad. We store this object and create ItemData, which we will pass using PresentationState to our composable. File: AdItem.kt . // ... class AdItemState( val id: Int, private val adService: AdService, private val request: AdRequest ) { private val _state = MutableStateFlow&lt;PresentationState&lt;ItemData&gt;&gt;(PresentationState.Loading) private var advertisement: Advertisement? = null val state = _state.asStateFlow() suspend fun loadAdvertisement() { _state.value = PresentationState.Loading adService .makeAdvertisement( adRequest = request, placementType = AdPlacementType.INLINE, // Inline by default targetURLHandler = null, // Can be skipped adEventListener = null // Can be skipped ) .get( onSuccess = { ad -&gt; val data = ItemData(ad) advertisement = ad _state.value = PresentationState.Loaded(data) }, onError = { error -&gt; _state.value = PresentationState.Error(error.description) } ) } data class ItemData( val advertisement: Advertisement ) } . Step 4 . Since Advertisement is not a lifecycle-aware object and contains logic related to coroutines, we need to destroy Advertisement when we no longer need it. To do this, we must use the Advertisement.dispose method. We add it to onCleared and will call it later from ViewModel. File: AdItem.kt . // ... class AdItemState( val id: Int, private val adService: AdService, private val request: AdRequest ) { // ... fun onCleared() { advertisement?.dispose() advertisement = null } // ... } . ",
    "url": "/nextgen-adsdk-android-release/6.0.0/create-and-display-inline-ads.html#section-1-creating-an-inline-ads",
    
    "relUrl": "/6.0.0/create-and-display-inline-ads.html#section-1-creating-an-inline-ads"
  },"7": {
    "doc": "Create and display inline ads",
    "title": "Section 2: Displaying advertisement",
    "content": "If we have an Advertisement instance, it remains to add a Composable to present it. In this section, we will figure out how to do this. Step 1 . We can use Ad to display advertisement, which serves as the presentation layer for your inline ad. File: AdItem.kt . @Composable fun AdItem(state: AdItemState) { val uiState by state.state.collectAsState() PresentationStateContainer( uiState, modifier = Modifier .fillMaxWidth() .aspectRatio(2.0f) ) { data -&gt; Box( Modifier.fillMaxWidth() ) { Ad( advertisement = data.advertisement, Modifier.fillMaxWidth() ) } } } // ... Step 2 . The only problem at the moment is that we don’t know the size of the advertisement. But we know that Advertisement stores advertising data. Let’s try to get it! . We can obtain all possible advertising data using Advertisement.getMetadata method that returns AdMetadata instance. This is the one we will use to obtain the size data. We will extend ItemData and map the result of AdService.makeAdvertisement to obtain AdMetadata.aspectRatio. Note: The AdMetadata is optional, but you can be sure that if you have not called the Advertisement.reload method, the object will be present. File: AdItem.kt . // ... class AdItemState( val id: Int, private val adService: AdService, private val request: AdRequest ) { private val _state = MutableStateFlow&lt;PresentationState&lt;ItemData&gt;&gt;(PresentationState.Loading) private var advertisement: Advertisement? = null val state = _state.asStateFlow() suspend fun loadAdvertisement() { _state.value = PresentationState.Loading adService .makeAdvertisement( adRequest = request, placementType = AdPlacementType.INLINE, // Inline by default targetURLHandler = null, // Can be skipped adEventListener = null // Can be skipped ) .map { ItemData(it, it.getMetadata()?.aspectRatio) } .get( onSuccess = { data -&gt; advertisement = data.advertisement _state.value = PresentationState.Loaded(data) }, onError = { error -&gt; _state.value = PresentationState.Error(error.description) } ) } fun onCleared() { advertisement?.dispose() advertisement = null } data class ItemData( val advertisement: Advertisement, val aspectRatio: Float? ) } private suspend fun &lt;T, ActionResult&gt; AdResult&lt;T&gt;.map( action: suspend (T) -&gt; ActionResult ): AdResult&lt;ActionResult&gt; { return when (this) { is AdResult.Success -&gt; AdResult.Success(action(this.result)) is AdResult.Error -&gt; AdResult.Error(this.error) } } . Step 3 . All we have left to do is use the aspect ratio provided, if it is specified in the Advertisement. If not, we will use the default 2:1. After that, we can be sure that the ad size is displayed correctly. File: AdItem.kt . @Composable fun AdItem(state: AdItemState) { val uiState by state.state.collectAsState() PresentationStateContainer( uiState, modifier = Modifier .fillMaxWidth() .aspectRatio(2.0f) ) { data -&gt; Box( Modifier .fillMaxWidth() .aspectRatio(data.aspectRatio ?: 2.0f) ) { Ad( advertisement = data.advertisement, Modifier .fillMaxWidth() .aspectRatio(data.aspectRatio ?: 2.0f) ) } } } // ... ",
    "url": "/nextgen-adsdk-android-release/6.0.0/create-and-display-inline-ads.html#section-2-displaying-advertisement",
    
    "relUrl": "/6.0.0/create-and-display-inline-ads.html#section-2-displaying-advertisement"
  },"8": {
    "doc": "Create and display inline ads",
    "title": "Section 3: Creating and displaying a list of advertisements",
    "content": "Our AdItem is ready to load and display a single ad. In this section, we will create a new screen to display the list of advertisements. Step 1 . First, we will create the top navigation bar, which we will use on future screen. Create AppTopBarContainer in ui/components. File: AppTopBarContainer.kt . @OptIn(ExperimentalMaterial3Api::class) @Composable fun AppTopBarContainer( title: String, modifier: Modifier = Modifier, onNavigateBack: () -&gt; Unit, content: @Composable () -&gt; Unit = {} ) { Column { Surface( modifier = modifier.fillMaxWidth(), color = MaterialTheme.colorScheme.primaryContainer, contentColor = MaterialTheme.colorScheme.onPrimaryContainer ) { TopAppBar( title = { Text(title) }, navigationIcon = { IconButton(onClick = onNavigateBack) { Icon( imageVector = Icons.AutoMirrored.Filled.ArrowBack, contentDescription = \"Back\" ) } } ) } content() } } . Step 2 . The next step will be to create InlineScreen composable and InlineViewModel in presentation/screens/inline_screen. File: InlineScreen.kt . @Composable fun InlineScreen( viewModel: InlineViewModel = viewModel(), navController: NavController ) { } class InlineViewModel( private val adService: AdService = ServiceLocator.adService ): ViewModel() { } . Step 3 . After that, we need to create routes for each of the screens, add a transition from MainScreen to InlineScreen, and connect navigation in MainActivity. File: InlineScreen.kt . @Serializable data object InlineRoute // ... File: MainScreen.kt . @Serializable data object MainRoute @Composable fun MainScreen( navController: NavController, viewModel: MainViewModel = viewModel() ) { val uiState by viewModel.state.collectAsState() PresentationStateContainer( uiState, Modifier.fillMaxSize() ) { Column( verticalArrangement = Arrangement.Center, horizontalAlignment = Alignment.CenterHorizontally, modifier = Modifier .fillMaxSize() .padding(16.dp) ) { Button( onClick = { navController.navigate(InlineRoute) } ) { Text(\"Inline Ads List\") } } } } // ... File: MainActivity.kt . class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) enableEdgeToEdge() setContent { TutorialAppTheme { val navController = rememberNavController() NavHost( navController = navController, startDestination = MainRoute ) { composable&lt;MainRoute&gt; { MainScreen(navController = navController) } composable&lt;InlineRoute&gt; { InlineScreen(navController = navController) } } } } } } . Step 4 . Let’s continue working with InlineScreen. This screen is responsible for creating AdItemState and displaying AdItems. Note: We start the process of loading all the ads as soon as the screen appears, but you can implement your own logic with bash loading on scroll, or load ads before the screen is displayed, it all depends on your needs. File: InlineScreen.kt . // ... @Composable fun InlineScreen( viewModel: InlineViewModel = viewModel(), navController: NavController ) { val uiState by viewModel.state.collectAsState() PresentationStateContainer( uiState, Modifier.fillMaxSize() ) { dataSource -&gt; AppTopBarContainer( title = \"Inline Screen\", onNavigateBack = { navController.navigateUp() } ) { LazyColumn( modifier = Modifier.fillMaxSize() ) { items( dataSource, key = { it.id } ) { itemState -&gt; AdItem(itemState) } } } } } class InlineViewModel( private val adService: AdService = ServiceLocator.adService ): ViewModel() { private val dataSource = mutableListOf&lt;AdItemState&gt;() private val _state = MutableStateFlow&lt;PresentationState&lt;List&lt;AdItemState&gt;&gt;&gt;( PresentationState.Loading ) val state = _state.asStateFlow() init { viewModelScope.launch { val cellStates = getDataSource() dataSource.addAll(cellStates) _state.value = PresentationState.Loaded(cellStates) } } private suspend fun getDataSource(): List&lt;AdItemState&gt; {} } . Step 5 . Let’s focus our attention on the getDataSource method, because in this method we will implement the logic for filling the dataSource. As you may recall, to create an ad, we need an AdRequest. It describes the request that will be sent to the server to get an ad. The only mandatory parameter when creating the AdRequest is AdRequest.contentUnit or AdRequest.learningTag. Content unit is unique ID of a content space. Note: You can also use AdRequest.learningTag, but we use AdRequest.contentUnit in this tutorial because it is more commonly used. File: InlineScreen.kt . // ... class InlineViewModel( private val adService: AdService = ServiceLocator.adService ) : ViewModel() { // ... private suspend fun getDataSource(): List&lt;AdItemState&gt; = supervisorScope { val requests = List(5) { AdRequest( contentUnit = \"4810915\", profiles = hashMapOf(), // Can be skipped keywords = listOf(), // Can be skipped window = null, // Can be skipped timeoutAfterSeconds = 10u, // Can be skipped gdprPd = null, // Can be skipped campaignId = null, // Can be skipped bannerId = null, // Can be skipped isSHBEnabled = null, // Can be skipped dsa = null // Can be skipped ) } } } . Step 6 . Time to load ads! Since we want to load all the ads in parallel, we’ll use a async coroutine to for that. File: InlineScreen.kt . // ... class InlineViewModel( private val adService: AdService = ServiceLocator.adService ) : ViewModel() { // ... private suspend fun getDataSource(): List&lt;AdItemState&gt; = supervisorScope { val requests = List(5) { AdRequest( contentUnit = \"4810915\", profiles = hashMapOf(), // Can be skipped keywords = listOf(), // Can be skipped window = null, // Can be skipped timeoutAfterSeconds = 10u, // Can be skipped gdprPd = null, // Can be skipped campaignId = null, // Can be skipped bannerId = null, // Can be skipped isSHBEnabled = null, // Can be skipped dsa = null // Can be skipped ) } requests .mapIndexed { index, request -&gt; async { val itemState = AdItemState( index, adService, request ) itemState.loadAdvertisement() itemState } } .awaitAll() } } . Step 7 . At this point, we can already see the list of advertisements, but in order to avoid possible leaks, we must clear the Advertisements when we no longer need them. To do this, we will use the onCleared method. File: InlineScreen.kt . // ... class InlineViewModel( private val adService: AdService = ServiceLocator.adService ) : ViewModel() { // ... override fun onCleared() { super.onCleared() dataSource.onCleared() } // ... } private fun List&lt;AdItemState&gt;.onCleared() = forEach { it.onCleared() } . Now, if you did everything right, you can launch the app and see the list of advertisement. Congratulations! . ",
    "url": "/nextgen-adsdk-android-release/6.0.0/create-and-display-inline-ads.html#section-3-creating-and-displaying-a-list-of-advertisements",
    
    "relUrl": "/6.0.0/create-and-display-inline-ads.html#section-3-creating-and-displaying-a-list-of-advertisements"
  },"9": {
    "doc": "Create and display interstitial ad",
    "title": "Create and display interstitial ad",
    "content": "A full-screen advertisement that fills the host app’s interface is known as an interstitial ad. In this tutorial we will add an interstitial ad to our application. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/6.0.0/create-and-display-interstitial-ad.html",
    
    "relUrl": "/6.0.0/create-and-display-interstitial-ad.html"
  },"10": {
    "doc": "Create and display interstitial ad",
    "title": "Section 1: Creating interstitial advertisements",
    "content": "We have already created an inline Advertisement on a previous chapter. In this section, we will create a interstitial ad for the future presentation. Step 1 . Let’s create InterstitialRoute, InterstitialScreen composable, and InterstitialViewModel in the presentation/screens. This will be the screen where we will display the ad. File: InterstitialScreen.kt . @Serializable data object InterstitialRoute @Composable fun InterstitialScreen( viewModel: InterstitialViewModel = viewModel(), navController: NavController ) { } class InterstitialViewModel( private val adService: AdService = ServiceLocator.adService ) : ViewModel() { } . Step 2 . Same with the InlineScreen, let’s add it to our navigation. File: MainScreen.kt . // ... @Composable fun MainScreen( navController: NavController, viewModel: MainViewModel = viewModel() ) { val uiState by viewModel.state.collectAsState() PresentationStateContainer( uiState, Modifier.fillMaxSize() ) { Column( verticalArrangement = Arrangement.Center, horizontalAlignment = Alignment.CenterHorizontally, modifier = Modifier .fillMaxSize() .padding(16.dp) ) { Button( onClick = { navController.navigate(InlineRoute) } ) { Text(\"Inline Ads List\") } Button( onClick = { navController.navigate(InterstitialRoute) } ) { Text(\"Interstitial Ad\") } } } } //... File: MainActivity.kt . class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) enableEdgeToEdge() setContent { TutorialAppTheme { val navController = rememberNavController() NavHost( navController = navController, startDestination = MainRoute ) { composable&lt;MainRoute&gt; { MainScreen(navController = navController) } composable&lt;InlineRoute&gt; { InlineScreen(navController = navController) } composable&lt;InterstitialRoute&gt; { InterstitialScreen(navController = navController) } } } } } } . Step 3 . Creating interstitial ads is almost the same as creating inline ads, with one small difference – the placementType parameter must be AdPlacementType.INTERSTITIAL. Let’s add the logic for loading the advertisement into InterstitialViewModel. File: InterstitialScreen.kt . // ... class InterstitialViewModel( private val adService: AdService = ServiceLocator.adService ) : ViewModel() { init { viewModelScope.launch { val request = AdRequest(contentUnit = \"5192923\") adService.makeAdvertisement( adRequest = request, placementType = AdPlacementType.INTERSTITIAL, adEventListener = null ).get( onSuccess = { ad -&gt; }, onError = { error -&gt; } ) } } } . ",
    "url": "/nextgen-adsdk-android-release/6.0.0/create-and-display-interstitial-ad.html#section-1-creating-interstitial-advertisements",
    
    "relUrl": "/6.0.0/create-and-display-interstitial-ad.html#section-1-creating-interstitial-advertisements"
  },"11": {
    "doc": "Create and display interstitial ad",
    "title": "Section 3: Presenting interstitial ad",
    "content": "We learnt how to create interstitial advertisement. Now, we are ready to present our interstitial ad. In this section, we will display interstitial ad in our app. ",
    "url": "/nextgen-adsdk-android-release/6.0.0/create-and-display-interstitial-ad.html#section-3-presenting-interstitial-ad",
    
    "relUrl": "/6.0.0/create-and-display-interstitial-ad.html#section-3-presenting-interstitial-ad"
  },"12": {
    "doc": "Create and display interstitial ad",
    "title": "Step 1",
    "content": "The AdSDK provides AdInterstitialState to control the state of the interstitial ad presentation. It accepts two parameters: . | advertisement – the advertisement to be displayed. | scope – the coroutine scope that defines the interstitial’s lifecycle. | . We add AdInterstitialState to PresentationState for presentation control. File: InterstitialScreen.kt . // ... @Composable fun InterstitialScreen( viewModel: InterstitialViewModel = viewModel(), navController: NavController ) { val uiState by viewModel.state.collectAsState() PresentationStateContainer( uiState, Modifier.fillMaxSize() ) { interstitialState -&gt; AppTopBarContainer( title = \"Interstitial Screen\", onNavigateBack = { navController.navigateUp() } ) { Box( contentAlignment = Alignment.Center, modifier = Modifier.fillMaxSize() ) { } } } } class InterstitialViewModel( private val adService: AdService = ServiceLocator.adService ) : ViewModel() { private var interstitialState: AdInterstitialState? = null private val _state = MutableStateFlow&lt;PresentationState&lt;AdInterstitialState&gt;&gt;( PresentationState.Loading ) val state = _state.asStateFlow() init { viewModelScope.launch { val request = AdRequest(contentUnit = \"5192923\") adService.makeAdvertisement( adRequest = request, placementType = AdPlacementType.INTERSTITIAL, adEventListener = null ).get( onSuccess = { ad -&gt; val adState = AdInterstitialState(ad, this) interstitialState = adState _state.value = PresentationState.Loaded(adState) }, onError = { error -&gt; interstitialState = null _state.value = PresentationState.Error(error.description) } ) } } } . Step 2 . Now let’s add a button that will show our ad if it is loaded. File: InterstitialScreen.kt . // ... @Composable fun InterstitialScreen( viewModel: InterstitialViewModel = viewModel(), navController: NavController ) { val uiState by viewModel.state.collectAsState() PresentationStateContainer( uiState, Modifier.fillMaxSize() ) { interstitialState -&gt; AppTopBarContainer( title = \"Interstitial Screen\", onNavigateBack = { navController.navigateUp() } ) { Box( contentAlignment = Alignment.Center, modifier = Modifier.fillMaxSize() ) { Button( onClick = { viewModel.onPresent() } ) { Text(\"Present\") } } } } } class InterstitialViewModel( private val adService: AdService = ServiceLocator.adService ) : ViewModel() { private var interstitialState: AdInterstitialState? = null // ... init { // ... } fun onPresent() { } } . Step 3 . To show an interstitial ad, you can use the AdInterstitialState.presentIfLoaded method. Note: If you don’t use the Advertisement.reload method, your Advertisement object will always be loaded, which means that the ad will be presented to the user immediately when AdInterstitialState.presentIfLoaded method called. Otherwise, the ad will be presented immediately after loading. File: InterstitialScreen.kt . // ... class InterstitialViewModel( private val adService: AdService = ServiceLocator.adService ) : ViewModel() { private var interstitialState: AdInterstitialState? = null // ... init { // ... } fun onPresent() { interstitialState?.presentIfLoaded() } } . Step 3 . The next step will be adding a presentation layer. To display interstitial ads, SDK has an Interstitial composable. Add it to your InterstitialScreen and pass the state. File: InterstitialScreen.kt . // ... @Composable fun InterstitialScreen( viewModel: InterstitialViewModel = viewModel(), navController: NavController ) { val uiState by viewModel.state.collectAsState() PresentationStateContainer( uiState, Modifier.fillMaxSize() ) { interstitialState -&gt; AppTopBarContainer( title = \"Interstitial Screen\", onNavigateBack = { navController.navigateUp() } ) { Box( contentAlignment = Alignment.Center, modifier = Modifier.fillMaxSize() ) { Button( onClick = { viewModel.onPresent() } ) { Text(\"Present\") } } } Box( contentAlignment = Alignment.Center, modifier = Modifier.fillMaxSize() ) { Interstitial(interstitialState) } } } // ... ",
    "url": "/nextgen-adsdk-android-release/6.0.0/create-and-display-interstitial-ad.html#step-1-1",
    
    "relUrl": "/6.0.0/create-and-display-interstitial-ad.html#step-1-1"
  },"13": {
    "doc": "Create and display interstitial ad",
    "title": "Section 3: Hiding interstitial ad",
    "content": "We managed to successfully show the ad, but we would like to be able to close interstitial. In this section, we implement this logic. Step 1 . Let’s continue the development in our InterstitialScreen file. We could hide the ad by simply calling the AdInterstitialState.hide method, but we don’t know when to call it. In order to understand when ad should be hidden, we need to use AdEventListener. We will explain the AdEventListener in more detail in the next tutorial. Let’s create an adEventListener in InterstitialViewModel, and then pass it to the AdService.makeAdvertisement. File: InterstitialScreen.kt . // ... class InterstitialViewModel( private val adService: AdService = ServiceLocator.adService ) : ViewModel() { private var interstitialState: AdInterstitialState? = null private val _state = MutableStateFlow&lt;PresentationState&lt;AdInterstitialState&gt;&gt;( PresentationState.Loading ) private val adEventListener: AdEventListener = object : AdEventListener { } val state = _state.asStateFlow() init { viewModelScope.launch { val request = AdRequest(contentUnit = \"5192923\") adService.makeAdvertisement( adRequest = request, placementType = AdPlacementType.INTERSTITIAL, adEventListener = adEventListener ).get( onSuccess = { ad -&gt; val adState = AdInterstitialState(ad, this) interstitialState = adState _state.value = PresentationState.Loaded(adState) }, onError = { error -&gt; interstitialState = null _state.value = PresentationState.Error(error.description) } ) } } fun onPresent() { interstitialState?.presentIfLoaded() } } . Step 2 . The method we are interested in is AdEventListener.unloadRequest. We need to implement it to make sure that the ad is hidden when it is needed. Note: You should not change the state from presented to hidden without using AdEventListener.unloadRequest method. The advert itself knows when it needs to be hidden and asks you to hide it using this method. File: InterstitialScreen.kt . // ... class InterstitialViewModel( private val adService: AdService = ServiceLocator.adService ) : ViewModel() { private var interstitialState: AdInterstitialState? = null private val _state = MutableStateFlow&lt;PresentationState&lt;AdInterstitialState&gt;&gt;( PresentationState.Loading ) private val adEventListener: AdEventListener = object : AdEventListener { override fun unloadRequest() { interstitialState?.hide() } } val state = _state.asStateFlow() init { // ... } fun onPresent() { interstitialState?.presentIfLoaded() } } . Step 3 . Same with inline ad, to avoid leaks, we must clear the advertisement when we no longer need it using the Advertisement.dispose method. File: InterstitialScreen.kt . class InterstitialViewModel( private val adService: AdService = ServiceLocator.adService ) : ViewModel() { private var interstitialState: AdInterstitialState? = null // ... init { // ... } fun onPresent() { interstitialState?.presentIfLoaded() } override fun onCleared() { super.onCleared() interstitialState?.advertisement?.dispose() } } . You can launch the app and make sure it works. Congratulations, we can now display interstitials in our app! . ",
    "url": "/nextgen-adsdk-android-release/6.0.0/create-and-display-interstitial-ad.html#section-3-hiding-interstitial-ad",
    
    "relUrl": "/6.0.0/create-and-display-interstitial-ad.html#section-3-hiding-interstitial-ad"
  },"14": {
    "doc": "Custom handling of target tap URLs",
    "title": "Custom handling of target tap URLs",
    "content": "Sometimes you need to handle taps in your own way. For example, to display ads in the internal browser in the app. In this tutorial, we will learn how to customise the SDK’s tap handling behaviour. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/6.0.0/create-target-url-handler.html",
    
    "relUrl": "/6.0.0/create-target-url-handler.html"
  },"15": {
    "doc": "Custom handling of target tap URLs",
    "title": "Section 1: Preparing the app",
    "content": "In this section, we will create a screen with a browser that will display the target URL when you click on an inline ad. Step 1 . Create a new BrowserScreen.kt file in presentation/screens package. In it, we will implement the BrowserScreen and BrowserRoute. File: BrowserScreen.kt . @Serializable data class BrowserRoute(val url: String) @Composable fun BrowserScreen( url: String, navController: NavController ) { val context = LocalContext.current AppTopBarContainer( title = \"Browser\", onNavigateBack = { navController.navigateUp() } ) { AndroidView( factory = { WebView(context).apply { webViewClient = WebViewClient() loadUrl(url) } }, update = { it.loadUrl(url) }, modifier = Modifier.fillMaxSize(), onRelease = { webView -&gt; webView.stopLoading() webView.destroy() } ) } } . Step 2 . After that, we add this screen to the navigation in MainActivity. File: MainActivity.kt . class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) enableEdgeToEdge() setContent { TutorialAppTheme { val navController = rememberNavController() NavHost( navController = navController, startDestination = MainRoute ) { // ... composable&lt;BrowserRoute&gt; { val route = it.toRoute&lt;BrowserRoute&gt;() BrowserScreen(url = route.url, navController = navController) } } } } } } . Step 3 . Since we want BrowserScreen to open for inline advertising, open AdItem.kt. File: AdItem.kt . // ... class AdItemState( val id: Int, private val adService: AdService, private val request: AdRequest, private val parentCoroutineScope: CoroutineScope ) { private val _state = MutableStateFlow&lt;PresentationState&lt;ItemData&gt;&gt;(PresentationState.Loading) private var advertisement: Advertisement? = null val state = _state.asStateFlow() val price: Int = Random.nextInt(10, 200) // ... } // ... Step 4 . We create a sealed class Event and MutableSharedFlow, which AdItemState will use to notify AdItem that we need to navigate to BrowserScreen. File: AdItem.kt . // ... class AdItemState( val id: Int, private val adService: AdService, private val request: AdRequest, private val parentCoroutineScope: CoroutineScope ) { private val _state = MutableStateFlow&lt;PresentationState&lt;ItemData&gt;&gt;(PresentationState.Loading) private val _events = MutableSharedFlow&lt;Event&gt;() private var advertisement: Advertisement? = null val state = _state.asStateFlow() val events = _events.asSharedFlow() val price: Int = Random.nextInt(10, 200) // ... sealed class Event { data class OpenURL(val url: String) : Event() } } // ... Step 5 . The final step is to collect events inside the composable. File: AdItem.kt . @Composable fun AdItem(state: AdItemState, navController: NavController) { val uiState by state.state.collectAsState() val events = state.events LaunchedEffect(Unit) { events.collect { event -&gt; when (event) { is AdItemState.Event.OpenURL -&gt; { navController.navigate(BrowserRoute(event.url)) } } } } // ... } // ... ",
    "url": "/nextgen-adsdk-android-release/6.0.0/create-target-url-handler.html#section-1-preparing-the-app",
    
    "relUrl": "/6.0.0/create-target-url-handler.html#section-1-preparing-the-app"
  },"16": {
    "doc": "Custom handling of target tap URLs",
    "title": "Section 2: Creating a target URL handler",
    "content": "In this section, we will look at how you can implement custom target URL processing. Step 1 . Let’s continue in AdItemState. As you may have noticed, the AdService.makeAdvertisement method has a parameter called targetURLHandler, which receives TargetURLHandler. File: AdItem.kt . // ... class AdItemState( val id: Int, private val adService: AdService, private val request: AdRequest, private val parentCoroutineScope: CoroutineScope ) { private val _state = MutableStateFlow&lt;PresentationState&lt;ItemData&gt;&gt;(PresentationState.Loading) private val _events = MutableSharedFlow&lt;Event&gt;() private var advertisement: Advertisement? = null val state = _state.asStateFlow() val events = _events.asSharedFlow() val price: Int = Random.nextInt(10, 200) // ... suspend fun loadAdvertisement() { _state.value = PresentationState.Loading adService .makeAdvertisement( adRequest = request, placementType = AdPlacementType.INLINE, // Inline by default targetURLHandler = null, // Can be skipped adEventListener = eventListener ) // ... } // ... } // ... Step 2 . The TargetURLHandler interface designed to handle target URLs. Let’s implement it. File: AdItem.kt . // ... class AdItemState( val id: Int, private val adService: AdService, private val request: AdRequest, private val parentCoroutineScope: CoroutineScope ) { private val _state = MutableStateFlow&lt;PresentationState&lt;ItemData&gt;&gt;(PresentationState.Loading) private val _events = MutableSharedFlow&lt;Event&gt;() private var advertisement: Advertisement? = null private val targetUrlHandler: TargetURLHandler = object : TargetURLHandler { } val state = _state.asStateFlow() val events = _events.asSharedFlow() val price: Int = Random.nextInt(10, 200) // ... suspend fun loadAdvertisement() { _state.value = PresentationState.Loading adService .makeAdvertisement( adRequest = request, placementType = AdPlacementType.INLINE, // Inline by default targetURLHandler = targetUrlHandler, adEventListener = eventListener ) // ... } // ... } // ... Step 3 . TargetURLHandler interface has two methods, one of which is optional, so let’s start with it. TargetURLHandler.isValidURL will be called every time the SDK wants to validate the target URL. If you return false, the SDK will return an AdError.invalidTargetURL error in AdEventListener.tapEventProcessingFailed. Note: If you do not implement this method, all URLs will be considered valid. File: AdItem.kt . // ... class AdItemState( // ... ) { private val _state = MutableStateFlow&lt;PresentationState&lt;ItemData&gt;&gt;(PresentationState.Loading) private val _events = MutableSharedFlow&lt;Event&gt;() private var advertisement: Advertisement? = null private val targetUrlHandler: TargetURLHandler = object : TargetURLHandler { override fun isValidURL(url: String) = true // Can be skipped } // ... } // ... Step 4 . The second method is mandatory. The TargetURLHandler.handleURL will be called every time the SDK wants the URL to be opened for the user. In our case, we want to emit Event.OpenURL. File: AdItem.kt . // ... class AdItemState( val id: Int, private val adService: AdService, private val request: AdRequest, private val parentCoroutineScope: CoroutineScope ) { private val _state = MutableStateFlow&lt;PresentationState&lt;ItemData&gt;&gt;(PresentationState.Loading) private val _events = MutableSharedFlow&lt;Event&gt;() private var advertisement: Advertisement? = null private val targetUrlHandler: TargetURLHandler = object : TargetURLHandler { override fun isValidURL(url: String) = true // Can be skipped override fun handleURL(url: String) { parentCoroutineScope.launch { _events.emit(Event.OpenURL(url)) } } } // ... } // ... Now, if you launch the app and tap on the ad, you can see that the target URL opens in the internal browser. Congratulations! . ",
    "url": "/nextgen-adsdk-android-release/6.0.0/create-target-url-handler.html#section-2-creating-a-target-url-handler",
    
    "relUrl": "/6.0.0/create-target-url-handler.html#section-2-creating-a-target-url-handler"
  },"17": {
    "doc": "Creating customised advertising",
    "title": "Creating customised advertising",
    "content": "In this tutorial, we will learn how to create custom ads using AdSDK. This process is the same for both inline and interstitial ads. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. Note: In this tutorial, we want to display a picture and frame it, but in real-world projects, your ad can be anything - video, HTML, graphics, etc. ",
    "url": "/nextgen-adsdk-android-release/6.0.0/creating-customised-advertising.html",
    
    "relUrl": "/6.0.0/creating-customised-advertising.html"
  },"18": {
    "doc": "Creating customised advertising",
    "title": "Section 1: Preparing the app",
    "content": "In this section, we will prepare our project for creating a custom renderer. We will create the logic for decoding the future JSON and move the methods for working with AdResult to a separate file. Step 1 . The server should always be configured to return a custom response when using custom advertising. In this tutorial, the server is configured to give us the following response. { // ... ad_name: \"tutorialad\", body: { // ... ext: { // ... adData: { banner_image: Banner URL, framing_width: Framing width, is_black_framing: Boolean value – whether the color should be black or white. } } } } . Step 2 . Knowing the data we want to obtain, we can start with the logic of decoding JSON. To do this, create TutorialRendererResponse.kt in the ui/components/tutorial_renderer package. File: TutorialRendererResponse.kt . @Serializable data class TutorialRendererResponse(val body: Body) { val bannerImage: String get() = body.ext.adData.bannerImage val framingWidth: Double get() = body.ext.adData.framingWidth val isBlackFraming: Boolean get() = body.ext.adData.isBlackFraming @Serializable data class Body(val ext: Ext) @Serializable data class Ext(val adData: AdData) @Serializable data class AdData( @SerialName(\"banner_image\") val bannerImage: String, @SerialName(\"framing_width\") val framingWidth: Double, @SerialName(\"is_black_framing\") val isBlackFraming: Boolean ) } . Step 3 . Since the renderer is an extension to the SDK, it should also work with the AdResult. Create a JsonExtensions.kt file in the utility/ package. In it, we implement a method for decoding JSON, which returns the AdResult type. File: JsonExtensions.kt . inline fun &lt;reified T&gt; Json.decodeString(json: String) = try { AdResult.Success(decodeFromString&lt;T&gt;(json)) } catch (exception: SerializationException) { AdResult.Error(AdError.Decoding(exception)) } . Step 4 . The next step is to create ByteArrayExtensions.kt in the same package. In this file, we implement the logic for converting ByteArray to ImageBitmap. File: ByteArrayExtensions.kt . fun ByteArray.toImageBitmap(url: String): AdResult&lt;ImageBitmap&gt; { val image = runCatching { BitmapFactory.decodeByteArray(this, 0, this.size)?.asImageBitmap() }.getOrNull() return if (image != null) { AdResult.Success(image) } else { val exception = JSONException(\"Image bitmap decoding failed for URL: $url\") AdResult.Error(AdError.Decoding(exception)) } } . Step 5 . The final step of preparation is to transfer all AdResult’s extensions methods from MainScreen.kt and AdItem.kt to a separate file AdResultExtensions.kt, which we create in the utility/ package. We do this because when creating a renderer, we will have to actively work with AdResult. File: AdResultExtensions.kt . suspend fun &lt;T, ActionResult&gt; AdResult&lt;T&gt;.map( action: suspend (T) -&gt; ActionResult ): AdResult&lt;ActionResult&gt; { return when (this) { is AdResult.Success -&gt; AdResult.Success(action(this.result)) is AdResult.Error -&gt; AdResult.Error(this.error) } } suspend fun &lt;T, ActionResult&gt; AdResult&lt;T&gt;.flatMap( action: suspend (T) -&gt; AdResult&lt;ActionResult&gt; ): AdResult&lt;ActionResult&gt; { return when (this) { is AdResult.Success -&gt; action(this.result) is AdResult.Error -&gt; AdResult.Error(this.error) } } suspend fun &lt;T&gt; AdResult&lt;T&gt;.onSuccess( action: suspend (T) -&gt; Unit ) : AdResult&lt;T&gt; { return when (this) { is AdResult.Success -&gt; { action(this.result) this } is AdResult.Error -&gt; this } } . ",
    "url": "/nextgen-adsdk-android-release/6.0.0/creating-customised-advertising.html#section-1-preparing-the-app",
    
    "relUrl": "/6.0.0/creating-customised-advertising.html#section-1-preparing-the-app"
  },"19": {
    "doc": "Creating customised advertising",
    "title": "Section 2: Creating a business layer",
    "content": "We use the AdRenderer interface to create custom advertisements. In this section, we will look at methods related to the business layer of renderer creation. Step 1 . Create TutorialRenderer.kt in the ui/components/tutorial_renderer package. In this file, we implement a class that will implement our future AdRenderer. File: TutorialRenderer.kt . class TutorialRenderer : AdRenderer { } . Step 2 . Let’s start with the AdRenderer.configure method. This method is the key to creating ads. Within it, you have to perform all the logic to prepare the ad for display - decoding, additional downloads, etc. Note: This method is directly related to the AdService.makeAdvertisement and Advertisement.reload methods. As soon as this method is completed, the Advertisement will be returned to the app. File: TutorialRenderer.kt . class TutorialRenderer : AdRenderer { // Will be called every time an ad is loaded or reloaded. override suspend fun configure( adResponse: String, adMetadata: AdMetadata ): AdResult&lt;Unit&gt; { } } . Step 3 . The adResponse parameter contains the entire response from the server. Let’s add the decoding logic to get the data we need to create the ad. File: TutorialRenderer.kt . class TutorialRenderer : AdRenderer { private val jsonFormat = Json { ignoreUnknownKeys = true } // Will be called every time an ad is loaded or reloaded. override suspend fun configure( adResponse: String, adMetadata: AdMetadata ) = jsonFormat.decodeString&lt;TutorialRendererResponse&gt;(adResponse) } . Step 4 . The next step is to load a banner for display. The SDK provides some tools for easy work with advertising resources. In this case, we use AssetRepository. We pass it through the constructor. It can download, cache, and return cached advertising resources. When using it, we don’t need to think about caching, as the whole process takes place internally. Isn’t it convenient? . File: TutorialRenderer.kt . class TutorialRenderer( private val assetRepository: AssetRepository ) : AdRenderer { private val jsonFormat = Json { ignoreUnknownKeys = true } // Will be called every time an ad is loaded or reloaded. override suspend fun configure( adResponse: String, adMetadata: AdMetadata ) = jsonFormat.decodeString&lt;TutorialRendererResponse&gt;(adResponse) } . Step 5 . We use the AssetRepository.getAsset method, which can return either AdError or AssetResult. From it, we can get the loaded data and find out whether it was successfully cached. Note: You can also use AssetRepository.getAssets to load multiple advertising resources concurrently. File: TutorialRenderer.kt . class TutorialRenderer( private val assetRepository: AssetRepository ) : AdRenderer { private val jsonFormat = Json { ignoreUnknownKeys = true } // Will be called every time an ad is loaded or reloaded. override suspend fun configure( adResponse: String, adMetadata: AdMetadata ) = jsonFormat.decodeString&lt;TutorialRendererResponse&gt;(adResponse) .flatMap { response -&gt; assetRepository .getAsset(response.bannerImage) .onSuccess { assetResult -&gt; assetResult.cacheResult.get( onSuccess = { Log.d(\"TutorialRenderer\", \"Banner cached: $it\") }, onError = { Log.e( \"TutorialRenderer\", \"Banner caching failed: ${it.description}\" ) } ) } .flatMap { it.data.toImageBitmap(response.bannerImage) } .map { Pair(response, it) } } } . Step 6 . In addition, the AdRenderer.configure method has an adMetadata parameter. This AdMetadata will be available in the app, and you can use it to pass some additional information from the renderer to the app. Note: If you use interactive elements in the upper right corner of your banner, isDSAButtonShown may also be useful for you. If this value is true, you should reserve 21 dp for this button. File: TutorialRenderer.kt . class TutorialRenderer( private val assetRepository: AssetRepository ) : AdRenderer { private val jsonFormat = Json { ignoreUnknownKeys = true } // Will be called every time an ad is loaded or reloaded. override suspend fun configure( adResponse: String, adMetadata: AdMetadata ) = jsonFormat.decodeString&lt;TutorialRendererResponse&gt;(adResponse) .flatMap { response -&gt; // ... } .onSuccess { adMetadata.rendererMetadata = mutableMapOf( \"custom_data\" to \"my custom data that will be available in the app\" ) } } . Step 7 . We’ve decoded the data we need and retrieved the ad banner, which means it’s time to change the state of our renderer so that the future composable knows it can display this content. File: TutorialRenderer.kt . class TutorialRenderer( private val assetRepository: AssetRepository ) : AdRenderer { private var rendererData = MutableStateFlow&lt;RendererData?&gt;(null) private val jsonFormat = Json { ignoreUnknownKeys = true } // Will be called every time an ad is loaded or reloaded. override suspend fun configure( adResponse: String, adMetadata: AdMetadata ) = jsonFormat.decodeString&lt;TutorialRendererResponse&gt;(adResponse) .flatMap { response -&gt; // ... } .onSuccess { // ... } .onSuccess { (response, banner) -&gt; rendererData.value = RendererData( banner = banner, framingWidth = response.framingWidth, isBlackFraming = response.isBlackFraming ) } .map {} data class RendererData( val banner: ImageBitmap, val framingWidth: Double, val isBlackFraming: Boolean ) } . Step 8 . This concludes the configuration of our renderer, so we can now proceed to the next method – AdRenderer.prepareForReload. In it, you can implement logic to clear your state and prepare for a reload. In our case, it’s not very useful, but it can come in handy, for example, if your renderer uses a timer or another process that you would like to reset. File: TutorialRenderer.kt . class TutorialRenderer( private val assetRepository: AssetRepository ) : AdRenderer { private var rendererData = MutableStateFlow&lt;RendererData?&gt;(null) private val jsonFormat = Json { ignoreUnknownKeys = true } // Will be called every time an ad is loaded or reloaded. override suspend fun configure( adResponse: String, adMetadata: AdMetadata ) = jsonFormat.decodeString&lt;TutorialRendererResponse&gt;(adResponse) // ... // Will be called when app want to reload the ad override suspend fun prepareForReload(): AdResult&lt;Unit&gt; { rendererData.value = null return AdResult.Success(Unit) } data class RendererData( // ... ) } . Step 9 . The final method in this section is AdRenderer.dispose. This is an optional method that you can use to clean up your renderer and finish all processes before it is destroyed. File: TutorialRenderer.kt . class TutorialRenderer( private val assetRepository: AssetRepository ) : AdRenderer { private var rendererData = MutableStateFlow&lt;RendererData?&gt;(null) private val jsonFormat = Json { ignoreUnknownKeys = true } // Will be called every time an ad is loaded or reloaded. override suspend fun configure( adResponse: String, adMetadata: AdMetadata ) = jsonFormat.decodeString&lt;TutorialRendererResponse&gt;(adResponse) // ... // Will be called when app want to reload the ad override suspend fun prepareForReload(): AdResult&lt;Unit&gt; { // ... } // Called before renderer will be removed override fun dispose() { } data class RendererData( // ... ) } . Step 10 . The most obvious example of using this method is cancelling all internal coroutines. We create an internal CoroutineScope that we will use in the future, and with the AdRenderer.dispose method, we can be sure that our renderer will not cause any leaks in the future. File: TutorialRenderer.kt . class TutorialRenderer( private val assetRepository: AssetRepository, private val coroutineScope: CoroutineScope = CoroutineScope( SupervisorJob() + Dispatchers.Main.immediate ) ) : AdRenderer { private var rendererData = MutableStateFlow&lt;RendererData?&gt;(null) private val jsonFormat = Json { ignoreUnknownKeys = true } // Will be called every time an ad is loaded or reloaded. override suspend fun configure( adResponse: String, adMetadata: AdMetadata ) = jsonFormat.decodeString&lt;TutorialRendererResponse&gt;(adResponse) // ... // Will be called when app want to reload the ad override suspend fun prepareForReload(): AdResult&lt;Unit&gt; { // ... } // Called before renderer will be removed override fun dispose() { rendererData.value = null coroutineScope.cancel() } data class RendererData( // ... ) } . ",
    "url": "/nextgen-adsdk-android-release/6.0.0/creating-customised-advertising.html#section-2-creating-a-business-layer",
    
    "relUrl": "/6.0.0/creating-customised-advertising.html#section-2-creating-a-business-layer"
  },"20": {
    "doc": "Creating customised advertising",
    "title": "Section 3: Event management",
    "content": "In the previous section, we implemented the logic associated with loading, reloading, and cleaning your custom ad. The next step will be to implement the processing of ad-related events. Step 1 . Let’s continue working with our TutorialRenderer. Almost all ads need to handle taps, but our renderer doesn’t have this functionality at the moment. File: TutorialRenderer.kt . class TutorialRenderer( private val assetRepository: AssetRepository, private val coroutineScope: CoroutineScope = CoroutineScope( SupervisorJob() + Dispatchers.Main.immediate ) ) : AdRenderer { // ... data class RendererData( // ... ) } . Step 2 . In order to execute or notify about an event, we use AdRendererEventHandler. In fact, it is an Advertisement object that knows how to handle certain events. File: TutorialRenderer.kt . class TutorialRenderer( private val assetRepository: AssetRepository, private val eventHandler: AdRendererEventHandler, private val coroutineScope: CoroutineScope = CoroutineScope( SupervisorJob() + Dispatchers.Main.immediate ) ) : AdRenderer { // ... data class RendererData( // ... ) } . Step 3 . Now we can implement the method that will be called when the banner is tapped. Note: Some events return AdResult, which indicates that the renderer may catch errors when executing events. If an error occurs when processing an event, you should not attempt to repeat it, as this is the responsibility of the app, which can do so using AdEventListener. You can use this error to debug or change the state of the presentation. File: TutorialRenderer.kt . class TutorialRenderer( private val assetRepository: AssetRepository, private val eventHandler: AdRendererEventHandler, private val coroutineScope: CoroutineScope = CoroutineScope( SupervisorJob() + Dispatchers.Main.immediate ) ) : AdRenderer { // ... fun onTap() { coroutineScope.launch { eventHandler.performTap(AdTapEvent.Tap) } } data class RendererData( // ... ) } . Step 4 . The tap event is not the only event that AdRendererEventHandler can handle. You can find all events in the AdRendererEventHandler documentation. File: TutorialRenderer.kt . class TutorialRenderer( private val assetRepository: AssetRepository, private val eventHandler: AdRendererEventHandler, private val coroutineScope: CoroutineScope = CoroutineScope( SupervisorJob() + Dispatchers.Main.immediate ) ) : AdRenderer { // ... fun onTap() { coroutineScope.launch { eventHandler.performTap(AdTapEvent.Tap) // eventHandler.unloadRequest() // eventHandler.sendMessage(\"Message_to_app\", \"My message to the app\") } } data class RendererData( // ... ) } . ",
    "url": "/nextgen-adsdk-android-release/6.0.0/creating-customised-advertising.html#section-3-event-management",
    
    "relUrl": "/6.0.0/creating-customised-advertising.html#section-3-event-management"
  },"21": {
    "doc": "Creating customised advertising",
    "title": "Section 4: Creating a presentation layer",
    "content": "Even though our business layer is ready, we still can’t build our project. That’s because the AdRenderer requires a presentation layer. Step 1 . The AdRenderer interface has a mandatory method AdRenderer.RenderAd. This method is exactly where we need to implement the presentation logic. File: TutorialRenderer.kt . class TutorialRenderer( private val assetRepository: AssetRepository, private val eventHandler: AdRendererEventHandler, private val coroutineScope: CoroutineScope = CoroutineScope( SupervisorJob() + Dispatchers.Main.immediate ) ) : AdRenderer { // ... @Composable override fun RenderAd(modifier: Modifier) { } } . Step 2 . First, we will observe the rendererData to get the data we need. File: TutorialRenderer.kt . class TutorialRenderer( private val assetRepository: AssetRepository, private val eventHandler: AdRendererEventHandler, private val coroutineScope: CoroutineScope = CoroutineScope( SupervisorJob() + Dispatchers.Main.immediate ) ) : AdRenderer { // ... @Composable override fun RenderAd(modifier: Modifier) { val data = rendererData.collectAsState() data.value?.let { } } } . Step 3 . After that, all we have left to do is implement the banner display with a frame and process tap on this advertisement. File: TutorialRenderer.kt . class TutorialRenderer( private val assetRepository: AssetRepository, private val eventHandler: AdRendererEventHandler, private val coroutineScope: CoroutineScope = CoroutineScope( SupervisorJob() + Dispatchers.Main.immediate ) ) : AdRenderer { // ... @Composable override fun RenderAd(modifier: Modifier) { val data = rendererData.collectAsState() data.value?.let { val borderColor = if (it.isBlackFraming) Color.Black else Color.White Box( modifier = modifier .border( width = it.framingWidth.dp, color = borderColor ) .clickable { onTap() } ) { Image( bitmap = it.banner, contentDescription = null ) } } } } . ",
    "url": "/nextgen-adsdk-android-release/6.0.0/creating-customised-advertising.html#section-4-creating-a-presentation-layer",
    
    "relUrl": "/6.0.0/creating-customised-advertising.html#section-4-creating-a-presentation-layer"
  },"22": {
    "doc": "Creating customised advertising",
    "title": "Section 5: Registering a renderer in the SDK",
    "content": "Although we have created a custom ad, in order for the SDK to use it, we need to pass it to the SDK somehow. Let’s do that. Step 1 . First of all, let’s get back to our response from the server. As you can see, it includes the ad_name field. It is this field that the SDK will use to identify your renderer. { // ... ad_name: \"tutorialad\", // &lt;---------- body: { // ... ext: { // ... adData: { banner_image: Banner URL, framing_width: Framing width, is_black_framing: Boolean value – whether the color should be black or white. } } } } . Step 2 . Let’s go to the MainScreen.kt file, the place where we create our AdService. This is where we will be able to register our custom renderer. File: MainScreen.kt . // ... class MainViewModel( val adServiceProvider: AdServiceProviderInterface = ServiceLocator.adServiceProvider ) : ViewModel() { // ... fun onLoad(isDataCollectionAllowed: Boolean) { // ... viewModelScope.launch { adServiceProvider .configure( \"1800\", parentCoroutineScope = this, cacheSize = 20u, globalParameters = globalParameters, adRequestGlobalParameters = adRequestGlobalParameters ) // ...onSuccess { adService -&gt; // ... } .get( onSuccess = { _state.value = PresentationState.Loaded(Unit) }, onError = { _state.value = PresentationState.Error(it.description) } ) } } // ... } // ... Step 3 . All we need to do is use the AdService.registerRenderer method, passing in the value we expect to receive in the ad_name field and the renderer factory method, which we will review in more detail in the next step. This way, every time the ad_name field in the server response is the same as the String you passed to this method, the SDK will build the renderer using provided factory method. File: MainScreen.kt . // ... class MainViewModel( val adServiceProvider: AdServiceProviderInterface = ServiceLocator.adServiceProvider ) : ViewModel() { // ... fun onLoad(isDataCollectionAllowed: Boolean) { // ... viewModelScope.launch { adServiceProvider .configure( \"1800\", parentCoroutineScope = this, cacheSize = 20u, globalParameters = globalParameters, adRequestGlobalParameters = adRequestGlobalParameters ) // ...onSuccess { adService -&gt; // ... } .onSuccess { it.registerRenderer(\"tutorialad\") { serviceLocator -&gt; } } .get( onSuccess = { _state.value = PresentationState.Loaded(Unit) }, onError = { _state.value = PresentationState.Error(it.description) } ) } } // ... } // ... Step 4 . Now let’s take a closer look at the factory method. An important parameter is AdRenderer.ServiceLocator. You can use it as a DI container or a Service Locator when creating your renderer. AdRenderer.ServiceLocator contains all the information and services that can be used when creating a custom renderer. In our case, these are AssetRepository and AdRendererEventHandler. Note: We will look at other services later in this tutorial. All data and services can be found in the AdRenderer.ServiceLocator documentation. File: MainScreen.kt . // ... class MainViewModel( val adServiceProvider: AdServiceProviderInterface = ServiceLocator.adServiceProvider ) : ViewModel() { // ... fun onLoad(isDataCollectionAllowed: Boolean) { // ... viewModelScope.launch { adServiceProvider .configure( \"1800\", parentCoroutineScope = this, cacheSize = 20u, globalParameters = globalParameters, adRequestGlobalParameters = adRequestGlobalParameters ) // ...onSuccess { adService -&gt; // ... } .onSuccess { it.registerRenderer(\"tutorialad\") { serviceLocator -&gt; TutorialRenderer( assetRepository = serviceLocator.assetRepository, eventHandler = serviceLocator.eventHandler ) } } .get( onSuccess = { _state.value = PresentationState.Loaded(Unit) }, onError = { _state.value = PresentationState.Error(it.description) } ) } } // ... } // ... Step 5 . The final step is to add a new AdRequest. To do this, open InlineScreen.kt and add a new AdRequest to the beginning of the requests list in the getDataSource method. File: InlineScreen.kt . // ... class InlineViewModel( private val adService: AdService = ServiceLocator.adService ) : ViewModel() { // ... private suspend fun getDataSource(): List&lt;AdItemState&gt; = supervisorScope { val requests = MutableList(5) { AdRequest( contentUnit = \"4810915\", profiles = hashMapOf(), // Can be skipped keywords = listOf(), // Can be skipped window = null, // Can be skipped timeoutAfterSeconds = 10u, // Can be skipped gdprPd = null, // Can be skipped campaignId = null, // Can be skipped bannerId = null, // Can be skipped isSHBEnabled = null, // Can be skipped dsa = null // Can be skipped ) } requests.add(0, AdRequest(contentUnit = \"5227780\")) requests .mapIndexed { index, request -&gt; async { val itemState = AdItemState( index, adService, request, viewModelScope ) itemState.loadAdvertisement() itemState } } .awaitAll() } } // ... Now you can launch the app and see your new custom ad, congratulations! . ",
    "url": "/nextgen-adsdk-android-release/6.0.0/creating-customised-advertising.html#section-5-registering-a-renderer-in-the-sdk",
    
    "relUrl": "/6.0.0/creating-customised-advertising.html#section-5-registering-a-renderer-in-the-sdk"
  },"23": {
    "doc": "Creating customised advertising",
    "title": "Section 6: Advanced management of advertising resources",
    "content": "Our ad can already load and cache an ad banner via AssetRepository, but there are cases when you want to implement more flexible caching logic, for example, you want to put several ad resources in one folder. In this section, we will look at how to do this. Step 1 . Return to the TutorialRenderer.kt file, and comment out all code related to the AssetRepository. File: TutorialRenderer.kt . class TutorialRenderer( // private val assetRepository: AssetRepository, private val eventHandler: AdRendererEventHandler, private val coroutineScope: CoroutineScope = CoroutineScope( SupervisorJob() + Dispatchers.Main.immediate ) ) : AdRenderer { // ... override suspend fun configure( adResponse: String, adMetadata: AdMetadata ) = jsonFormat.decodeString&lt;TutorialRendererResponse&gt;(adResponse) /* .flatMap { response -&gt; assetRepository .getAsset(response.bannerImage) .onSuccess { assetResult -&gt; assetResult.cacheResult.get( onSuccess = { Log.d(\"TutorialRenderer\", \"Banner cached: $it\") }, onError = { Log.e( \"TutorialRenderer\", \"Banner caching failed: ${it.description}\" ) } ) } .flatMap { it.data.toImageBitmap(response.bannerImage) } .map { Pair(response, it) } } */ .onSuccess { // ... } .onSuccess { (response, banner) -&gt; // ... } .map {} // ... } . Step 2 . We will create our own implementation for loading and caching banner. To do this, we will create a method called getBannerByteArray, which we will use in the AdRenderer.configure method instead of AssetRepository.getAsset. File: TutorialRenderer.kt . class TutorialRenderer( // private val assetRepository: AssetRepository, private val eventHandler: AdRendererEventHandler, private val coroutineScope: CoroutineScope = CoroutineScope( SupervisorJob() + Dispatchers.Main.immediate ) ) : AdRenderer { // ... override suspend fun configure( adResponse: String, adMetadata: AdMetadata ) = jsonFormat.decodeString&lt;TutorialRendererResponse&gt;(adResponse) /* // ... */ .flatMap { response -&gt; getBannerByteArray(response.bannerImage) .flatMap { it.toImageBitmap(response.bannerImage) } .map { Pair(response, it) } } .onSuccess { // ... } .onSuccess { (response, banner) -&gt; // ... } .map {} private suspend fun getBannerByteArray(url: String): AdResult&lt;ByteArray&gt; { } // ... } . Step 3 . To create our own implementation of loading and caching, we can use two other interfaces provided by AdRenderer.ServiceLocator: the AssetCache for working with the cache, and the AssetRequestService which can be used to conveniently load ad resources. We pass them through the constructor. File: TutorialRenderer.kt . class TutorialRenderer( // private val assetRepository: AssetRepository, private val eventHandler: AdRendererEventHandler, private val cache: AssetCache, private val requestService: AssetRequestService, private val coroutineScope: CoroutineScope = CoroutineScope( SupervisorJob() + Dispatchers.Main.immediate ) ) : AdRenderer { // ... private suspend fun getBannerByteArray(url: String): AdResult&lt;ByteArray&gt; { } // ... } . Step 4 . It’s time to implement getBannerByteArray method. The first thing we will create is AssetPath. In our case, we want the file name to be associated with the URL, and this resource is located in the TutorialRendererResources folder. Note: When passing the URL to AssetPath.fromURL, the AssetPath will use the MD5 hash of the passed URL as the file name. You can also use the AssetPath.fromFileName method if you want to pass the file name yourself. File: TutorialRenderer.kt . class TutorialRenderer( // private val assetRepository: AssetRepository, private val eventHandler: AdRendererEventHandler, private val cache: AssetCache, private val requestService: AssetRequestService, private val coroutineScope: CoroutineScope = CoroutineScope( SupervisorJob() + Dispatchers.Main.immediate ) ) : AdRenderer { // ... private suspend fun getBannerByteArray(url: String): AdResult&lt;ByteArray&gt; { val path = AssetPath.fromURL( folder = \"TutorialRendererResources\", // Optional url = url ) } // ... } . Step 5 . Now we can check if our banner is cached via AssetCache.read, if so, we will use the cached data. File: TutorialRenderer.kt . class TutorialRenderer( // private val assetRepository: AssetRepository, private val eventHandler: AdRendererEventHandler, private val cache: AssetCache, private val requestService: AssetRequestService, private val coroutineScope: CoroutineScope = CoroutineScope( SupervisorJob() + Dispatchers.Main.immediate ) ) : AdRenderer { // ... private suspend fun getBannerByteArray(url: String): AdResult&lt;ByteArray&gt; { val path = AssetPath.fromURL( folder = \"TutorialRendererResources\", // Optional url = url ) val cacheResult = cache.read(path).getOrNull() if (cacheResult != null) { val (bytes, uri) = cacheResult Log.d(\"TutorialRenderer\", \"Banner loaded from cache: $uri\") return AdResult.Success(bytes) } Log.d(\"TutorialRenderer\", \"Banner not found in cache\") } // ... } . Step 6 . If not, we can download the banner using AssetRequestService. File: TutorialRenderer.kt . class TutorialRenderer( // private val assetRepository: AssetRepository, private val eventHandler: AdRendererEventHandler, private val cache: AssetCache, private val requestService: AssetRequestService, private val coroutineScope: CoroutineScope = CoroutineScope( SupervisorJob() + Dispatchers.Main.immediate ) ) : AdRenderer { // ... private suspend fun getBannerByteArray(url: String): AdResult&lt;ByteArray&gt; { val path = AssetPath.fromURL( folder = \"TutorialRendererResources\", // Optional url = url ) val cacheResult = cache.read(path).getOrNull() if (cacheResult != null) { val (bytes, uri) = cacheResult Log.d(\"TutorialRenderer\", \"Banner loaded from cache: $uri\") return AdResult.Success(bytes) } Log.d(\"TutorialRenderer\", \"Banner not found in cache\") return requestService.request(url) } // ... } . Step 7 . Since the banner has already been loaded, we would like to cache it for future use. To do this, you can use the AssetCache.write method. File: TutorialRenderer.kt . class TutorialRenderer( // private val assetRepository: AssetRepository, private val eventHandler: AdRendererEventHandler, private val cache: AssetCache, private val requestService: AssetRequestService, private val coroutineScope: CoroutineScope = CoroutineScope( SupervisorJob() + Dispatchers.Main.immediate ) ) : AdRenderer { // ... private suspend fun getBannerByteArray(url: String): AdResult&lt;ByteArray&gt; { val path = AssetPath.fromURL( folder = \"TutorialRendererResources\", // Optional url = url ) val cacheResult = cache.read(path).getOrNull() if (cacheResult != null) { val (bytes, uri) = cacheResult Log.d(\"TutorialRenderer\", \"Banner loaded from cache: $uri\") return AdResult.Success(bytes) } Log.d(\"TutorialRenderer\", \"Banner not found in cache\") return requestService.request(url) .onSuccess { bytes -&gt; cache.write(path, bytes) .get( onSuccess = { Log.d( \"TutorialRenderer\", \"Banner cached after download: $it\" ) }, onError = { Log.e( \"TutorialRenderer\", \"Banner loaded, but caching failed: ${it.description}\" ) } ) } } // ... } . Step 8 . You can also remove files from the cache if you need to. Note: Most often, you do not need to remove resources manually, as the SDK itself manages the removal of files from the cache using a FIFO strategy and a cache size that is set from the app. File: TutorialRenderer.kt . class TutorialRenderer( // private val assetRepository: AssetRepository, private val eventHandler: AdRendererEventHandler, private val cache: AssetCache, private val requestService: AssetRequestService, private val coroutineScope: CoroutineScope = CoroutineScope( SupervisorJob() + Dispatchers.Main.immediate ) ) : AdRenderer { // ... private suspend fun getBannerByteArray(url: String): AdResult&lt;ByteArray&gt; { val path = AssetPath.fromURL( folder = \"TutorialRendererResources\", // Optional url = url ) // cache.remove(path) // ... } // ... } . Step 9 . The final step is to pass AssetCache and AssetRequestService from AdRenderer.ServiceLocator instead of AssetRepository in MainScreen.kt. File: MainScreen.kt . // ... class MainViewModel( val adServiceProvider: AdServiceProviderInterface = ServiceLocator.adServiceProvider ) : ViewModel() { // ... fun onLoad(isDataCollectionAllowed: Boolean) { // ... viewModelScope.launch { adServiceProvider .configure( \"1800\", parentCoroutineScope = this, cacheSize = 20u, globalParameters = globalParameters, adRequestGlobalParameters = adRequestGlobalParameters ) // ...onSuccess { adService -&gt; // ... } .onSuccess { it.registerRenderer(\"tutorialad\") { serviceLocator -&gt; TutorialRenderer( cache = serviceLocator.assetCache, requestService = serviceLocator.assetRequestService, eventHandler = serviceLocator.eventHandler ) } } .get( onSuccess = { _state.value = PresentationState.Loaded(Unit) }, onError = { _state.value = PresentationState.Error(it.description) } ) } } // ... } // ... Congratulations, we have implemented our own caching and loading logic! . ",
    "url": "/nextgen-adsdk-android-release/6.0.0/creating-customised-advertising.html#section-6-advanced-management-of-advertising-resources",
    
    "relUrl": "/6.0.0/creating-customised-advertising.html#section-6-advanced-management-of-advertising-resources"
  },"24": {
    "doc": "First steps for working with AdSDK",
    "title": "First steps for working with AdSDK",
    "content": "This tutorial will guide you through the first steps of working with the AdSDK - creating an AdService. You can download this this project which already implements all the steps of this tutorial. ",
    "url": "/nextgen-adsdk-android-release/6.0.0/first-steps.html",
    
    "relUrl": "/6.0.0/first-steps.html"
  },"25": {
    "doc": "First steps for working with AdSDK",
    "title": "Section 1: App creation and preparation",
    "content": "Creating and preparing a tutorial application before working with AdSDK. Step 1 . Create a new Android project and remove any unnecessary code. Make sure you have added the correct packages from the readme. Step 2 . In real projects, you will most likely use different libraries for DI. For a simple example, we create an object called ServiceLocator in di package. In addition, we will create an Application class. File: ServiceLocator.kt . object ServiceLocator { } . File: App.kt . class App : Application() { override fun onCreate() { super.onCreate() } } . Step 3 . After that, we will create MainScreen in presentation/screens as our start screen and add it to the MainActivity. File: MainScreen.kt . @Composable fun MainScreen( viewModel: MainViewModel = viewModel() ) { } class MainViewModel : ViewModel() { } . File: MainActivity.kt . class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) enableEdgeToEdge() setContent { TutorialAppTheme { MainScreen() } } } } . Note: The [AdService.configure] method makes one request to the ad server to get and set a cookie. Make sure you set the necessary [GlobalParameters], if needed.. Step 4 . As the final step in preparing the application, we will create a PresentationState in presentation/entities that we will use on future screens, and a PresentationStateContainer composable in ui/components to display this state. With their help, we can easily monitor the state of the future screens with the transfer of the data we need. File: PresentationState.kt . sealed class PresentationState&lt;out Data&gt; { object Loading : PresentationState&lt;Nothing&gt;() data class Error(val description: String) : PresentationState&lt;Nothing&gt;() data class Loaded&lt;Data&gt;(val data: Data) : PresentationState&lt;Data&gt;() } . File: PresentationStateContainer.kt . @Composable fun &lt;Data&gt; PresentationStateContainer( state: PresentationState&lt;Data&gt;, modifier: Modifier = Modifier, content: @Composable (data: Data) -&gt; Unit ) { when (state) { is PresentationState.Loading -&gt; { Box( contentAlignment = Alignment.Center, modifier = modifier ) { CircularProgressIndicator() } } is PresentationState.Error -&gt; { Box( contentAlignment = Alignment.Center, modifier = modifier ) { Text(text = state.description, color = Color.Red) } } is PresentationState.Loaded -&gt; content(state.data) } } . ",
    "url": "/nextgen-adsdk-android-release/6.0.0/first-steps.html#section-1-app-creation-and-preparation",
    
    "relUrl": "/6.0.0/first-steps.html#section-1-app-creation-and-preparation"
  },"26": {
    "doc": "First steps for working with AdSDK",
    "title": "Section 2: Creating an AdService",
    "content": "Creating and configuring an AdService for later ad creation and loading. Step 1 . The entry point into the SDK is the AdServiceProvider class and the AdService interface. AdService is the main class that we will use to create ads in the future. In turn, AdServiceProvider is a class that we can use in the DI container. It is responsible for configuring and storing AdService. We add AdServiceProvider to the ServiceLocator and initialise it by passing applicationContext to it. File: ServiceLocator.kt . object ServiceLocator { lateinit var adServiceProvider: AdServiceProviderInterface private set fun init(context: Context) { adServiceProvider = AdServiceProvider(context) } } . File: App.kt . class App : Application() { override fun onCreate() { super.onCreate() ServiceLocator.init(applicationContext) } } . Step 2 . The first thing we need to do is configure AdService using the AdServiceProvider.configure method. To do this, we need to pass at least two parameters: . | networkId – identifier of your advertising account. | parentCoroutineScope – coroutine scope that defines the lifetime of the AdService. | . File: MainScreen.kt . // ... class MainViewModel( val adServiceProvider: AdServiceProviderInterface = ServiceLocator.adServiceProvider ) : ViewModel() { init { viewModelScope.launch { adServiceProvider.configure( \"1800\", parentCoroutineScope = this ) } } } . Step 3 . AdServiceProvider.configure returns AdResult, which is our custom AdSDK implementation of Kotlin’s Result. AdResult contains AdError - the only type of error which the SDK supports. We can use AdResult to check that the AdService has been successfully configured and initialised. We will process the AdService configuration result using the PresentationState we created earlier. If the service is configured, the state will be changed to Loaded; otherwise, we will change it to Error with the error description. File: MainScreen.kt . // ... class MainViewModel( val adServiceProvider: AdServiceProviderInterface = ServiceLocator.adServiceProvider ) : ViewModel() { private val _state = MutableStateFlow&lt;PresentationState&lt;Unit&gt;&gt;( PresentationState.Loading ) val state = _state.asStateFlow() init { viewModelScope.launch { adServiceProvider.configure( \"1800\", parentCoroutineScope = this ).get( onSuccess = { _state.value = PresentationState.Loaded(Unit) }, onError = { _state.value = PresentationState.Error(it.description) } ) } } } . Step 4 . We can now use MainViewModel.state in the MainScreen and handle it using PresentationStateContainer. File: MainScreen.kt . @Composable fun MainScreen( viewModel: MainViewModel = viewModel() ) { val uiState by viewModel.state.collectAsState() PresentationStateContainer( uiState, Modifier.fillMaxSize() ) { Text(\"Ready\") } } // ... Step 5 . As a final step, let’s prepare the AdService so it’s easier to use in the upcoming components. Once again, you’ll likely be using different libraries for DI. Since our AdService will live as a singleton, we ensure that it will only be used after configuration. In this case, we can call the AdServiceProvider.get method and be sure that it will never return an error. Note: If you call the AdServiceProvider.get method before successfully configuring AdService, you will receive an AdError.Configuration error. File: ServiceLocator.kt . object ServiceLocator { lateinit var adServiceProvider: AdServiceProviderInterface private set val adService: AdService get() = when (val serviceResult = adServiceProvider.get()) { is AdResult.Success -&gt; serviceResult.result is AdResult.Error -&gt; throw Exception(serviceResult.error.description) } fun init(context: Context) { adServiceProvider = AdServiceProvider(context) } } . Now, if you’ve done everything right, you should see the “Ready” message when you launch the app. This completes the AdService configuration, congratulations! . ",
    "url": "/nextgen-adsdk-android-release/6.0.0/first-steps.html#section-2-creating-an-adservice",
    
    "relUrl": "/6.0.0/first-steps.html#section-2-creating-an-adservice"
  },"27": {
    "doc": "Global request parameters",
    "title": "Global request parameters",
    "content": "We already know how to create and perform AdRequest, TagRequest, and TrackingRequest. However, each of them can have additional parameters, which are called global parameters because they are specified globally for all requests. The SDK provides the ability to add global parameters once so that you don’t have to copy them when creating each request. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/6.0.0/global-request-parameters.html",
    
    "relUrl": "/6.0.0/global-request-parameters.html"
  },"28": {
    "doc": "Global request parameters",
    "title": "Section 1: Preparing the app",
    "content": "The application should ask whether it is permitted to collect data about the user. In this section, we will add functionality for this. Step 1 . Let’s open MainScreen.kt. Since we need to ask the user for permission, we create an AlertDialog in MainScreen. File: MainScreen.kt . // ... @Composable fun MainScreen( navController: NavController, viewModel: MainViewModel = viewModel() ) { val uiState by viewModel.state.collectAsState() val showDialog by viewModel.showDialog.collectAsState() if (showDialog) { AlertDialog( onDismissRequest = { viewModel.showDialog.value = false viewModel.onLoad(false) }, text = { Text(\"Please grant the permission to collect the data\") }, confirmButton = { TextButton(onClick = { viewModel.showDialog.value = false viewModel.onLoad(true) }) { Text(\"Allow\") } }, dismissButton = { TextButton(onClick = { viewModel.showDialog.value = false viewModel.onLoad(false) }) { Text(\"Deny\") } } ) } // ... } class MainViewModel( val adServiceProvider: AdServiceProviderInterface = ServiceLocator.adServiceProvider ) : ViewModel() { private val _state = MutableStateFlow&lt;PresentationState&lt;Unit&gt;&gt;( PresentationState.Loading ) val state = _state.asStateFlow() val showDialog = MutableStateFlow(true) init { // ... } fun onLoad(isDataCollectionAllowed: Boolean) { } } . Step 2 . Since the AdService configuration contains cookies loading logic, we should obtain permission before calling AdServiceProvider.configure. To do this, we will move the configuration logic from init to the new onLoad method. Thus, when configuring AdService, we will already have the isDataCollectionAllowed parameter. File: MainScreen.kt . // ... class MainViewModel( val adServiceProvider: AdServiceProviderInterface = ServiceLocator.adServiceProvider ) : ViewModel() { private val _state = MutableStateFlow&lt;PresentationState&lt;Unit&gt;&gt;( PresentationState.Loading ) val state = _state.asStateFlow() val showDialog = MutableStateFlow(true) fun onLoad(isDataCollectionAllowed: Boolean) { viewModelScope.launch { adServiceProvider.configure( \"1800\", parentCoroutineScope = this ).get( onSuccess = { _state.value = PresentationState.Loaded(Unit) }, onError = { _state.value = PresentationState.Error(it.description) } ) } } } . Step 3 . The final step will be to add a couple of extensions so that we can use AdService after successful configuration. In this code, after successful configuration via AdServiceProvider.configure, we obtain AdService using the AdServiceProvider.get method. After that, we call the onSuccess method, which we will use in the future to work with AdService. File: MainScreen.kt . // ... class MainViewModel( val adServiceProvider: AdServiceProviderInterface = ServiceLocator.adServiceProvider ) : ViewModel() { // ... fun onLoad(isDataCollectionAllowed: Boolean) { viewModelScope.launch { adServiceProvider .configure( \"1800\", parentCoroutineScope = this ) .flatMap { adServiceProvider.get() } .onSuccess { adService -&gt; } .get( onSuccess = { _state.value = PresentationState.Loaded(Unit) }, onError = { _state.value = PresentationState.Error(it.description) } ) } } } private suspend fun &lt;T, ActionResult&gt; AdResult&lt;T&gt;.flatMap( action: suspend (T) -&gt; AdResult&lt;ActionResult&gt; ): AdResult&lt;ActionResult&gt; { return when (this) { is AdResult.Success -&gt; action(this.result) is AdResult.Error -&gt; AdResult.Error(this.error) } } private suspend fun &lt;T&gt; AdResult&lt;T&gt;.onSuccess( action: suspend (T) -&gt; Unit ) : AdResult&lt;T&gt; { return when (this) { is AdResult.Success -&gt; { action(this.result) this } is AdResult.Error -&gt; this } } . Now we can move on to the global parameters! . ",
    "url": "/nextgen-adsdk-android-release/6.0.0/global-request-parameters.html#section-1-preparing-the-app",
    
    "relUrl": "/6.0.0/global-request-parameters.html#section-1-preparing-the-app"
  },"29": {
    "doc": "Global request parameters",
    "title": "Section 2: Setting &amp; modifying global parameters",
    "content": "In this section, we will learn about GlobalParameters and AdRequestGlobalParameters. We will pass the AccessMode parameter depending on the user’s permission and specify how the server should work with cookies each time AdRequest is executed. Step 1 . Let’s continue working in the MainViewModel and focus on the onLoad method. Since the AdServiceProvider.configure method includes logic for loading cookies, we should pass user permission before the SDK makes this request. We can do this using the globalParameters parameter, which accepts GlobalParameters. GlobalParameters is an object for storing common global parameters that will be applied when creating an AdRequest, TagRequest, and TrackingRequest. We will create GlobalParameters with AccessMode, which will depend on the user’s choice. This way, the ad server will know whether it can identify the user using cookies at the AdService configuration stage. Note: GlobalParameters.accessMode is not the only global parameter for AdRequest, TagRequest, and TrackingRequest. A list of all global parameters can be found in the GlobalParameters documentation. File: MainScreen.kt . // ... class MainViewModel( val adServiceProvider: AdServiceProviderInterface = ServiceLocator.adServiceProvider ) : ViewModel() { // ... fun onLoad(isDataCollectionAllowed: Boolean) { val globalParameters = GlobalParameters( accessMode = isDataCollectionAllowed.toAccessMode() ) viewModelScope.launch { adServiceProvider .configure( \"1800\", parentCoroutineScope = this, globalParameters = globalParameters ) .flatMap { adServiceProvider.get() } .onSuccess { adService -&gt; } .get( onSuccess = { _state.value = PresentationState.Loaded(Unit) }, onError = { _state.value = PresentationState.Error(it.description) } ) } } } private fun Boolean.toAccessMode() = if (this) AccessMode.OPT_IN else AccessMode.OPT_OUT // ... Step 2 . In addition, sometimes you need to be able to modify or remove the GlobalParameters. You can use AdService.setGlobalParameters and AdService.removeGlobalParameter for this purpose. Note: You can pass multiple GlobalParameter at once to the AdService.setGlobalParameters method by separating them with commas. File: MainScreen.kt . // ... class MainViewModel( val adServiceProvider: AdServiceProviderInterface = ServiceLocator.adServiceProvider ) : ViewModel() { // ... fun onLoad(isDataCollectionAllowed: Boolean) { val globalParameters = GlobalParameters( accessMode = isDataCollectionAllowed.toAccessMode() ) viewModelScope.launch { adServiceProvider .configure( \"1800\", parentCoroutineScope = this, globalParameters = globalParameters ) .flatMap { adServiceProvider.get() } .onSuccess { adService -&gt; adService.setGlobalParameters( GlobalParameter( GlobalParameters::externalUID, ExternalUID(\"uid\") ) ) adService.removeGlobalParameter(GlobalParameters::externalUID) } .get( onSuccess = { _state.value = PresentationState.Loaded(Unit) }, onError = { _state.value = PresentationState.Error(it.description) } ) } } } // ... Step 3 . Although GlobalParameters are added to each AdRequest, TagRequest, and TrackingRequest, AdRequest has separate AdRequestGlobalParameters that will only be added to it. We implement logic where we allow the server to read cookies if the user has given permission to use personal data. Otherwise, we prohibit the use of cookies. To do this, we use the adRequestGlobalParameters parameter with the CookiesAccess property passed. Note: AdRequestGlobalParameters.cookiesAccess is not the only global parameter specific for AdRequest. A list of all global parameters can be found in the AdRequestGlobalParameters documentation. File: MainScreen.kt . // ... class MainViewModel( val adServiceProvider: AdServiceProviderInterface = ServiceLocator.adServiceProvider ) : ViewModel() { // ... fun onLoad(isDataCollectionAllowed: Boolean) { val globalParameters = GlobalParameters( accessMode = isDataCollectionAllowed.toAccessMode() ) val adRequestGlobalParameters = AdRequestGlobalParameters( cookiesAccess = isDataCollectionAllowed.toCookiesAccess() ) viewModelScope.launch { adServiceProvider .configure( \"1800\", parentCoroutineScope = this, globalParameters = globalParameters, adRequestGlobalParameters = adRequestGlobalParameters ) .flatMap { adServiceProvider.get() } .onSuccess { adService -&gt; // ... } .get( onSuccess = { _state.value = PresentationState.Loaded(Unit) }, onError = { _state.value = PresentationState.Error(it.description) } ) } } } private fun Boolean.toCookiesAccess(): AdRequestGlobalParameters.CookiesAccess { return if (this) { AdRequestGlobalParameters.CookiesAccess.GET } else { AdRequestGlobalParameters.CookiesAccess.NO_COOKIES } } // ... Step 4 . Just like with GlobalParameters, you can modify and remove the AdRequestGlobalParameter. You can use AdService.setAdRequestGlobalParameters and AdService.removeAdRequestGlobalParameter for this purpose. Note: You can pass multiple AdRequestGlobalParameter at once to the AdService.setAdRequestGlobalParameters method by separating them with commas. File: MainScreen.kt . // ... class MainViewModel( val adServiceProvider: AdServiceProviderInterface = ServiceLocator.adServiceProvider ) : ViewModel() { // ... fun onLoad(isDataCollectionAllowed: Boolean) { val globalParameters = GlobalParameters( accessMode = isDataCollectionAllowed.toAccessMode() ) val adRequestGlobalParameters = AdRequestGlobalParameters( cookiesAccess = isDataCollectionAllowed.toCookiesAccess() ) viewModelScope.launch { adServiceProvider .configure( \"1800\", parentCoroutineScope = this, globalParameters = globalParameters, adRequestGlobalParameters = adRequestGlobalParameters ) .flatMap { adServiceProvider.get() } .onSuccess { adService -&gt; // ... adService.setAdRequestGlobalParameters( AdRequestGlobalParameter( AdRequestGlobalParameters::isIpIdentified, true ) ) adService.removeAdRequestGlobalParameter( AdRequestGlobalParameters::isIpIdentified ) } .get( onSuccess = { _state.value = PresentationState.Loaded(Unit) }, onError = { _state.value = PresentationState.Error(it.description) } ) } } } // ... Now the ad server will know whether it has permission to process personal data each time AdRequest, TagRequest, and TrackingRequest are executed. In addition, we have specified how the server should work with cookies when AdRequest is executed. Congratulations! . ",
    "url": "/nextgen-adsdk-android-release/6.0.0/global-request-parameters.html#section-2-setting--modifying-global-parameters",
    
    "relUrl": "/6.0.0/global-request-parameters.html#section-2-setting--modifying-global-parameters"
  },"30": {
    "doc": "Handling the ad events",
    "title": "Monitor and process ad-related events",
    "content": "Advertisement do a lot of work under the hood and can send messages about them to the app. In turn, you can monitor and react to it in some way. In this tutorial, we’ll look at what events are handled by Advertisement and how we can interact with them. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/6.0.0/handling-the-ad-events.html#monitor-and-process-ad-related-events",
    
    "relUrl": "/6.0.0/handling-the-ad-events.html#monitor-and-process-ad-related-events"
  },"31": {
    "doc": "Handling the ad events",
    "title": "Section 1: Monitoring of ad-related events",
    "content": "In this section, we’ll look at how you can know when and what kind of event happened. Step 1 . Let’s open AdItem.kt, and pay attention to the parameters of the AdService.makeAdvertisement method. File: AdItem.kt . // ... class AdItemState( val id: Int, private val adService: AdService, private val request: AdRequest ) { // ... suspend fun loadAdvertisement() { _state.value = PresentationState.Loading adService .makeAdvertisement( adRequest = request, placementType = AdPlacementType.INLINE, // Inline by default targetURLHandler = null, // Can be skipped adEventListener = null // Can be skipped ) .map { ItemData(it, it.getMetadata()?.aspectRatio) } .get( onSuccess = { data -&gt; advertisement = data.advertisement _state.value = PresentationState.Loaded(data) }, onError = { error -&gt; _state.value = PresentationState.Error(error.description) } ) } // ... } // ... Step 2 . To monitor and interact with any ad event, we should implement AdEventListener and pass it when creating an Advertisement. File: AdItem.kt . // ... class AdItemState( val id: Int, private val adService: AdService, private val request: AdRequest ) { // ... suspend fun loadAdvertisement() { _state.value = PresentationState.Loading adService .makeAdvertisement( adRequest = request, placementType = AdPlacementType.INLINE, // Inline by default targetURLHandler = null, // Can be skipped adEventListener = eventListener ) .map { ItemData(it, it.getMetadata()?.aspectRatio) } .get( onSuccess = { data -&gt; advertisement = data.advertisement _state.value = PresentationState.Loaded(data) }, onError = { error -&gt; _state.value = PresentationState.Error(error.description) } ) } // ... private val eventListener = object : AdEventListener { } } // ... Now we’re ready to get started with various advertising-related events! . ",
    "url": "/nextgen-adsdk-android-release/6.0.0/handling-the-ad-events.html#section-1-monitoring-of-ad-related-events",
    
    "relUrl": "/6.0.0/handling-the-ad-events.html#section-1-monitoring-of-ad-related-events"
  },"32": {
    "doc": "Handling the ad events",
    "title": "Section 2: Request to unload or hide ad",
    "content": "In this section, we’ll look at how an Advertisement can signal to unload or hide the ad. Step 1 . To monitor the moment when an ad wants to be removed or hidden, you can implement AdEventListener.unloadRequest. You may already remember its use with interstitial ads, where it is an essential part of the implementation. In the case of inline ads, this method can also be used in customised ads. Note: If you know that you do not have inline ads that can be hidden or removed, you can ignore this method for inline ads. File: AdItem.kt . // ... class AdItemState( val id: Int, private val adService: AdService, private val request: AdRequest ) { // ... private val eventListener = object : AdEventListener { override fun unloadRequest() { } } } // ... Step 2 . Let’s implement this method so that it displays the message to the user and removes the Advertisement. File: AdItem.kt . // ... class AdItemState( val id: Int, private val adService: AdService, private val request: AdRequest ) { // ... private val eventListener = object : AdEventListener { override fun unloadRequest() { _state.value = PresentationState.Error(\"Unloaded by event listener\") advertisement?.dispose() advertisement = null } } } // ... ",
    "url": "/nextgen-adsdk-android-release/6.0.0/handling-the-ad-events.html#section-2-request-to-unload-or-hide-ad",
    
    "relUrl": "/6.0.0/handling-the-ad-events.html#section-2-request-to-unload-or-hide-ad"
  },"33": {
    "doc": "Handling the ad events",
    "title": "Section 3: Monitor and process advertising tracking events",
    "content": "Advertisement can perform tracking, depending on the response from the server. The SDK uses AdTrackingEvent to identify them. Most often, you’ll use these methods for debugging or handling errors related to tracking. In this section, we’ll look how we can work with AdTrackingEvent. Step 1 . You can use two methods to monitor tracking events: . | AdEventListener.trackingEventProcessed | AdEventListener.trackingEventProcessingFailed | . File: AdItem.kt . // ... class AdItemState( val id: Int, private val adService: AdService, private val request: AdRequest ) { // ... private val eventListener = object : AdEventListener { // ... override fun trackingEventProcessed( event: AdTrackingEvent, processedURLs: List&lt;String&gt;, metadata: AdMetadata ) { } override suspend fun trackingEventProcessingFailed( event: AdTrackingEvent, processedURLs: List&lt;String&gt;, failedURLs: Map&lt;String, AdError&gt; ): AdEventListener.FailureAction { } } } // ... Step 2 . Let’s start with AdEventListener.trackingEventProcessed, it signals a successful tracking on the server. As you can see, one AdTrackingEvent can have multiple URLs to track on the server, so you have the processedURLs parameter, which contains a list of all the URLs that were requested. File: AdItem.kt . // ... class AdItemState( val id: Int, private val adService: AdService, private val request: AdRequest ) { // ... private val eventListener = object : AdEventListener { // ... override fun trackingEventProcessed( event: AdTrackingEvent, processedURLs: List&lt;String&gt;, metadata: AdMetadata ) { when (event) { is AdTrackingEvent.Impression -&gt; { Log.d(\"AdItemState\", \"My ad $id is ready\") } is AdTrackingEvent.Viewable -&gt; { Log.d( \"AdItemState\", \"${event.percentage.value}% of my ad $id is now visible on the screen.\" ) } } Log.d( \"AdItemState\", \"SDK notified server about that via URLs: $processedURLs\" ) } override suspend fun trackingEventProcessingFailed( event: AdTrackingEvent, processedURLs: List&lt;String&gt;, failedURLs: Map&lt;String, AdError&gt; ): AdEventListener.FailureAction { } } } // ... Step 3 . AdEventListener.trackingEventProcessingFailed is called in case of an error. In this case, since the event can have several URLs, you get a list of those URLs that were successfully requested and those that failed. File: AdItem.kt . // ... class AdItemState( val id: Int, private val adService: AdService, private val request: AdRequest ) { // ... private val eventListener = object : AdEventListener { // ... override fun trackingEventProcessed( event: AdTrackingEvent, processedURLs: List&lt;String&gt;, metadata: AdMetadata ) { // ... } override suspend fun trackingEventProcessingFailed( event: AdTrackingEvent, processedURLs: List&lt;String&gt;, failedURLs: Map&lt;String, AdError&gt; ): AdEventListener.FailureAction { when (event) { is AdTrackingEvent.Impression -&gt; { Log.d(\"AdItemState\", \"My ad $id is ready\") } is AdTrackingEvent.Viewable -&gt; { Log.d( \"AdItemState\", \"${event.percentage.value}% of my ad $id is now visible on the screen.\" ) } } Log.d( \"AdItemState\", \"\"\" SDK notified server about that via URLs: $processedURLs\", but failed during requesting those: $failedURLs \"\"\".trimIndent() ) } } } // ... Step 4 . In addition, you should specify how you want to handle this error with AdEventListener.FailureAction. You can either AdEventListener.FailureAction.IGNORE the error, in which case the server will not know about this event, or try to AdEventListener.FailureAction.RETRY the requests to the URLs that failed. File: AdItem.kt . // ... class AdItemState( val id: Int, private val adService: AdService, private val request: AdRequest ) { // ... private val eventListener = object : AdEventListener { // ... override fun trackingEventProcessed( event: AdTrackingEvent, processedURLs: List&lt;String&gt;, metadata: AdMetadata ) { // ... } override suspend fun trackingEventProcessingFailed( event: AdTrackingEvent, processedURLs: List&lt;String&gt;, failedURLs: Map&lt;String, AdError&gt; ): AdEventListener.FailureAction { when (event) { is AdTrackingEvent.Impression -&gt; { Log.d(\"AdItemState\", \"My ad $id is ready\") } is AdTrackingEvent.Viewable -&gt; { Log.d( \"AdItemState\", \"${event.percentage.value}% of my ad $id is now visible on the screen.\" ) } } Log.d( \"AdItemState\", \"\"\" SDK notified server about that via URLs: $processedURLs\", but failed during requesting those: $failedURLs \"\"\".trimIndent() ) return AdEventListener.FailureAction.IGNORE } } } // ... ",
    "url": "/nextgen-adsdk-android-release/6.0.0/handling-the-ad-events.html#section-3-monitor-and-process-advertising-tracking-events",
    
    "relUrl": "/6.0.0/handling-the-ad-events.html#section-3-monitor-and-process-advertising-tracking-events"
  },"34": {
    "doc": "Handling the ad events",
    "title": "Section 4: Monitor and process advertising tap events",
    "content": "As a rule, tapping on an ad will trigger a AdTapEvent in the SDK. This can be either a simple opening of the URL to the user in an external browser or more complex logic with redirect processing. In this section, we’ll look how we can work with AdTapEvent. Most often, you’ll use it for debugging or handling tap-related errors. Step 1 . Same with tracking events, you can use two methods to monitor tap events: . | AdEventListener.tapEventProcessed | AdEventListener.tapEventProcessingFailed | . File: AdItem.kt . // ... class AdItemState( val id: Int, private val adService: AdService, private val request: AdRequest ) { // ... private val eventListener = object : AdEventListener { // ... override fun tapEventProcessed( event: AdTapEvent, processedURL: String, metadata: AdMetadata ) { } override suspend fun tapEventProcessingFailed( event: AdTapEvent, error: AdError ): AdEventListener.FailureAction { } } } // ... Step 2 . Let’s start with AdEventListener.tapEventProcessed, it signals a successful tap processing. As you can see, all AdTapEvent except AdTapEvent.SilentTap should eventually show something to the user. In the case of AdTapEvent.SilentTap, the SDK only handles the tracking associated with the tap. Note: You can read the AdTapEvent.SilentTap documentation to better understand when this event is used. File: AdItem.kt . // ... class AdItemState( val id: Int, private val adService: AdService, private val request: AdRequest ) { // ... private val eventListener = object : AdEventListener { // ... override fun tapEventProcessed( event: AdTapEvent, processedURL: String, metadata: AdMetadata ) { when (event) { is AdTapEvent.Tap, is AdTapEvent.TapURL -&gt; { Log.d( \"AdItemState\", \"\"\" User tapped on my ad $id. $processedURL opened for the user. \"\"\".trimIndent() ) } is AdTapEvent.TapAsset -&gt; { Log.d( \"AdItemState\", \"\"\" User tapped on asset ${event.id} of my ad $id. $processedURL opened for the user. \"\"\".trimIndent() ) } is AdTapEvent.SilentTap -&gt; { Log.d( \"AdItemState\", \"\"\" The renderer of ad $id want to process click counter redirect. URL for redirect: ${event.url}. As a result of redirects we get $processedURL. This URL is NOT opened for the user. \"\"\".trimIndent() ) } } } override suspend fun tapEventProcessingFailed( event: AdTapEvent, error: AdError ): AdEventListener.FailureAction { } } } // ... Step 3 . AdEventListener.tapEventProcessingFailed is called in case of an error. In this case, we get the AdTapEvent that caused the AdError. Just like with AdTrackingEvent, you can decide how you will handle this error with AdEventListener.FailureAction. Note: Most often, the error is related to an incorrect URL received in the advertisement, but in the case of AdTapEvent.SilentTap, it can be errors related to redirect processing. File: AdItem.kt . // ... class AdItemState( val id: Int, private val adService: AdService, private val request: AdRequest ) { // ... private val eventListener = object : AdEventListener { // ... override fun tapEventProcessed( event: AdTapEvent, processedURL: String, metadata: AdMetadata ) { // ... } override suspend fun tapEventProcessingFailed( event: AdTapEvent, error: AdError ): AdEventListener.FailureAction { when (event) { is AdTapEvent.Tap, is AdTapEvent.TapURL -&gt; { Log.d(\"AdItemState\", \"User tapped on my ad $id.\") } is AdTapEvent.TapAsset -&gt; { Log.d(\"AdItemState\", \"User tapped on asset ${event.id} of my ad $id\") } is AdTapEvent.SilentTap -&gt; { Log.d( \"AdItemState\", \"\"\" The renderer of ad $id want to process click counter redirect. URL for redirect: ${event.url}. \"\"\".trimIndent() ) } } Log.d(\"AdItemState\", \"But processing failed with error: ${error.description}\") return AdEventListener.FailureAction.IGNORE } } } // ... ",
    "url": "/nextgen-adsdk-android-release/6.0.0/handling-the-ad-events.html#section-4-monitor-and-process-advertising-tap-events",
    
    "relUrl": "/6.0.0/handling-the-ad-events.html#section-4-monitor-and-process-advertising-tap-events"
  },"35": {
    "doc": "Handling the ad events",
    "title": "Section 5: Monitor and process custom advertising events",
    "content": "The AdSDK offers extensive customisation functionality, such as creating customised ads and sending customised events. In this section, we will consider only those events that can occur when using a custom renderer or custom HTML advertising. Step 1 . Let’s start with the simplest event, when the AdRenderer wants to notify the application of an event with a name and an optional message – AdEventListener.rendererMessageReceived. File: AdItem.kt . // ... class AdItemState( val id: Int, private val adService: AdService, private val request: AdRequest ) { // ... private val eventListener = object : AdEventListener { // ... override fun rendererMessageReceived(name: String, message: String?) { } } } // ... Step 2 . The renderer can send any message that you can process. In our case, we just want to log this event. File: AdItem.kt . // ... class AdItemState( val id: Int, private val adService: AdService, private val request: AdRequest ) { // ... private val eventListener = object : AdEventListener { // ... override fun rendererMessageReceived(name: String, message: String?) { Log.d( \"AdItemState\", \"\"\" Renderer of my ad $id sent me a message. Name: $name, message: $message\" We can create custom logic in the application based on it. \"\"\".trimIndent() ) } } } // ... Step 3 . In addition, the custom AdRenderer can perform custom tracking. To monitor such events, you can use: . | AdEventListener.customTrackingEventProcessed | AdEventListener.customTrackingEventProcessingFailed | . File: AdItem.kt . // ... class AdItemState( val id: Int, private val adService: AdService, private val request: AdRequest ) { // ... private val eventListener = object : AdEventListener { // ... override fun customTrackingEventProcessed(name: String, url: String, metadata: AdMetadata) { } override suspend fun customTrackingEventProcessingFailed( name: String, url: String, error: AdError ): AdEventListener.FailureAction { } } } // ... Step 4 . The logic is similar to tracking or tap events monitoring and handling. You can get the name of the event, the URL where the request was made, a possible error, and decide how to handle it. File: AdItem.kt . // ... class AdItemState( val id: Int, private val adService: AdService, private val request: AdRequest ) { // ... private val eventListener = object : AdEventListener { // ... override fun customTrackingEventProcessed(name: String, url: String, metadata: AdMetadata) { Log.d( \"AdItemState\", \"Custom tracking event '$name' of my ad $id processed. URL: $url\" ) } override suspend fun customTrackingEventProcessingFailed( name: String, url: String, error: AdError ): AdEventListener.FailureAction { Log.d( \"AdItemState\", \"\"\" Custom tracking event '$name' of my ad $id failed during processing. URL: $url, error: ${error.description} \"\"\".trimIndent() ) return AdEventListener.FailureAction.IGNORE } } } // ... ",
    "url": "/nextgen-adsdk-android-release/6.0.0/handling-the-ad-events.html#section-5-monitor-and-process-custom-advertising-events",
    
    "relUrl": "/6.0.0/handling-the-ad-events.html#section-5-monitor-and-process-custom-advertising-events"
  },"36": {
    "doc": "Handling the ad events",
    "title": "Handling the ad events",
    "content": " ",
    "url": "/nextgen-adsdk-android-release/6.0.0/handling-the-ad-events.html",
    
    "relUrl": "/6.0.0/handling-the-ad-events.html"
  },"37": {
    "doc": "Meet nextgen AdSDK",
    "title": "Meet nextgen AdSDK",
    "content": "Manage, display, and create your custom advertisements on Android using cutting-edge technologies such as Jetpack Compose and Coroutines based on the AdSDK. ",
    "url": "/nextgen-adsdk-android-release/6.0.0/meet-adsdk.html",
    
    "relUrl": "/6.0.0/meet-adsdk.html"
  },"38": {
    "doc": "Meet nextgen AdSDK",
    "title": "Chapter 1",
    "content": "Working with the built-in capabilities of the SDK. In this chapter, you will learn how to create, display, and manage advertisements using AdSDK. | First steps for working with AdSDK | Create and display inline ads | Create and display interstitial ad | Handling the ad events | User tagging and conversion tracking | Global request parameters | AdSDK Cache Management | . ",
    "url": "/nextgen-adsdk-android-release/6.0.0/meet-adsdk.html#chapter-1",
    
    "relUrl": "/6.0.0/meet-adsdk.html#chapter-1"
  },"39": {
    "doc": "Meet nextgen AdSDK",
    "title": "Chapter 2",
    "content": "Extending the SDK with your custom advertisements. In this chapter, you will learn about the possibilities of extending and substituting the AdSDK functionality. | Custom handling of target tap URLs | Creating customised advertising | . ",
    "url": "/nextgen-adsdk-android-release/6.0.0/meet-adsdk.html#chapter-2",
    
    "relUrl": "/6.0.0/meet-adsdk.html#chapter-2"
  },"40": {
    "doc": "Meet nextgen AdSDK",
    "title": "Chapter 3",
    "content": "Additional infos and guides. In this chapter, you can learn about special cases, like using the AdSDK with XML views. | How to use AdSDK with XML views | . ",
    "url": "/nextgen-adsdk-android-release/6.0.0/meet-adsdk.html#chapter-3",
    
    "relUrl": "/6.0.0/meet-adsdk.html#chapter-3"
  },"41": {
    "doc": "User tagging and conversion tracking",
    "title": "User tagging and conversion tracking",
    "content": "AdSDK provides powerful functionality for user tagging and conversion tracking. In this tutorial we will explore this functionality. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/6.0.0/user-tagging-conversion-tracking.html",
    
    "relUrl": "/6.0.0/user-tagging-conversion-tracking.html"
  },"42": {
    "doc": "User tagging and conversion tracking",
    "title": "Section 1: Preparing the app",
    "content": "Before considering user tagging and conversion tracking, we need to prepare the application to have appropriate places to perform tagging and tracking. In this section, we will add an option to purchase the product shown in the inline ad. Step 1 . First, we will create a reusable component LabeledContent in ui/components that we will use in the future. File: LabeledContent.kt . @Composable fun LabeledContent( label: String, modifier: Modifier = Modifier, content: @Composable () -&gt; Unit ) { Row( modifier = modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically ) { Text(label, fontWeight = FontWeight.Bold) content() } } . Step 2 . Let’s create a new BasketScreen, BasketViewModel, and BasketRoute in presentation/screens. In it, we create a screen where the user will buy the product, displaying the id, price, quantity, and total cost. File: BasketScreen.kt . @Serializable data class BasketRoute(val id: Int, val price: Int) @Composable fun BasketScreen( route: BasketRoute, viewModel: BasketViewModel = viewModel { BasketViewModel(route.id, route.price) }, navController: NavController ) { val quantity by viewModel.quantity.collectAsState() val total by viewModel.total.collectAsState() val error by viewModel.error.collectAsState() AppTopBarContainer( title = \"Basket\", onNavigateBack = { navController.navigateUp() } ) { Column( modifier = Modifier .fillMaxSize() .padding(16.dp), verticalArrangement = Arrangement.spacedBy(16.dp) ) { LabeledContent(label = \"Item id\") { Text(viewModel.id.toString()) } LabeledContent(label = \"Price\") { Text(\"€${viewModel.price}\") } LabeledContent(label = \"Quantity\") { Text(quantity.toString()) } IconButton(onClick = { viewModel.onIncreaseQuantity() }) { Icon(Icons.Default.Add, contentDescription = \"Increase quantity\") } IconButton(onClick = { viewModel.onDecreaseQuantity() }) { Icon(Icons.Default.Remove, contentDescription = \"Decrease quantity\") } LabeledContent(label = \"Total\") { Text(\"€$total\") } Button( onClick = { viewModel.onPurchase() }, modifier = Modifier.fillMaxWidth() ) { Text(\"Purchase\") } error?.let { errorMessage -&gt; Text( text = errorMessage, color = Color.Red ) } } } } class BasketViewModel( val id: Int, val price: Int ) : ViewModel() { private var _quantity = MutableStateFlow(1) private var _error = MutableStateFlow&lt;String?&gt;(null) val quantity = _quantity.asStateFlow() val error = _error.asStateFlow() val total: StateFlow&lt;Int&gt; = quantity .map { it * price } .stateIn(viewModelScope, SharingStarted.Eagerly, price) fun onIncreaseQuantity() { _quantity.value += 1 } fun onDecreaseQuantity() { if (quantity.value &gt; 1) _quantity.value -= 1 } fun onPurchase() {} } . Step 3 . Now we return to the AdItemState. We add a random price for the product and pass parentCoroutineScope for future use. File: AdItem.kt . // ... class AdItemState( val id: Int, private val adService: AdService, private val request: AdRequest, private val parentCoroutineScope: CoroutineScope ) { // ... val price: Int = Random.nextInt(10, 200) suspend fun loadAdvertisement() { // ... } // ... } // ... Step 4 . The next step is to add price information and a button to the AdItem that will take us to the basket screen. File: AdItem.kt . @Composable fun AdItem(state: AdItemState, navController: NavController) { val uiState by state.state.collectAsState() PresentationStateContainer( uiState, modifier = Modifier .fillMaxWidth() ) { data -&gt; Column { Box( Modifier .fillMaxWidth() .aspectRatio(data.aspectRatio ?: 2.0f) ) { Ad( advertisement = data.advertisement, Modifier .fillMaxWidth() .aspectRatio(data.aspectRatio ?: 2.0f) ) } LabeledContent( \"Price: €${state.price}\", Modifier.padding(15.dp) ) { Button(onClick = { navController.navigate( BasketRoute(state.id, state.price) ) }) { Text(\"Add to basket\") } } } } } // ... Step 5 . Now we fix the errors in InlineScreen.kt after previous changes. We pass navController to AdItem and viewModelScope to AdItemState. File: InlineScreen.kt . // ... @Composable fun InlineScreen( viewModel: InlineViewModel = viewModel(), navController: NavController ) { val uiState by viewModel.state.collectAsState() PresentationStateContainer( uiState, Modifier.fillMaxSize() ) { dataSource -&gt; AppTopBarContainer( title = \"Inline Screen\", onNavigateBack = { navController.navigateUp() } ) { LazyColumn( modifier = Modifier.fillMaxSize() ) { items( dataSource, key = { it.id } ) { itemState -&gt; AdItem(itemState, navController) } } } } } class InlineViewModel( private val adService: AdService = ServiceLocator.adService ) : ViewModel() { // ... private suspend fun getDataSource(): List&lt;AdItemState&gt; = supervisorScope { // ... requests .mapIndexed { index, request -&gt; async { val itemState = AdItemState( index, adService, request, viewModelScope ) itemState.loadAdvertisement() itemState } } .awaitAll() } } . Step 6 . And finally, as a last step, we add BasketRoute to navigation. File: MainActivity.kt . class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) enableEdgeToEdge() setContent { TutorialAppTheme { val navController = rememberNavController() NavHost( navController = navController, startDestination = MainRoute ) { composable&lt;MainRoute&gt; { MainScreen(navController = navController) } composable&lt;InlineRoute&gt; { InlineScreen(navController = navController) } composable&lt;InterstitialRoute&gt; { InterstitialScreen(navController = navController) } composable&lt;BasketRoute&gt; { val route = it.toRoute&lt;BasketRoute&gt;() BasketScreen(route = route, navController = navController) } } } } } } . Now our app is ready to create purchases! . ",
    "url": "/nextgen-adsdk-android-release/6.0.0/user-tagging-conversion-tracking.html#section-1-preparing-the-app",
    
    "relUrl": "/6.0.0/user-tagging-conversion-tracking.html#section-1-preparing-the-app"
  },"43": {
    "doc": "User tagging and conversion tracking",
    "title": "Section 2: User tagging",
    "content": "The SDK provides functionality to put a user identifier, e.g. cookie id, into a retargeting segment (to tag a user). This allows advertisers to create a segment of users with certain interests or affinities, and to re-advertise to this segment (retargeting). In this section, we will look at how we can perform a tag request using the AdSDK. Step 1 . Let’s continue with the AdItem.kt file. Let’s imagine a situation where we need to tag a user when he adds an item to the basket. To do this, first of all, we add the onBasket method to the AdItemState, and call it when the basket button is tapped. File: AdItem.kt . @Composable fun AdItem(state: AdItemState, navController: NavController) { val uiState by state.state.collectAsState() PresentationStateContainer( uiState, modifier = Modifier .fillMaxWidth() ) { data -&gt; Column { // ... LabeledContent( \"Price: €${state.price}\", Modifier.padding(15.dp) ) { Button(onClick = { state.onBasket() navController.navigate( BasketRoute(state.id, state.price) ) }) { Text(\"Add to basket\") } } } } } class AdItemState( val id: Int, private val adService: AdService, private val request: AdRequest, private val parentCoroutineScope: CoroutineScope ) { private val _state = MutableStateFlow&lt;PresentationState&lt;ItemData&gt;&gt;(PresentationState.Loading) private var advertisement: Advertisement? = null val state = _state.asStateFlow() val price: Int = Random.nextInt(10, 200) fun onBasket() { } // ... } // ... Step 2 . Now we’re ready to tag the user. You use TagRequest to describe the tagging request. It consists of TagRequest.Tags with a key, a subkey, and a value. In our case, we’ll use key as the name of our store, subkey as the product category, and value as our product id. Note: In real projects, the advertiser should provide you with information on the tag parameters. File: AdItem.kt . // ... class AdItemState( val id: Int, private val adService: AdService, private val request: AdRequest, private val parentCoroutineScope: CoroutineScope ) { // ... fun onBasket() { val request = TagRequest( tags = listOf( TagRequest.Tag( key = \"MyTutorialStore\", subKey = \"Movies\", value = \"$id\" ) ), timeout = null // Can be skipped ) } } // ... Step 3 . You can perform a user tagging request with AdService.tagUser method. File: AdItem.kt . // ... class AdItemState( val id: Int, private val adService: AdService, private val request: AdRequest, private val parentCoroutineScope: CoroutineScope ) { // ... fun onBasket() { val request = TagRequest( tags = listOf( TagRequest.Tag( key = \"MyTutorialStore\", subKey = \"Movies\", value = \"$id\" ) ), timeout = null // Can be skipped ) parentCoroutineScope.launch { adService.tagUser(request) .get( onSuccess = { Log.d(\"AdItemState\", \"Successfully tagged user for item $id\") }, onError = { Log.d(\"AdItemState\", \"Failed to tag user for item $id: ${it.description}\") } ) } } } // ... Congratulations, now our app can tag the user who added the item to the basket! . ",
    "url": "/nextgen-adsdk-android-release/6.0.0/user-tagging-conversion-tracking.html#section-2-user-tagging",
    
    "relUrl": "/6.0.0/user-tagging-conversion-tracking.html#section-2-user-tagging"
  },"44": {
    "doc": "User tagging and conversion tracking",
    "title": "Section 3: Conversion tracking",
    "content": "The SDK allows you to track conversions. This is useful for advertisers, as conversion details would be available in posttracking reports via the adserver. In this section, we will look at how we can perform a tracking request using the AdSDK. Step 1 . Let’s open the BasketScreen.kt file and focus on the BasketViewModel. The conversion, in our case, is the purchase of an item in the basket. File: BasketScreen.kt . // ... class BasketViewModel( val id: Int, val price: Int ) : ViewModel() { private var _quantity = MutableStateFlow(1) private var _error = MutableStateFlow&lt;String?&gt;(null) val quantity = _quantity.asStateFlow() val error = _error.asStateFlow() val total: StateFlow&lt;Int&gt; = quantity .map { it * price } .stateIn(viewModelScope, SharingStarted.Eagerly, price) fun onIncreaseQuantity() { _quantity.value += 1 } fun onDecreaseQuantity() { if (quantity.value &gt; 1) _quantity.value -= 1 } fun onPurchase() {} } . Step 2 . A conversion tracking request is described using TrackingRequest. In it, we pass all the parameters related to the purchase. Note: In real projects, the advertiser should provide you with information on the landingpageId and trackingspotId parameters. File: BasketScreen.kt . // ... class BasketViewModel( val id: Int, val price: Int ) : ViewModel() { private var _quantity = MutableStateFlow(1) private var _error = MutableStateFlow&lt;String?&gt;(null) val quantity = _quantity.asStateFlow() val error = _error.asStateFlow() val total: StateFlow&lt;Int&gt; = quantity .map { it * price } .stateIn(viewModelScope, SharingStarted.Eagerly, price) fun onIncreaseQuantity() { _quantity.value += 1 } fun onDecreaseQuantity() { if (quantity.value &gt; 1) _quantity.value -= 1 } fun onPurchase() { val request = TrackingRequest( landingPageId = 0, trackingSpotId = 0, orderId = \"My purchase id\", // Can be skipped price = price.toFloat(), // Can be skipped total = total.value.toFloat(), // Can be skipped quantity = quantity.value, // Can be skipped itemNumber = \"$id\", // Can be skipped description = null, // Can be skipped timeout = null // Can be skipped ) } } . Step 3 . Now we can perform the tracking request. We use AdService.trackingRequest for this purpose, and in case of an error, we display it on the screen. File: BasketScreen.kt . // ... class BasketViewModel( val id: Int, val price: Int, private val adService: AdService = ServiceLocator.adService ) : ViewModel() { private var _quantity = MutableStateFlow(1) private var _error = MutableStateFlow&lt;String?&gt;(null) val quantity = _quantity.asStateFlow() val error = _error.asStateFlow() val total: StateFlow&lt;Int&gt; = quantity .map { it * price } .stateIn(viewModelScope, SharingStarted.Eagerly, price) fun onIncreaseQuantity() { _quantity.value += 1 } fun onDecreaseQuantity() { if (quantity.value &gt; 1) _quantity.value -= 1 } fun onPurchase() { val request = TrackingRequest( landingPageId = 0, trackingSpotId = 0, orderId = \"My purchase id\", // Can be skipped price = price.toFloat(), // Can be skipped total = total.value.toFloat(), // Can be skipped quantity = quantity.value, // Can be skipped itemNumber = \"$id\", // Can be skipped description = null, // Can be skipped timeout = null // Can be skipped ) viewModelScope.launch { adService.trackingRequest(request) .get( onSuccess = { Log.d(\"BasketViewModel\", \"Successfully tracked purchase with id: $id\") }, onError = { _error.value = it.description } ) } } } . Congratulations, our app can now track purchase! . ",
    "url": "/nextgen-adsdk-android-release/6.0.0/user-tagging-conversion-tracking.html#section-3-conversion-tracking",
    
    "relUrl": "/6.0.0/user-tagging-conversion-tracking.html#section-3-conversion-tracking"
  },"45": {
    "doc": "AdSDK Cache Management",
    "title": "AdSDK Cache Management",
    "content": "The SDK supports a persistent cache with resources related to ad, these can be banners or other resources, depending on the type of ad. In this tutorial, we’ll look at how an application developer can control the cache. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/cache-management.html",
    
    "relUrl": "/5.3.0/cache-management.html"
  },"46": {
    "doc": "AdSDK Cache Management",
    "title": "Section 1: Limiting the cache size",
    "content": "In this section, we will learn how to limit the size of the cache. Step 1 . When we creating an AdService, we can specify the size of our cache in MB. Let’s change it to 20 MB. The cache size parameter is optional. If you do not specify it, the default cache size is 100 MB. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure( \"1800\", applicationContext, cacheSizeInMb = 20u ) initResult.get( onSuccess = { addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } // ... } . Step 2 . In addition, the SDK allows you to change the size of the cache over time. You can use AdService.setCacheSize method for this purpose. If the specified cache size is smaller than the size of already cached resources, the cache will delete resources to fit the new specified limit. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure( \"1800\", applicationContext, cacheSizeInMb = 20u ) initResult.get( onSuccess = { // coroutineScope.launch { AdService.setCacheSize(20u) } addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } // ... } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/cache-management.html#section-1-limiting-the-cache-size",
    
    "relUrl": "/5.3.0/cache-management.html#section-1-limiting-the-cache-size"
  },"47": {
    "doc": "AdSDK Cache Management",
    "title": "Section 2: Flushing the cache",
    "content": "Although the cache size reached to it limit, SDK will removes resources in FIFO order, sometimes you need to clear the cache completely. In this section, we will learn how we can do this. Step 1 . For example, let’s clear the cache in the case of an AdError.CacheWriteAction. To do this, let’s go back to the InlineAd file and add this code in the case of a AdService.makeAdvertisement method failure. File: InlineAd.kt . // ... class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { val tagUser = async { tagUser() } val conversionTracking = async { conversionTracking() } tagUser.await() conversionTracking.await() AdService.makeAdvertisement( adRequest, adEventListener = adEventListener ).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") when(it) { is AdError.CacheWriteAction -&gt; { } else -&gt; {} } advertisementState.value = ResultState.Error(it) } ) } } //... } . Step 2 . We create an method flushCache and use AdService.flushCache. File: InlineAd.kt . // ... class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { val tagUser = async { tagUser() } val conversionTracking = async { conversionTracking() } tagUser.await() conversionTracking.await() AdService.makeAdvertisement( adRequest, adEventListener = adEventListener ).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") when(it) { is AdError.CacheWriteAction -&gt; { flushCache() } else -&gt; {} } advertisementState.value = ResultState.Error(it) } ) } } fun flushCache() { viewModelScope.launch { AdService.flushCache().get( onSuccess = { Log.d(\"InlineAdViewModel\", \"FlushCache was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed flushCache: ${it.description}\") } ) } } // ... } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/cache-management.html#section-2-flushing-the-cache",
    
    "relUrl": "/5.3.0/cache-management.html#section-2-flushing-the-cache"
  },"48": {
    "doc": "AdSDK Cache Management",
    "title": "Section 3: Specify the cache path",
    "content": "In this section, we will see how to set the path of the cache. Step 1 . Like the size we can also set the custom path of the cache when we configure the AdService. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure( \"1800\", applicationContext, cacheSizeInMb = 20u, cachePath = cacheDir.path + \"/tutorialApp/\" ) initResult.get( onSuccess = { // coroutineScope.launch { AdService.setCacheSize(20u) } addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } // ... } . Step 2 . Similar to the size, the SDK allows you to change the path of the cache over time. You can use AdService.setCachePath method for this purpose. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure( \"1800\", applicationContext, cacheSizeInMb = 20u, cachePath = cacheDir.path + \"/tutorialApp/\" ) initResult.get( onSuccess = { // coroutineScope.launch { AdService.setCacheSize(20u) } // coroutineScope.launch { // AdService.setCachePath(cacheDir.path + \"/tutorialApp/\") // } addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } // ... } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/cache-management.html#section-3-specify-the-cache-path",
    
    "relUrl": "/5.3.0/cache-management.html#section-3-specify-the-cache-path"
  },"49": {
    "doc": "How to use AdSDK with XML views",
    "title": "How to use AdSDK with XML views",
    "content": "You can follow the tutorial documentation almost entirely. We will highlight the few differences in this guide. We’ll also provide some examples of how to integrate the functionality. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/compose_with_xml_guide.html",
    
    "relUrl": "/5.3.0/compose_with_xml_guide.html"
  },"50": {
    "doc": "How to use AdSDK with XML views",
    "title": "AdSDK configuration",
    "content": "For setting up AdService, creating AdRequest and Advertisement, you can follow the previous tutorial exactly, as it does not include any Compose-specific code. The first thing to be careful about when following the tutorial is how the advertisement state is shared in the view model. In the tutorial, we use mutableStateOf, which is a feature from Jetpack Compose. An alternative could be MutableLiveData. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/compose_with_xml_guide.html#adsdk-configuration",
    
    "relUrl": "/5.3.0/compose_with_xml_guide.html#adsdk-configuration"
  },"51": {
    "doc": "How to use AdSDK with XML views",
    "title": "Use AdSDK composable with views",
    "content": "The major difference when using XML instead of Compose comes when you try to use the Ad or the Interstitial composable, since they are built with Compose. To integrate them into an XML-based layout, you’ll need to use Android’s setContent(). There are several ways to do this. You can use the XML layout. &lt;androidx.compose.ui.platform.ComposeView android:id=\"@+id/composeView1\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; . is ResultState.Success -&gt; { findViewById&lt;ComposeView&gt;(R.id.composeView1).setContent { Ad(it.data) } } . You can also create the layout in the code directly. ComposeView(context).apply { layoutParams = AdsListView.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT ) setContent { Interstitial(viewModel.interstitialState) } } . For more information, you can refer to the Compose documentation. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/compose_with_xml_guide.html#use-adsdk-composable-with-views",
    
    "relUrl": "/5.3.0/compose_with_xml_guide.html#use-adsdk-composable-with-views"
  },"52": {
    "doc": "Create and display inline ads",
    "title": "Create and display inline ads",
    "content": "This tutorial will guide you how to create and display inline ads. An inline ad is an ad created to be displayed in your view hierarchy. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/create-and-display-inline-ads.html",
    
    "relUrl": "/5.3.0/create-and-display-inline-ads.html"
  },"53": {
    "doc": "Create and display inline ads",
    "title": "Creating an inline ads",
    "content": "Your AdService is ready for creating advertisements, so in this section, we will create an InlineAd composable for future ad display. Step 1 . Lets create an InlineAd composable and an InlineAdViewModel class. File: InlineAd.kt . @Composable fun InlineAd() { Text( text = \"Advertisement should be here\" ) } class InlineAdViewModel : ViewModel() { } . Step 2 . To create advertisements, we use the AdService.makeAdvertisement method. The most important parameter now is AdRequest, which describes the request that will be sent to the server to receive ads. The only mandatory parameter when creating the AdRequest is AdRequest.contentUnit or AdRequest.learningTag. Content unit is unique ID of a content space. You can also use AdRequest.learningTag, but we use AdRequest.contentUnit in this tutorial because it is more commonly used. File: InlineAd.kt . @Composable fun InlineAd() { Text( text = \"Advertisement should be here\" ) } class InlineAdViewModel : ViewModel() { private val adRequest = AdRequest(\"4810915\") } . Step 3 . The AdService.makeAdvertisement method returns AdResult. It is also suspendable we will use it in the viewModelScope. If the ad is created and loaded successfully, you will receive the downloaded Advertisement object. You can think of it as a ViewModel that holds the data and state of your ad. We’ll again use ResultState with Advertisement to identify whether the ad was created and loaded successfully. File: InlineAd.kt . @Composable fun InlineAd() { Text( text = \"Advertisement should be here\" ) } class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) init { viewModelScope.launch { AdService.makeAdvertisement(adRequest).get( onSuccess = { advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 4 . If we have an Advertisement instance, it remains to add a Composable. The sdk_presentation_compose has Ad, which is the presentation layer of your inline ad. File: InlineAd.kt . @Composable fun InlineAd() { val viewModel: InlineAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Ad(it.data) } } } } class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) init { viewModelScope.launch { AdService.makeAdvertisement(adRequest).get( onSuccess = { advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 5 . The last thing we need to do is add our Composable to the MainActivity. File: MainActivity.kt . class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val app = application as App app.adServiceStatus.observe(this) { result -&gt; when(result) { is ResultState.Error -&gt; { showAppError(result.exception) } is ResultState.Success -&gt; { setContent { TutorialAppTheme { InlineAd() } } } } } } private fun showAppError(adError: AdError) { Toast.makeText(this, \"Initialization failed: ${adError.description}\", Toast.LENGTH_LONG).show() } } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/create-and-display-inline-ads.html#creating-an-inline-ads",
    
    "relUrl": "/5.3.0/create-and-display-inline-ads.html#creating-an-inline-ads"
  },"54": {
    "doc": "Create and display inline ads",
    "title": "Section 2: Defining the size of the advertisement",
    "content": "Our InlineAdViewModel and InlineAd can load and display ads, but how can we understand what size the Ad should be? In this section we will deal with this question. Step 1 . As we already know, Advertisement stores advertising data. Let’s try to get it! We can obtain all possible advertising data using AdMetadata. This is the one we will use to obtain the size data. We are interested in AdMetadata.aspectRatio, which is optional. We have implemented the logic so that in cases where it is not present, we will use the 2:1 ratio. File: InlineAd.kt . @Composable fun InlineAd() { val viewModel: InlineAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { it.data.adMetadata Ad(it.data) } } } } class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f init { viewModelScope.launch { AdService.makeAdvertisement(adRequest).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 2 . Now we can add the AdMetadata.aspectRatio via the Modifier into the Ad. File: InlineAd.kt . @Composable fun InlineAd() { val viewModel: InlineAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { it.data.adMetadata Ad( it.data, modifier = Modifier.aspectRatio(viewModel.aspectRatio) ) } } } } class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f init { viewModelScope.launch { AdService.makeAdvertisement(adRequest).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Now we should see the banner on our device. Congrats! . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/create-and-display-inline-ads.html#section-2-defining-the-size-of-the-advertisement",
    
    "relUrl": "/5.3.0/create-and-display-inline-ads.html#section-2-defining-the-size-of-the-advertisement"
  },"55": {
    "doc": "Create and display interstitial ad",
    "title": "Create and display interstitial ad",
    "content": "A full-screen advertisement that fills the host app’s interface is known as an interstitial ad. In this tutorial we will add an interstitial ad to our application. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/create-and-display-interstitial-ad.html",
    
    "relUrl": "/5.3.0/create-and-display-interstitial-ad.html"
  },"56": {
    "doc": "Create and display interstitial ad",
    "title": "Section 1: Prepare app for interstitial ad",
    "content": "We want to present the interstitial on a different screen and add navigation buttons for it. Step 1 . Let’s create a new MainScreen file in which we add Navigation and MainScreen. Note: At the moment you will get an error, because we have not created InterstitialScreen yet. File: MainScreen.kt . @Composable fun Navigation() { val navController = rememberNavController() NavHost(navController = navController, startDestination = \"mainScreen\") { composable(\"mainScreen\") { MainScreen(navController) } composable(\"interstitial\") { InterstitialScreen() } } } @Composable fun MainScreen(navController: NavController) { Scaffold( floatingActionButton = { ExtendedFloatingActionButton( onClick = { navController.navigate(\"interstitial\") }, content = { Text(\"Go to Interstitial\") }, ) } ) { innerPadding -&gt; Column( modifier = Modifier .fillMaxSize() .padding(innerPadding), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { InlineAd() Spacer(modifier = Modifier.height(16.dp)) } } } . Step 2 . The next step is to create our future screen for displaying interstitial ads. Create a new InterstitialScreen file and add a screen with a button to it. File: InterstitialScreen.kt . @Composable fun InterstitialScreen() { Box( modifier = Modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { Button( onClick = { }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } } } class InterstitialAdViewModel : ViewModel() { } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/create-and-display-interstitial-ad.html#section-1-prepare-app-for-interstitial-ad",
    
    "relUrl": "/5.3.0/create-and-display-interstitial-ad.html#section-1-prepare-app-for-interstitial-ad"
  },"57": {
    "doc": "Create and display interstitial ad",
    "title": "Section 2: Creating interstitial advertisements",
    "content": "We have already created an inline Advertisement on a previous chapter. In this section, we will create a interstitial ad for the future presentation. Step 1 . Interstitial ad is created in the same way as inline ads, with one difference – the placementType parameter must be AdPlacementType.INTERSTITIAL. Let’s add the logic for loading the advertisement into InterstitialAdViewModel. We’ll again use ResultState with Advertisement to identify whether the ad was created and loaded successfully. File: InterstitialScreen.kt . @Composable fun InterstitialScreen() { Box( modifier = Modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { Button( onClick = { }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = AdPlacementType.INTERSTITIAL, ).get( onSuccess = { advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 2 . We add the InterstitialAdViewModel to the InterstitialAd. File: InterstitialScreen.kt . @Composable fun InterstitialScreen() { val viewModel: InterstitialAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = AdPlacementType.INTERSTITIAL, ).get( onSuccess = { advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/create-and-display-interstitial-ad.html#section-2-creating-interstitial-advertisements",
    
    "relUrl": "/5.3.0/create-and-display-interstitial-ad.html#section-2-creating-interstitial-advertisements"
  },"58": {
    "doc": "Create and display interstitial ad",
    "title": "Section 3: Presenting interstitial ad",
    "content": "We learnt how to create interstitial advertisement. Now, we are ready to present our interstitial ad. In this section, we will display interstitial ad in our app. Step 1 . Our AdSDK provides AdInterstitialState to control the state of the interstitial ad presentation. Add a property for this in the InterstitialAdViewModel. File: InterstitialScreen.kt . fun InterstitialScreen() { val viewModel: InterstitialAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisement = mutableStateOf&lt;Advertisement?&gt;(null) lateinit var interstitialState: AdInterstitialState init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = PlacementType.INTERSTITIAL, adEventListener = adEventListener ).get( onSuccess = { interstitialState = AdInterstitialState(it, this) advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"AdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 2 . The next step will be adding a presentation layer. To display interstitial ads, SDK has an Interstitial composable. Add it to your InterstitialScreen and pass the state value from the InterstitialAdViewModel. File: InterstitialScreen.kt . @Composable fun InterstitialScreen(modifier: Modifier) { val viewModel: InterstitialAdViewModel = viewModel() Box( modifier = modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } Interstitial(viewModel.interstitialState) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisement = mutableStateOf&lt;Advertisement?&gt;(null) lateinit var interstitialState: AdInterstitialState init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = PlacementType.INTERSTITIAL ).get( onSuccess = { interstitialState = AdInterstitialState(it, this) advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 3 . To show an interstitial ad, you can use the AdInterstitialState.presentIfLoaded method. Note: If you don’t use the Advertisement.reload method, your Advertisement object will always be loaded, which means that the ad will be presented to the user immediately when AdInterstitialState.presentIfLoaded method called. Otherwise, the ad will be presented immediately after loading. File: InterstitialScreen.kt . fun InterstitialScreen() { val viewModel: InterstitialAdViewModel = viewModel() Box( modifier = modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { viewModel.interstitialState.presentIfLoaded() }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } Interstitial(viewModel.interstitialState) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisement = mutableStateOf&lt;Advertisement?&gt;(null) lateinit var interstitialState: AdInterstitialState init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = PlacementType.INTERSTITIAL ).get( onSuccess = { interstitialState = AdInterstitialState(it, this) advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/create-and-display-interstitial-ad.html#section-3-presenting-interstitial-ad",
    
    "relUrl": "/5.3.0/create-and-display-interstitial-ad.html#section-3-presenting-interstitial-ad"
  },"59": {
    "doc": "Create and display interstitial ad",
    "title": "Section 3: Hiding interstitial ad",
    "content": "We managed to successfully show the ad, but we would like to be able to close interstitial. In this section, we implement this logic. Step 1 . Let’s continue the development in our InterstitialScreen file. We could hide the ad by simply calling the AdInterstitialState.hide method, but we don’t know when to call it. In order to understand when ad should be hidden, we need to use AdEventListener. We will explain the AdEventListener in more detail in the next chapter. Let’s create an adEventListener in InterstitialAdViewModel, and then pass it to the AdService.makeAdvertisement. File: InterstitialScreen.kt . fun InterstitialScreen() { val viewModel: InterstitialAdViewModel = viewModel() Box( modifier = modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { viewModel.interstitialState.presentIfLoaded() }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } Interstitial(viewModel.interstitialState) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) lateinit var interstitialState: AdInterstitialState val adEventListener: AdEventListener = object : AdEventListener { override fun eventProcessed(adEventType: AdEventType, adMetadata: AdMetadata) { Log.d(\"InterstitialAdViewModel events\", \"Collected EVENT - $adEventType\") } } init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = AdPlacementType.INTERSTITIAL, adEventListener = adEventListener ).get( onSuccess = { interstitialState = AdInterstitialState(it, this) advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 2 . The event we are interested in is AdEventType.UnloadRequest. We need to observe it to make sure that the ad is hidden when it is needed. Note: You should not change the state from presented to hidden without using AdEventType.UnloadRequest event. The advert itself knows when it needs to be hidden and asks you to hide it using this method. File: InterstitialScreen.kt . fun InterstitialScreen() { val viewModel: InterstitialAdViewModel = viewModel() Box( modifier = modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { viewModel.interstitialState.presentIfLoaded() }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } Interstitial(viewModel.interstitialState) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) lateinit var interstitialState: AdInterstitialState val adEventListener: AdEventListener = object : AdEventListener { override fun eventProcessed(adEventType: AdEventType, adMetadata: AdMetadata) { Log.d(\"InterstitialAdViewModel events\", \"Collected EVENT - $adEventType\") if (adEventType == AdEventType.UnloadRequest) { interstitialState.hide() } } } init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = AdPlacementType.INTERSTITIAL, adEventListener= adEventListener ).get( onSuccess = { interstitialState = AdInterstitialState(it, this) advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Now, if you launch the app, you should see an interstitial ad. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/create-and-display-interstitial-ad.html#section-3-hiding-interstitial-ad",
    
    "relUrl": "/5.3.0/create-and-display-interstitial-ad.html#section-3-hiding-interstitial-ad"
  },"60": {
    "doc": "Creating customised advertising",
    "title": "Creating customised advertising",
    "content": "In this tutorial, we will learn how to create custom ads using AdSDK. This process is the same for both inline and interstitial ads. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. Note: In this tutorial, we want to display a picture and frame it, but in real-world projects, your ad can be anything - video, HTML, graphics, etc. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/creating-customised-advertising.html",
    
    "relUrl": "/5.3.0/creating-customised-advertising.html"
  },"61": {
    "doc": "Creating customised advertising",
    "title": "Section 1: Creating a custom renderer",
    "content": "We will create an custom composable ad. Let’s start by using the AdComposeRenderer. Step 1 . Create a new file TutorialRenderer and TutorialRenderer class on it. Step 2 . TutorialRenderer need to implement AdComposeRenderer, override AdComposeRenderer.configure, and AdComposeRenderer.RenderAd. We’ll take a closer look at each of these methods in separate sections. File: TutorialRenderer.kt . internal class TutorialRenderer : AdComposeRenderer { override suspend fun configure( rendererEventHandler: AdRendererEventHandler, adMetadata: AdMetadata, adResponseBundle: AdResponseBundle ): AdResult&lt;Unit&gt; {} @Composable override fun RenderAd(modifier: Modifier) {} } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/creating-customised-advertising.html#section-1-creating-a-custom-renderer",
    
    "relUrl": "/5.3.0/creating-customised-advertising.html#section-1-creating-a-custom-renderer"
  },"62": {
    "doc": "Creating customised advertising",
    "title": "Section 2: Get the data",
    "content": "In this section, we will learn how the renderer can receive data from the ad server using the AdComposeRenderer.configure method. Step 1 . The server should always be configured to return a custom response when using custom advertising. In this tutorial, the server is configured to give us the following response. { // ... \"ad_name\": \"tutorialad\", \"body\": { // ... \"ext\": { // ... \"adData\": { \"banner_image\": \"Banner URL\", \"framing_width\": \"Framing width\", \"is_black_framing\": \"Boolean value – whether the color should be black or white.\" } } } } . Step 2 . We will use kotlinx.serialization.json.JsonObject to parse the JSON. We have to import it in our build gradle file. File: build.gradle.kts . implementation(\"org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.3\") . Step 3 . The AdComposeRenderer.configure method is the key to creating ads. Within it, you have to perform all the logic to prepare the ad for display - decoding, additional downloads, etc. Note: This method is directly related to the [AdService.makeAdvertisement] and [Advertisement.reload] methods. As soon as this method is completed, the Advertisement will be returned to the app. The AdResponseBundle parameter contains the entire response from the server we need. It contains the data as AdResponse and JSON as a string. We will keep it easy and just use a method to get the 3 values from the AdResponse. You could do this with your own decoding logic or anything similar and use JSON string. File: TutorialRenderer.kt . internal class TutorialRenderer : AdComposeRenderer { private var framingWidth: Int = 1 private var isBlackFraming: Boolean = false override suspend fun configure( rendererEventHandler: AdRendererEventHandler, adMetadata: AdMetadata, adResponseBundle: AdResponseBundle ): AdResult&lt;Unit&gt; { val adDataMap = adResponseBundle.adResponse.body?.ext?.adData as? Map&lt;*, *&gt; ?: return AdResult.Error(AdError.Decoding(Exception(\"adData is missing.\"))) val jsonString = JSONObject(adDataMap).toString() val adData = Json.parseToJsonElement(jsonString).jsonObject val bannerURL = adData[\"banner_image\"]?.jsonPrimitive?.content ?: return AdResult.Error(AdError.Decoding(Exception(\"Banner URL is null.\"))) framingWidth = adData[\"framing_width\"]?.jsonPrimitive?.intOrNull ?: framingWidth isBlackFraming = adData[\"is_black_framing\"]?.jsonPrimitive?.booleanOrNull ?: isBlackFraming } @Composable override fun RenderAd(modifier: Modifier) {} } . Step 4 . We will use the banner URL to get the image from the cache or download it from the server. We get a cache instance with AdService.getCacheInstance and can use DriveCache.find to get the image from cache. If not, we will use AdRendererEventHandler.downloadBitmap to download the image. We will take a closer look at [AdRendererEventHandler] in the next sections. File: TutorialRenderer.kt . internal class TutorialRenderer : AdComposeRenderer { private lateinit var eventHandler: AdRendererEventHandler private var framingWidth: Int = 1 private var isBlackFraming: Boolean = false override suspend fun configure( rendererEventHandler: AdRendererEventHandler, adMetadata: AdMetadata, adResponseBundle: AdResponseBundle ): AdResult&lt;Unit&gt; { this.eventHandler = rendererEventHandler val adDataMap = adResponseBundle.adResponse.body?.ext?.adData as? Map&lt;*, *&gt; ?: return AdResult.Error(AdError.Decoding(Exception(\"adData is missing.\"))) val jsonString = JSONObject(adDataMap).toString() val adData = Json.parseToJsonElement(jsonString).jsonObject val bannerURL = adData[\"banner_image\"]?.jsonPrimitive?.content ?: return AdResult.Error(AdError.Decoding(Exception(\"Banner URL is null.\"))) framingWidth = adData[\"framing_width\"]?.jsonPrimitive?.intOrNull ?: framingWidth isBlackFraming = adData[\"is_black_framing\"]?.jsonPrimitive?.booleanOrNull ?: isBlackFraming val bannerResult = getBanner(bannerURL) return when (bannerResult) { is AdResult.Success -&gt; { imageBitmap = bannerResult.result AdResult.Success(Unit) } is AdResult.Error -&gt; AdResult.Error(bannerResult.error) } } private suspend fun getBanner(url: String): AdResult&lt;ImageBitmap&gt; { val cachedBanner = getCachedBanner(url) if (cachedBanner != null) { return AdResult.Success(cachedBanner) } return loadAndCacheBanner(url) } private suspend fun getCachedBanner(url: String): ImageBitmap? { val cache = AdService.getCacheInstance().getOrNull() val banner = cache?.find(url)?.getOrNull() if (banner != null) { return BitmapFactory.decodeByteArray( banner.data, 0, banner.data.size )?.asImageBitmap() } return null } private suspend fun loadAndCacheBanner(url: String): AdResult&lt;ImageBitmap&gt; { val bitmapResult = eventHandler.downloadBitmap(url) return when (bitmapResult) { is AdResult.Error -&gt; AdResult.Error(bitmapResult.error) is AdResult.Success -&gt; { AdResult.Success(bitmapResult.result.asImageBitmap()) } } } @Composable override fun RenderAd(modifier: Modifier) {} } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/creating-customised-advertising.html#section-2-get-the-data",
    
    "relUrl": "/5.3.0/creating-customised-advertising.html#section-2-get-the-data"
  },"63": {
    "doc": "Creating customised advertising",
    "title": "Section 3: Create the renderer UI",
    "content": "Now our data is ready. Lets create the renderer UI. To do this, we will use the AdComposeRenderer.RenderAd composable method. Step 1 . We will only show a framed image when the imageBitmap is loaded. File: TutorialRenderer.kt . internal class TutorialRenderer : AdComposeRenderer { private lateinit var eventHandler: AdRendererEventHandler private var imageBitmap by mutableStateOf&lt;ImageBitmap?&gt;(null) private var framingWidth: Int = 1 private var isBlackFraming: Boolean = false // ... @Composable override fun RenderAd(modifier: Modifier) { val imageBitmap = rememberUpdatedState(this.imageBitmap) imageBitmap.value?.let { // Framed image goes here. } } } . Step 2 . We create a box for the framing and show the image inside. File: TutorialRenderer.kt . internal class TutorialRenderer : AdComposeRenderer { private lateinit var eventHandler: AdRendererEventHandler private var imageBitmap by mutableStateOf&lt;ImageBitmap?&gt;(null) private var framingWidth: Int = 1 private var isBlackFraming: Boolean = false // ... @Composable override fun RenderAd(modifier: Modifier) { val imageBitmap = rememberUpdatedState(this.imageBitmap) imageBitmap.value?.let { val borderColor = if (isBlackFraming) Color.Black else Color.White Box( modifier = Modifier .fillMaxWidth() .aspectRatio(it.width.toFloat() / it.height) .border( width = framingWidth.dp, color = borderColor ) ) { Image( bitmap = it, contentDescription = null ) } } } } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/creating-customised-advertising.html#section-3-create-the-renderer-ui",
    
    "relUrl": "/5.3.0/creating-customised-advertising.html#section-3-create-the-renderer-ui"
  },"64": {
    "doc": "Creating customised advertising",
    "title": "Section 4: Event management",
    "content": "The next step will be to implement the processing of ad-related events. We can do this using the [AdRendererEventHandler]. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/creating-customised-advertising.html#section-4-event-management",
    
    "relUrl": "/5.3.0/creating-customised-advertising.html#section-4-event-management"
  },"65": {
    "doc": "Creating customised advertising",
    "title": "Step 1",
    "content": "We already used AdRendererEventHandler.downloadBitmap. Here are all event method we can use: . | AdRendererEventHandler.downloadBitmap | AdRendererEventHandler.performCustomTrackingEvent | AdRendererEventHandler.performTapEvent | AdRendererEventHandler.sendMessage | AdRendererEventHandler.unloadRequest | . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/creating-customised-advertising.html#step-1-3",
    
    "relUrl": "/5.3.0/creating-customised-advertising.html#step-1-3"
  },"66": {
    "doc": "Creating customised advertising",
    "title": "Step 2",
    "content": "We will use AdRendererEventHandler.performTapEvent to trigger the tap event. Note: You can see all possible types of tap events and the difference between them in the AdTapEvent documentation. File: TutorialRenderer.kt . internal class TutorialRenderer : AdComposeRenderer { private lateinit var eventHandler: AdRendererEventHandler // ... @Composable override fun RenderAd(modifier: Modifier) { val imageBitmap = rememberUpdatedState(this.imageBitmap) imageBitmap.value?.let { val borderColor = if (isBlackFraming) Color.Black else Color.White Box( modifier = Modifier .fillMaxWidth() .aspectRatio(it.width.toFloat() / it.height) .border( width = framingWidth.dp, color = borderColor ) ) { Image( bitmap = it, contentDescription = null, modifier.clickable { eventHandler.performTapEvent(AdTapEvent.Tap) } ) } } } } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/creating-customised-advertising.html#step-2-3",
    
    "relUrl": "/5.3.0/creating-customised-advertising.html#step-2-3"
  },"67": {
    "doc": "Creating customised advertising",
    "title": "Section 5: Prepare to present the custom ad",
    "content": "Let’s create a screen to present our custom ad. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/creating-customised-advertising.html#section-5-prepare-to-present-the-custom-ad",
    
    "relUrl": "/5.3.0/creating-customised-advertising.html#section-5-prepare-to-present-the-custom-ad"
  },"68": {
    "doc": "Creating customised advertising",
    "title": "Step 1",
    "content": "Create a new file CustomAd. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/creating-customised-advertising.html#step-1-4",
    
    "relUrl": "/5.3.0/creating-customised-advertising.html#step-1-4"
  },"69": {
    "doc": "Creating customised advertising",
    "title": "Step 2",
    "content": "Add a CustomAd composable and a CustomAdViewModel. File: CustomAd.kt . @Composable fun CustomAd() { val viewModel: CustomAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { it.data.adMetadata Ad(it.data) } } } } class CustomAdViewModel: ViewModel() { private val adRequest = AdRequest(\"5227780\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, ).get( onSuccess = { advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"CustomAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/creating-customised-advertising.html#step-2-4",
    
    "relUrl": "/5.3.0/creating-customised-advertising.html#step-2-4"
  },"70": {
    "doc": "Creating customised advertising",
    "title": "Step 3",
    "content": "Add the CustomAd into the MainScreen. File: MainScreen.kt . @Composable fun Navigation() { val navController = rememberNavController() NavHost(navController = navController, startDestination = \"mainScreen\") { composable(\"mainScreen\") { MainScreen(navController) } composable(\"interstitial\") { InterstitialScreen() } } } @Composable fun MainScreen(navController: NavController) { Scaffold( floatingActionButton = { ExtendedFloatingActionButton( onClick = { navController.navigate(\"interstitial\") }, content = { Text(\"Go to Interstitial\") }, ) } ) { innerPadding -&gt; Column( modifier = Modifier .fillMaxSize() .padding(innerPadding), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { InlineAd() CustomAd() } } } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/creating-customised-advertising.html#step-3-1",
    
    "relUrl": "/5.3.0/creating-customised-advertising.html#step-3-1"
  },"71": {
    "doc": "Creating customised advertising",
    "title": "Section 6: Registering a renderer in the SDK",
    "content": "Although we have created a custom ad, in order for the SDK to use it, we need to pass it to the SDK somehow. Let’s do that. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/creating-customised-advertising.html#section-6-registering-a-renderer-in-the-sdk",
    
    "relUrl": "/5.3.0/creating-customised-advertising.html#section-6-registering-a-renderer-in-the-sdk"
  },"72": {
    "doc": "Creating customised advertising",
    "title": "Step 1",
    "content": "First of all, let’s get back to our response from the server. As you can see, it includes the ad_name field. It is this field that the SDK will use to identify your renderer. { // ... \"ad_name\": \"tutorialad\", // &lt;------- \"body\": { // ... \"ext\": { // ... \"adData\": { \"banner_image\": \"Banner URL\", \"framing_width\": \"Framing width\", \"is_black_framing\": \"Boolean value – whether the color should be black or white.\" } } } } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/creating-customised-advertising.html#step-1-5",
    
    "relUrl": "/5.3.0/creating-customised-advertising.html#step-1-5"
  },"73": {
    "doc": "Creating customised advertising",
    "title": "Step 2",
    "content": "All we need to do is use the AdService.registerRenderer method, passing in the value we expect to receive in the ad_name field and the renderer factory. This way, every time the ad_name field in the server response is the same as the string you passed to this method, the SDK will display the TutorialRenderer. Step 3 . We call the AdService.registerRenderer method in the App class. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure( \"1800\", applicationContext, cacheSizeInMb = 20u, cachePath = cacheDir.path + \"/tutorialApp/\" ) initResult.get( onSuccess = { launch { AdService.registerRenderer(\"tutorialad\") { TutorialRenderer() } adServiceStatus.postValue(ResultState.Success(Unit)) } }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } } . Now you can launch the app and see your new custom ad, congratulations! . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/creating-customised-advertising.html#step-2-5",
    
    "relUrl": "/5.3.0/creating-customised-advertising.html#step-2-5"
  },"74": {
    "doc": "First steps for working with AdSDK",
    "title": "First steps for working with AdSDK",
    "content": "This tutorial will guide you through the first steps of working with the AdSDK - creating an AdService. You can download this this project which already implements all the steps of this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/first-steps.html",
    
    "relUrl": "/5.3.0/first-steps.html"
  },"75": {
    "doc": "First steps for working with AdSDK",
    "title": "Creating an AdService",
    "content": "Creating and configuring an AdService for later ad creation and loading. Step 1 . Create a new Android project and remove any unnecessary code. Make sure you have added the correct packages from the readme. Step 2 . The entry point into the SDK is the AdService class. This is the first thing we should create, as it will be used to generate advertisements in the future. For an easy start, we will simply configure the AdService in the App class. We create a file called App and add it to the MainActivity as well. File: App.kt . class App : Application() { override fun onCreate() { super.onCreate() } } . File: MainActivity.kt . class MainActivity : ComponentActivity() { override fun onCreate() { super.onCreate() val app = application as App // ... } } // ... Remember to add this class as an entry point, so add it to the application in your Manifest. File: AndroidManifest.xml . android:name=\"com.adition.tutorial_app.App\" . Step 3 . Before using the AdService, we should first configure it. To do this, we will use the AdService.configure method in the App class. The only mandatory parameter when configuring an AdService is AdService.networkId. The network identifier is the identifier of your advertising account. The configure method is suspendable, so we should use the coroutine. To do this, we need to create a coroutineScope and add this code to the onCreate function of the App class. class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) override fun onCreate() { super.onCreate() coroutineScope.launch { AdService.configure(\"1800\", applicationContext) } } } . Step 4 . AdService.configure returns AdResult, which is our custom AdSDK implementation of Kotlin’s Result. AdResult contains AdError the only type of error which the SDK supports. We can use AdResult to check that the AdService has been successfully configured and initialised. Let us add a ResultState class to monitor the status. File: ResultState . sealed class ResultState&lt;out T&gt; { data class Success&lt;out T&gt;(val data: T) : ResultState&lt;T&gt;() data class Error&lt;T&gt;(val exception: AdError) : ResultState&lt;T&gt;() } . We can use this status in the App file. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure(\"1800\", applicationContext) initResult.get( onSuccess = { adServiceStatus.value = ResultState.Success(Unit) }, onError = { adServiceStatus.value = ResultState.Error(it) } ) } } } . Step 5 . We can now use adServiceStatus in the onCreate function of the MainActivity. File: MainActivity.kt . class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val app = application as App app.adServiceStatus.observe(this) { result -&gt; when(result) { is ResultState.Error -&gt; { // We will handle in the next step. } is ResultState.Success -&gt; { setContent { TutorialAppTheme { Greeting(name = \"AdSDK\") } } } } } } } // ... Step 6 . We could react on all the different error cases AdError contains. To keeps it easy we just show the description of the AdError. File: MainActivity.kt . class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val app = application as App app.adServiceStatus.observe(this) { result -&gt; when(result) { is ResultState.Error -&gt; { showAppError(result.exception) } is ResultState.Success -&gt; { setContent { TutorialAppTheme { Greeting(name = \"AdSDK\") } } } } } } private fun showAppError(adError: AdError) { Toast.makeText(this, \"Initialization failed: ${adError.description}\", Toast.LENGTH_LONG).show() } } // ... Now, if you’ve done everything right, you should see the greeting message when you launch the app. This completes the AdService configuration, congratulations! . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/first-steps.html#creating-an-adservice",
    
    "relUrl": "/5.3.0/first-steps.html#creating-an-adservice"
  },"76": {
    "doc": "Global request parameters",
    "title": "Global request parameters",
    "content": "We already know how to create and perform AdRequest, TagRequest, and TrackingRequest. However, each of them can have additional parameters, which are called global parameters because they are specified globally for all requests. The SDK provides the ability to add global parameters once so that you don’t have to copy them when creating each request. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/global-request-parameters.html",
    
    "relUrl": "/5.3.0/global-request-parameters.html"
  },"77": {
    "doc": "Global request parameters",
    "title": "Modifying global parameters",
    "content": "In this section we’ll configure the AdRequestGlobalParameters and TrackingGlobalParameters for each AdRequest, TagRequest, and TrackingRequest we have in our application. We will also look at the possibility of removing global parameters. Step 1 . We can add global parameters using the AdService. The AdService has a AdService.setAdRequestGlobalParameter method which we will use to set the gdpr parameter for each AdRequest. Add the global parameters to the App class and a function addGlobalParameters(). Note: If we want to remove a ad request global parameter we could use the AdService.removeAdRequestGlobalParameter method. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure(\"1800\", applicationContext) initResult.get( onSuccess = { addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } private fun addGlobalParameters() { val gdpr = GDPR(consent = \"gdprconsentexample\", isRulesEnabled = true) AdService.setAdRequestGlobalParameter(AdRequestGlobalParameters::gdpr, gdpr) // AdService.removeAdRequestGlobalParameter(AdRequestGlobalParameters::gdpr) } } . Step 2 . We can also modify TrackingGlobalParameters for each TagRequest and TrackingRequest using the AdService.setTrackingGlobalParameter method. Let’s add this code to the addGlobalParameters method. Note: If we want to remove a tracking global parameter we could use the AdService.removeTrackingGlobalParameter method. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure(\"1800\", applicationContext) initResult.get( onSuccess = { addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } private fun addGlobalParameters() { val gdpr = GDPR(consent = \"gdprconsentexample\", isRulesEnabled = true) AdService.setAdRequestGlobalParameter(AdRequestGlobalParameters::gdpr, gdpr) // AdService.removeAdRequestGlobalParameter(AdRequestGlobalParameters::gdpr) AdService.setTrackingGlobalParameter(TrackingGlobalParameters::gdpr, gdpr) // AdService.removeTrackingGlobalParameter(TrackingGlobalParameters::gdpr) } } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/global-request-parameters.html#modifying-global-parameters",
    
    "relUrl": "/5.3.0/global-request-parameters.html#modifying-global-parameters"
  },"78": {
    "doc": "Handling the ad events",
    "title": "Monitor and process ad-related events",
    "content": "Advertisement do a lot of work under the hood and can send messages about them to the app. In turn, you can monitor and react to it in some way. In this tutorial, we’ll look at what events are handled by Advertisement and how we can interact with them. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/handling-the-ad-events.html#monitor-and-process-ad-related-events",
    
    "relUrl": "/5.3.0/handling-the-ad-events.html#monitor-and-process-ad-related-events"
  },"79": {
    "doc": "Handling the ad events",
    "title": "Section 1: Observing events",
    "content": "We will use the AdEventListener to observe the AdEventType. Since we used the AdEventListener in the interstitial tutorial, this time we will add it to the other InlineAdViewModel to observe all the AdEventType. Step 1 . Lets add an AdEventListener to the InlineAdViewModel and pass it to the AdService.makeAdvertisement. File: InlineAd.kt . // ... class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f val adEventListener: AdEventListener = object : AdEventListener { override fun eventProcessed(adEventType: AdEventType, adMetadata: AdMetadata) { Log.d(\"InlineAdViewModel events\", \"Collected EVENT - $adEventType\") } } init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, adEventListener = adEventListener ).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 2 . Here we can see the different AdEventType we can observe: . | Impression | Viewable | Tap | UnloadRequest | RendererMessageReceived | CustomTrackingEvent | . Now let us add all possible AdEventType to the AdEventListener.eventProcessed method of the adEventListener. File: InlineAd.kt . // ... class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f val adEventListener: AdEventListener = object : AdEventListener { override fun eventProcessed(adEventType: AdEventType, adMetadata: AdMetadata) { Log.d(\"InlineAdViewModel events\", \"Collected EVENT - $adEventType\") when (adEventType) { is AdEventType.Impression -&gt; {} is AdEventType.RendererMessageReceived -&gt; {} is AdEventType.CustomTrackingEvent -&gt; {} is AdEventType.Tap -&gt; {} is AdEventType.UnloadRequest -&gt; {} is AdEventType.Viewable -&gt; {} } } } init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, adEventListener = adEventListener ).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 3 . We have already seen UnloadRequest in the interstitial example. Lets look at the Viewable event and monitor each VisibilityPercentage in this example. Note: Impression and Viewable can only be observed if they are configured in the ad server backend. Otherwise they are not part of the ad response. File: InlineAd.kt . // ... class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f val adEventListener: AdEventListener = object : AdEventListener { override fun eventProcessed(adEventType: AdEventType, adMetadata: AdMetadata) { Log.d(\"InlineAdViewModel events\", \"Collected EVENT - $adEventType\") when (adEventType) { is AdEventType.Impression -&gt; {} is AdEventType.RendererMessageReceived -&gt; {} is AdEventType.CustomTrackingEvent -&gt; {} is AdEventType.Tap -&gt; {} is AdEventType.UnloadRequest -&gt; {} is AdEventType.Viewable -&gt; { when (adEventType.percentage) { AdEventType.VisibilityPercentage.ONE -&gt; { Log.d(\"InlineAdViewModel events\", \"1% of my ads are now visible on the screen.\") } AdEventType.VisibilityPercentage.FIFTY -&gt; { Log.d(\"InlineAdViewModel events\", \"50% of my ads are now visible on the screen.\") } AdEventType.VisibilityPercentage.ONE_HUNDRED -&gt; { Log.d(\"InlineAdViewModel events\", \"100% of my ads are now visible on the screen.\") } } } } } } init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, adEventListener = adEventListener ).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/handling-the-ad-events.html#section-1-observing-events",
    
    "relUrl": "/5.3.0/handling-the-ad-events.html#section-1-observing-events"
  },"80": {
    "doc": "Handling the ad events",
    "title": "Handling the ad events",
    "content": " ",
    "url": "/nextgen-adsdk-android-release/5.3.0/handling-the-ad-events.html",
    
    "relUrl": "/5.3.0/handling-the-ad-events.html"
  },"81": {
    "doc": "Meet nextgen AdSDK",
    "title": "Meet nextgen AdSDK",
    "content": "Manage, display, and create your custom advertisements on Android using cutting-edge technologies such as Jetpack Compose and Coroutines based on the AdSDK. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/meet-adsdk.html",
    
    "relUrl": "/5.3.0/meet-adsdk.html"
  },"82": {
    "doc": "Meet nextgen AdSDK",
    "title": "Chapter 1",
    "content": "Working with the built-in capabilities of the SDK. In this chapter, you will learn how to create, display, and manage advertisements using AdSDK. | First steps for working with AdSDK | Create and display inline ads | Create and display interstitial ad | Handling the ad events | User tagging and conversion tracking | Global request parameters | AdSDK Cache Management | . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/meet-adsdk.html#chapter-1",
    
    "relUrl": "/5.3.0/meet-adsdk.html#chapter-1"
  },"83": {
    "doc": "Meet nextgen AdSDK",
    "title": "Chapter 2",
    "content": "Extending the SDK with your custom advertisements. In this chapter, you will learn about the possibilities of extending and substituting the AdSDK functionality. | Creating customised advertising | . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/meet-adsdk.html#chapter-2",
    
    "relUrl": "/5.3.0/meet-adsdk.html#chapter-2"
  },"84": {
    "doc": "Meet nextgen AdSDK",
    "title": "Chapter 3",
    "content": "Additional infos and guides. In this chapter, you can learn about special cases, like using the AdSDK with XML views. | How to use AdSDK with XML views | . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/meet-adsdk.html#chapter-3",
    
    "relUrl": "/5.3.0/meet-adsdk.html#chapter-3"
  },"85": {
    "doc": "User tagging and conversion tracking",
    "title": "User tagging and conversion tracking",
    "content": "AdSDK provides powerful functionality for user tagging and conversion tracking. In this tutorial we will explore this functionality. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/user-tagging-conversion-tracking.html",
    
    "relUrl": "/5.3.0/user-tagging-conversion-tracking.html"
  },"86": {
    "doc": "User tagging and conversion tracking",
    "title": "Section 1: User tagging",
    "content": "The SDK provides functionality to put a user identifier, such as a cookie id, into a retargeting segment (to tag a user). This allows advertisers to create a segment of users with certain interests or affinities, and to re-advertise to this segment (retargeting). In this section, we will look at how to perform a tag request using the AdSDK. Step 1 . To tag a user we need a TagRequest, that describes the request for tagging and consists of tags with a key, a subkey, and a value. We keep it simple and just add a tagUser() method to the InlineAdViewModel and create a TagRequest with one TagRequest.Tag. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) } } . Step 2 . We pass the TagRequest to the AdService.tagUser. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request) } } . Step 3 . The AdService.tagUser method returns an AdResult, so let’s log the result. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } } . Step 4 . To make sure the user is tagged before we call AdService.makeAdvertisement, we will use the coroutines async method. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { val tagUser = async { tagUser() } tagUser.await() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/user-tagging-conversion-tracking.html#section-1-user-tagging",
    
    "relUrl": "/5.3.0/user-tagging-conversion-tracking.html#section-1-user-tagging"
  },"87": {
    "doc": "User tagging and conversion tracking",
    "title": "Section 2: Conversion tracking",
    "content": "The SDK allows you to track conversions. This is useful for advertisers as conversion details are available in post tracking reports via the ad server. In this section we will look at how to perform a tracking request using the AdSDK. Step 1 . A conversion tracking request is described using TrackingRequest. We add a conversionTracking() function to the InlineAdViewModel . File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() conversionTracking() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } private suspend fun conversionTracking() { val request = TrackingRequest( landingPageId = 1, trackingSpotId = 1, orderId = \"orderId\", itemNumber = \"itemNumber\", description = \"description\", quantity = 1, price = 19.99f, total = 39.98f ) } } . Step 2 . We pass the TrackingRequest to the AdService.trackingRequest. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() conversionTracking() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } private suspend fun conversionTracking() { val request = TrackingRequest( landingPageId = 1, trackingSpotId = 1, orderId = \"orderId\", itemNumber = \"itemNumber\", description = \"description\", quantity = 1, price = 19.99f, total = 39.98f ) AdService.trackingRequest(request) } } . Step 3 . The AdService.trackingRequest method also returns an AdResult, so let’s log the result. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() conversionTracking() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } private suspend fun conversionTracking() { val request = TrackingRequest( landingPageId = 1, trackingSpotId = 1, orderId = \"orderId\", itemNumber = \"itemNumber\", description = \"description\", quantity = 1, price = 19.99f, total = 39.98f ) AdService.trackingRequest(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"Conversion tracking was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed conversion tracking: ${it.description}\") } ) } } . Step 4 . To ensure that the conversion tracking is done before we call the AdService.makeAdvertisement method, we will use the coroutines async method. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { val tagUser = async { tagUser() } val conversionTracking = async { conversionTracking() } tagUser.await() conversionTracking.await() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } private suspend fun conversionTracking() { val request = TrackingRequest( landingPageId = 1, trackingSpotId = 1, orderId = \"orderId\", itemNumber = \"itemNumber\", description = \"description\", quantity = 1, price = 19.99f, total = 39.98f ) AdService.trackingRequest(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"Conversion tracking was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed conversion tracking: ${it.description}\") } ) } } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/user-tagging-conversion-tracking.html#section-2-conversion-tracking",
    
    "relUrl": "/5.3.0/user-tagging-conversion-tracking.html#section-2-conversion-tracking"
  },"88": {
    "doc": "AdSDK Cache Management",
    "title": "AdSDK Cache Management",
    "content": "The SDK supports a persistent cache with resources related to ad, these can be banners or other resources, depending on the type of ad. In this tutorial, we’ll look at how an application developer can control the cache. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/cache-management.html",
    
    "relUrl": "/5.0.1/cache-management.html"
  },"89": {
    "doc": "AdSDK Cache Management",
    "title": "Section 1: Limiting the cache size",
    "content": "In this section, we will learn how to limit the size of the cache. Step 1 . When we creating an AdService, we can specify the size of our cache in MB. Let’s change it to 20 MB. The cache size parameter is optional. If you do not specify it, the default cache size is 100 MB. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure( \"1800\", applicationContext, cacheSizeInMb = 20u ) initResult.get( onSuccess = { addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } // ... } . Step 2 . In addition, the SDK allows you to change the size of the cache over time. You can use AdService.setCacheSize method for this purpose. If the specified cache size is smaller than the size of already cached resources, the cache will delete resources to fit the new specified limit. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure( \"1800\", applicationContext, cacheSizeInMb = 20u ) initResult.get( onSuccess = { // coroutineScope.launch { AdService.setCacheSize(20u) } addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } // ... } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/cache-management.html#section-1-limiting-the-cache-size",
    
    "relUrl": "/5.0.1/cache-management.html#section-1-limiting-the-cache-size"
  },"90": {
    "doc": "AdSDK Cache Management",
    "title": "Section 2: Flushing the cache",
    "content": "Although the cache size reached to it limit, SDK will removes resources in FIFO order, sometimes you need to clear the cache completely. In this section, we will learn how we can do this. Step 1 . For example, let’s clear the cache in the case of an AdError.CacheWriteAction. To do this, let’s go back to the InlineAd file and add this code in the case of a AdService.makeAdvertisement method failure. File: InlineAd.kt . // ... class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { val tagUser = async { tagUser() } val conversionTracking = async { conversionTracking() } tagUser.await() conversionTracking.await() AdService.makeAdvertisement( adRequest, adEventListener = adEventListener ).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") when(it) { is AdError.CacheWriteAction -&gt; { } else -&gt; {} } advertisementState.value = ResultState.Error(it) } ) } } //... } . Step 2 . We create an method flushCache and use AdService.flushCache. File: InlineAd.kt . // ... class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { val tagUser = async { tagUser() } val conversionTracking = async { conversionTracking() } tagUser.await() conversionTracking.await() AdService.makeAdvertisement( adRequest, adEventListener = adEventListener ).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") when(it) { is AdError.CacheWriteAction -&gt; { flushCache() } else -&gt; {} } advertisementState.value = ResultState.Error(it) } ) } } fun flushCache() { viewModelScope.launch { AdService.flushCache().get( onSuccess = { Log.d(\"InlineAdViewModel\", \"FlushCache was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed flushCache: ${it.description}\") } ) } } // ... } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/cache-management.html#section-2-flushing-the-cache",
    
    "relUrl": "/5.0.1/cache-management.html#section-2-flushing-the-cache"
  },"91": {
    "doc": "AdSDK Cache Management",
    "title": "Section 3: Specify the cache path",
    "content": "In this section, we will see how to set the path of the cache. Step 1 . Like the size we can also set the custom path of the cache when we configure the AdService. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure( \"1800\", applicationContext, cacheSizeInMb = 20u, cachePath = cacheDir.path + \"/tutorialApp/\" ) initResult.get( onSuccess = { // coroutineScope.launch { AdService.setCacheSize(20u) } addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } // ... } . Step 2 . Similar to the size, the SDK allows you to change the path of the cache over time. You can use AdService.setCachePath method for this purpose. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure( \"1800\", applicationContext, cacheSizeInMb = 20u, cachePath = cacheDir.path + \"/tutorialApp/\" ) initResult.get( onSuccess = { // coroutineScope.launch { AdService.setCacheSize(20u) } // coroutineScope.launch { // AdService.setCachePath(cacheDir.path + \"/tutorialApp/\") // } addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } // ... } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/cache-management.html#section-3-specify-the-cache-path",
    
    "relUrl": "/5.0.1/cache-management.html#section-3-specify-the-cache-path"
  },"92": {
    "doc": "How to use AdSDK with XML views",
    "title": "How to use AdSDK with XML views",
    "content": "You can follow the tutorial documentation almost entirely. We will highlight the few differences in this guide. We’ll also provide some examples of how to integrate the functionality. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/compose_with_xml_guide.html",
    
    "relUrl": "/5.0.1/compose_with_xml_guide.html"
  },"93": {
    "doc": "How to use AdSDK with XML views",
    "title": "AdSDK configuration",
    "content": "For setting up AdService, creating AdRequest and Advertisement, you can follow the previous tutorial exactly, as it does not include any Compose-specific code. The first thing to be careful about when following the tutorial is how the advertisement state is shared in the view model. In the tutorial, we use mutableStateOf, which is a feature from Jetpack Compose. An alternative could be MutableLiveData. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/compose_with_xml_guide.html#adsdk-configuration",
    
    "relUrl": "/5.0.1/compose_with_xml_guide.html#adsdk-configuration"
  },"94": {
    "doc": "How to use AdSDK with XML views",
    "title": "Use AdSDK composable with views",
    "content": "The major difference when using XML instead of Compose comes when you try to use the Ad or the Interstitial composable, since they are built with Compose. To integrate them into an XML-based layout, you’ll need to use Android’s setContent(). There are several ways to do this. You can use the XML layout. &lt;androidx.compose.ui.platform.ComposeView android:id=\"@+id/composeView1\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; . is ResultState.Success -&gt; { findViewById&lt;ComposeView&gt;(R.id.composeView1).setContent { Ad(it.data) } } . You can also create the layout in the code directly. ComposeView(context).apply { layoutParams = AdsListView.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT ) setContent { Interstitial(viewModel.interstitialState) } } . For more information, you can refer to the Compose documentation. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/compose_with_xml_guide.html#use-adsdk-composable-with-views",
    
    "relUrl": "/5.0.1/compose_with_xml_guide.html#use-adsdk-composable-with-views"
  },"95": {
    "doc": "Create and display inline ads",
    "title": "Create and display inline ads",
    "content": "This tutorial will guide you how to create and display inline ads. An inline ad is an ad created to be displayed in your view hierarchy. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/create-and-display-inline-ads.html",
    
    "relUrl": "/5.0.1/create-and-display-inline-ads.html"
  },"96": {
    "doc": "Create and display inline ads",
    "title": "Creating an inline ads",
    "content": "Your AdService is ready for creating advertisements, so in this section, we will create an InlineAd composable for future ad display. Step 1 . Lets create an InlineAd composable and an InlineAdViewModel class. File: InlineAd.kt . @Composable fun InlineAd() { Text( text = \"Advertisement should be here\" ) } class InlineAdViewModel : ViewModel() { } . Step 2 . To create advertisements, we use the AdService.makeAdvertisement method. The most important parameter now is AdRequest, which describes the request that will be sent to the server to receive ads. The only mandatory parameter when creating the AdRequest is AdRequest.contentUnit or AdRequest.learningTag. Content unit is unique ID of a content space. You can also use AdRequest.learningTag, but we use AdRequest.contentUnit in this tutorial because it is more commonly used. File: InlineAd.kt . @Composable fun InlineAd() { Text( text = \"Advertisement should be here\" ) } class InlineAdViewModel : ViewModel() { private val adRequest = AdRequest(\"4810915\") } . Step 3 . The AdService.makeAdvertisement method returns AdResult. It is also suspendable we will use it in the viewModelScope. If the ad is created and loaded successfully, you will receive the downloaded Advertisement object. You can think of it as a ViewModel that holds the data and state of your ad. We’ll again use ResultState with Advertisement to identify whether the ad was created and loaded successfully. File: InlineAd.kt . @Composable fun InlineAd() { Text( text = \"Advertisement should be here\" ) } class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) init { viewModelScope.launch { AdService.makeAdvertisement(adRequest).get( onSuccess = { advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 4 . If we have an Advertisement instance, it remains to add a Composable. The sdk_presentation_compose has Ad, which is the presentation layer of your inline ad. File: InlineAd.kt . @Composable fun InlineAd() { val viewModel: InlineAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Ad(it.data) } } } } class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) init { viewModelScope.launch { AdService.makeAdvertisement(adRequest).get( onSuccess = { advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 5 . The last thing we need to do is add our Composable to the MainActivity. File: MainActivity.kt . class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val app = application as App app.adServiceStatus.observe(this) { result -&gt; when(result) { is ResultState.Error -&gt; { showAppError(result.exception) } is ResultState.Success -&gt; { setContent { TutorialAppTheme { InlineAd() } } } } } } private fun showAppError(adError: AdError) { Toast.makeText(this, \"Initialization failed: ${adError.description}\", Toast.LENGTH_LONG).show() } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/create-and-display-inline-ads.html#creating-an-inline-ads",
    
    "relUrl": "/5.0.1/create-and-display-inline-ads.html#creating-an-inline-ads"
  },"97": {
    "doc": "Create and display inline ads",
    "title": "Section 2: Defining the size of the advertisement",
    "content": "Our InlineAdViewModel and InlineAd can load and display ads, but how can we understand what size the Ad should be? In this section we will deal with this question. Step 1 . As we already know, Advertisement stores advertising data. Let’s try to get it! We can obtain all possible advertising data using AdMetadata. This is the one we will use to obtain the size data. We are interested in AdMetadata.aspectRatio, which is optional. We have implemented the logic so that in cases where it is not present, we will use the 2:1 ratio. File: InlineAd.kt . @Composable fun InlineAd() { val viewModel: InlineAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { it.data.adMetadata Ad(it.data) } } } } class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f init { viewModelScope.launch { AdService.makeAdvertisement(adRequest).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 2 . Now we can add the AdMetadata.aspectRatio via the Modifier into the Ad. File: InlineAd.kt . @Composable fun InlineAd() { val viewModel: InlineAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { it.data.adMetadata Ad( it.data, modifier = Modifier.aspectRatio(viewModel.aspectRatio) ) } } } } class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f init { viewModelScope.launch { AdService.makeAdvertisement(adRequest).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Now we should see the banner on our device. Congrats! . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/create-and-display-inline-ads.html#section-2-defining-the-size-of-the-advertisement",
    
    "relUrl": "/5.0.1/create-and-display-inline-ads.html#section-2-defining-the-size-of-the-advertisement"
  },"98": {
    "doc": "Create and display interstitial ad",
    "title": "Create and display interstitial ad",
    "content": "A full-screen advertisement that fills the host app’s interface is known as an interstitial ad. In this tutorial we will add an interstitial ad to our application. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/create-and-display-interstitial-ad.html",
    
    "relUrl": "/5.0.1/create-and-display-interstitial-ad.html"
  },"99": {
    "doc": "Create and display interstitial ad",
    "title": "Section 1: Prepare app for interstitial ad",
    "content": "We want to present the interstitial on a different screen and add navigation buttons for it. Step 1 . Let’s create a new MainScreen file in which we add Navigation and MainScreen. Note: At the moment you will get an error, because we have not created InterstitialScreen yet. File: MainScreen.kt . @Composable fun Navigation() { val navController = rememberNavController() NavHost(navController = navController, startDestination = \"mainScreen\") { composable(\"mainScreen\") { MainScreen(navController) } composable(\"interstitial\") { InterstitialScreen() } } } @Composable fun MainScreen(navController: NavController) { Scaffold( floatingActionButton = { ExtendedFloatingActionButton( onClick = { navController.navigate(\"interstitial\") }, content = { Text(\"Go to Interstitial\") }, ) } ) { innerPadding -&gt; Column( modifier = Modifier .fillMaxSize() .padding(innerPadding), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { InlineAd() Spacer(modifier = Modifier.height(16.dp)) } } } . Step 2 . The next step is to create our future screen for displaying interstitial ads. Create a new InterstitialScreen file and add a screen with a button to it. File: InterstitialScreen.kt . @Composable fun InterstitialScreen() { Box( modifier = Modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { Button( onClick = { }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } } } class InterstitialAdViewModel : ViewModel() { } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/create-and-display-interstitial-ad.html#section-1-prepare-app-for-interstitial-ad",
    
    "relUrl": "/5.0.1/create-and-display-interstitial-ad.html#section-1-prepare-app-for-interstitial-ad"
  },"100": {
    "doc": "Create and display interstitial ad",
    "title": "Section 2: Creating interstitial advertisements",
    "content": "We have already created an inline Advertisement on a previous chapter. In this section, we will create a interstitial ad for the future presentation. Step 1 . Interstitial ad is created in the same way as inline ads, with one difference – the placementType parameter must be AdPlacementType.INTERSTITIAL. Let’s add the logic for loading the advertisement into InterstitialAdViewModel. We’ll again use ResultState with Advertisement to identify whether the ad was created and loaded successfully. File: InterstitialScreen.kt . @Composable fun InterstitialScreen() { Box( modifier = Modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { Button( onClick = { }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = AdPlacementType.INTERSTITIAL, ).get( onSuccess = { advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 2 . We add the InterstitialAdViewModel to the InterstitialAd. File: InterstitialScreen.kt . @Composable fun InterstitialScreen() { val viewModel: InterstitialAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = AdPlacementType.INTERSTITIAL, ).get( onSuccess = { advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/create-and-display-interstitial-ad.html#section-2-creating-interstitial-advertisements",
    
    "relUrl": "/5.0.1/create-and-display-interstitial-ad.html#section-2-creating-interstitial-advertisements"
  },"101": {
    "doc": "Create and display interstitial ad",
    "title": "Section 3: Presenting interstitial ad",
    "content": "We learnt how to create interstitial advertisement. Now, we are ready to present our interstitial ad. In this section, we will display interstitial ad in our app. Step 1 . Our AdSDK provides AdInterstitialState to control the state of the interstitial ad presentation. Add a property for this in the InterstitialAdViewModel. File: InterstitialScreen.kt . fun InterstitialScreen() { val viewModel: InterstitialAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisement = mutableStateOf&lt;Advertisement?&gt;(null) lateinit var interstitialState: AdInterstitialState init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = PlacementType.INTERSTITIAL, adEventListener = adEventListener ).get( onSuccess = { interstitialState = AdInterstitialState(it, this) advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"AdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 2 . The next step will be adding a presentation layer. To display interstitial ads, SDK has an Interstitial composable. Add it to your InterstitialScreen and pass the state value from the InterstitialAdViewModel. File: InterstitialScreen.kt . @Composable fun InterstitialScreen(modifier: Modifier) { val viewModel: InterstitialAdViewModel = viewModel() Box( modifier = modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } Interstitial(viewModel.interstitialState) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisement = mutableStateOf&lt;Advertisement?&gt;(null) lateinit var interstitialState: AdInterstitialState init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = PlacementType.INTERSTITIAL ).get( onSuccess = { interstitialState = AdInterstitialState(it, this) advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 3 . To show an interstitial ad, you can use the AdInterstitialState.presentIfLoaded method. Note: If you don’t use the Advertisement.reload method, your Advertisement object will always be loaded, which means that the ad will be presented to the user immediately when AdInterstitialState.presentIfLoaded method called. Otherwise, the ad will be presented immediately after loading. File: InterstitialScreen.kt . fun InterstitialScreen() { val viewModel: InterstitialAdViewModel = viewModel() Box( modifier = modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { viewModel.interstitialState.presentIfLoaded() }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } Interstitial(viewModel.interstitialState) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisement = mutableStateOf&lt;Advertisement?&gt;(null) lateinit var interstitialState: AdInterstitialState init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = PlacementType.INTERSTITIAL ).get( onSuccess = { interstitialState = AdInterstitialState(it, this) advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/create-and-display-interstitial-ad.html#section-3-presenting-interstitial-ad",
    
    "relUrl": "/5.0.1/create-and-display-interstitial-ad.html#section-3-presenting-interstitial-ad"
  },"102": {
    "doc": "Create and display interstitial ad",
    "title": "Section 3: Hiding interstitial ad",
    "content": "We managed to successfully show the ad, but we would like to be able to close interstitial. In this section, we implement this logic. Step 1 . Let’s continue the development in our InterstitialScreen file. We could hide the ad by simply calling the AdInterstitialState.hide method, but we don’t know when to call it. In order to understand when ad should be hidden, we need to use AdEventListener. We will explain the AdEventListener in more detail in the next chapter. Let’s create an adEventListener in InterstitialAdViewModel, and then pass it to the AdService.makeAdvertisement. File: InterstitialScreen.kt . fun InterstitialScreen() { val viewModel: InterstitialAdViewModel = viewModel() Box( modifier = modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { viewModel.interstitialState.presentIfLoaded() }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } Interstitial(viewModel.interstitialState) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) lateinit var interstitialState: AdInterstitialState val adEventListener: AdEventListener = object : AdEventListener { override fun eventProcessed(adEventType: AdEventType, adMetadata: AdMetadata) { Log.d(\"InterstitialAdViewModel events\", \"Collected EVENT - $adEventType\") } } init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = AdPlacementType.INTERSTITIAL, adEventListener = adEventListener ).get( onSuccess = { interstitialState = AdInterstitialState(it, this) advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 2 . The event we are interested in is AdEventType.UnloadRequest. We need to observe it to make sure that the ad is hidden when it is needed. Note: You should not change the state from presented to hidden without using AdEventType.UnloadRequest event. The advert itself knows when it needs to be hidden and asks you to hide it using this method. File: InterstitialScreen.kt . fun InterstitialScreen() { val viewModel: InterstitialAdViewModel = viewModel() Box( modifier = modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { viewModel.interstitialState.presentIfLoaded() }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } Interstitial(viewModel.interstitialState) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) lateinit var interstitialState: AdInterstitialState val adEventListener: AdEventListener = object : AdEventListener { override fun eventProcessed(adEventType: AdEventType, adMetadata: AdMetadata) { Log.d(\"InterstitialAdViewModel events\", \"Collected EVENT - $adEventType\") if (adEventType == AdEventType.UnloadRequest) { interstitialState.hide() } } } init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = AdPlacementType.INTERSTITIAL, adEventListener= adEventListener ).get( onSuccess = { interstitialState = AdInterstitialState(it, this) advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Now, if you launch the app, you should see an interstitial ad. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/create-and-display-interstitial-ad.html#section-3-hiding-interstitial-ad",
    
    "relUrl": "/5.0.1/create-and-display-interstitial-ad.html#section-3-hiding-interstitial-ad"
  },"103": {
    "doc": "Creating customised advertising",
    "title": "Creating customised advertising",
    "content": "In this tutorial, we will learn how to create custom ads using AdSDK. This process is the same for both inline and interstitial ads. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. Note: In this tutorial, we want to display a picture and frame it, but in real-world projects, your ad can be anything - video, HTML, graphics, etc. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/creating-customised-advertising.html",
    
    "relUrl": "/5.0.1/creating-customised-advertising.html"
  },"104": {
    "doc": "Creating customised advertising",
    "title": "Section 1: Creating a custom renderer",
    "content": "We will create an custom composable ad. Let’s start by using the AdComposeRenderer. Step 1 . Create a new file TutorialRenderer and TutorialRenderer class on it. Step 2 . TutorialRenderer need to implement AdComposeRenderer, override AdComposeRenderer.configure, and AdComposeRenderer.RenderAd. We’ll take a closer look at each of these methods in separate sections. File: TutorialRenderer.kt . internal class TutorialRenderer : AdComposeRenderer { override suspend fun configure( rendererEventHandler: AdRendererEventHandler, adMetadata: AdMetadata, adResponseBundle: AdResponseBundle ): AdResult&lt;Unit&gt; {} @Composable override fun RenderAd(modifier: Modifier) {} } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/creating-customised-advertising.html#section-1-creating-a-custom-renderer",
    
    "relUrl": "/5.0.1/creating-customised-advertising.html#section-1-creating-a-custom-renderer"
  },"105": {
    "doc": "Creating customised advertising",
    "title": "Section 2: Get the data",
    "content": "In this section, we will learn how the renderer can receive data from the ad server using the AdComposeRenderer.configure method. Step 1 . The server should always be configured to return a custom response when using custom advertising. In this tutorial, the server is configured to give us the following response. { // ... \"ad_name\": \"tutorialad\", \"body\": { // ... \"ext\": { // ... \"adData\": { \"banner_image\": \"Banner URL\", \"framing_width\": \"Framing width\", \"is_black_framing\": \"Boolean value – whether the color should be black or white.\" } } } } . Step 2 . We will use kotlinx.serialization.json.JsonObject to parse the JSON. We have to import it in our build gradle file. File: build.gradle.kts . implementation(\"org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.3\") . Step 3 . The AdComposeRenderer.configure method is the key to creating ads. Within it, you have to perform all the logic to prepare the ad for display - decoding, additional downloads, etc. Note: This method is directly related to the [AdService.makeAdvertisement] and [Advertisement.reload] methods. As soon as this method is completed, the Advertisement will be returned to the app. The AdResponseBundle parameter contains the entire response from the server we need. It contains the data as AdResponse and JSON as a string. We will keep it easy and just use a method to get the 3 values from the AdResponse. You could do this with your own decoding logic or anything similar and use JSON string. File: TutorialRenderer.kt . internal class TutorialRenderer : AdComposeRenderer { private var framingWidth: Int = 1 private var isBlackFraming: Boolean = false override suspend fun configure( rendererEventHandler: AdRendererEventHandler, adMetadata: AdMetadata, adResponseBundle: AdResponseBundle ): AdResult&lt;Unit&gt; { val adDataMap = adResponseBundle.adResponse.body?.ext?.adData as? Map&lt;*, *&gt; ?: return AdResult.Error(AdError.Decoding(Exception(\"adData is missing.\"))) val jsonString = JSONObject(adDataMap).toString() val adData = Json.parseToJsonElement(jsonString).jsonObject val bannerURL = adData[\"banner_image\"]?.jsonPrimitive?.content ?: return AdResult.Error(AdError.Decoding(Exception(\"Banner URL is null.\"))) framingWidth = adData[\"framing_width\"]?.jsonPrimitive?.intOrNull ?: framingWidth isBlackFraming = adData[\"is_black_framing\"]?.jsonPrimitive?.booleanOrNull ?: isBlackFraming } @Composable override fun RenderAd(modifier: Modifier) {} } . Step 4 . We will use the banner URL to get the image from the cache or download it from the server. We get a cache instance with AdService.getCacheInstance and can use DriveCache.find to get the image from cache. If not, we will use AdRendererEventHandler.downloadBitmap to download the image. We will take a closer look at [AdRendererEventHandler] in the next sections. File: TutorialRenderer.kt . internal class TutorialRenderer : AdComposeRenderer { private lateinit var eventHandler: AdRendererEventHandler private var framingWidth: Int = 1 private var isBlackFraming: Boolean = false override suspend fun configure( rendererEventHandler: AdRendererEventHandler, adMetadata: AdMetadata, adResponseBundle: AdResponseBundle ): AdResult&lt;Unit&gt; { this.eventHandler = rendererEventHandler val adDataMap = adResponseBundle.adResponse.body?.ext?.adData as? Map&lt;*, *&gt; ?: return AdResult.Error(AdError.Decoding(Exception(\"adData is missing.\"))) val jsonString = JSONObject(adDataMap).toString() val adData = Json.parseToJsonElement(jsonString).jsonObject val bannerURL = adData[\"banner_image\"]?.jsonPrimitive?.content ?: return AdResult.Error(AdError.Decoding(Exception(\"Banner URL is null.\"))) framingWidth = adData[\"framing_width\"]?.jsonPrimitive?.intOrNull ?: framingWidth isBlackFraming = adData[\"is_black_framing\"]?.jsonPrimitive?.booleanOrNull ?: isBlackFraming val bannerResult = getBanner(bannerURL) return when (bannerResult) { is AdResult.Success -&gt; { imageBitmap = bannerResult.result AdResult.Success(Unit) } is AdResult.Error -&gt; AdResult.Error(bannerResult.error) } } private suspend fun getBanner(url: String): AdResult&lt;ImageBitmap&gt; { val cachedBanner = getCachedBanner(url) if (cachedBanner != null) { return AdResult.Success(cachedBanner) } return loadAndCacheBanner(url) } private suspend fun getCachedBanner(url: String): ImageBitmap? { val cache = AdService.getCacheInstance().getOrNull() val banner = cache?.find(url)?.getOrNull() if (banner != null) { return BitmapFactory.decodeByteArray( banner.data, 0, banner.data.size )?.asImageBitmap() } return null } private suspend fun loadAndCacheBanner(url: String): AdResult&lt;ImageBitmap&gt; { val bitmapResult = eventHandler.downloadBitmap(url) return when (bitmapResult) { is AdResult.Error -&gt; AdResult.Error(bitmapResult.error) is AdResult.Success -&gt; { AdResult.Success(bitmapResult.result.asImageBitmap()) } } } @Composable override fun RenderAd(modifier: Modifier) {} } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/creating-customised-advertising.html#section-2-get-the-data",
    
    "relUrl": "/5.0.1/creating-customised-advertising.html#section-2-get-the-data"
  },"106": {
    "doc": "Creating customised advertising",
    "title": "Section 3: Create the renderer UI",
    "content": "Now our data is ready. Lets create the renderer UI. To do this, we will use the AdComposeRenderer.RenderAd composable method. Step 1 . We will only show a framed image when the imageBitmap is loaded. File: TutorialRenderer.kt . internal class TutorialRenderer : AdComposeRenderer { private lateinit var eventHandler: AdRendererEventHandler private var imageBitmap by mutableStateOf&lt;ImageBitmap?&gt;(null) private var framingWidth: Int = 1 private var isBlackFraming: Boolean = false // ... @Composable override fun RenderAd(modifier: Modifier) { val imageBitmap = rememberUpdatedState(this.imageBitmap) imageBitmap.value?.let { // Framed image goes here. } } } . Step 2 . We create a box for the framing and show the image inside. File: TutorialRenderer.kt . internal class TutorialRenderer : AdComposeRenderer { private lateinit var eventHandler: AdRendererEventHandler private var imageBitmap by mutableStateOf&lt;ImageBitmap?&gt;(null) private var framingWidth: Int = 1 private var isBlackFraming: Boolean = false // ... @Composable override fun RenderAd(modifier: Modifier) { val imageBitmap = rememberUpdatedState(this.imageBitmap) imageBitmap.value?.let { val borderColor = if (isBlackFraming) Color.Black else Color.White Box( modifier = Modifier .fillMaxWidth() .aspectRatio(it.width.toFloat() / it.height) .border( width = framingWidth.dp, color = borderColor ) ) { Image( bitmap = it, contentDescription = null ) } } } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/creating-customised-advertising.html#section-3-create-the-renderer-ui",
    
    "relUrl": "/5.0.1/creating-customised-advertising.html#section-3-create-the-renderer-ui"
  },"107": {
    "doc": "Creating customised advertising",
    "title": "Section 4: Event management",
    "content": "The next step will be to implement the processing of ad-related events. We can do this using the [AdRendererEventHandler]. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/creating-customised-advertising.html#section-4-event-management",
    
    "relUrl": "/5.0.1/creating-customised-advertising.html#section-4-event-management"
  },"108": {
    "doc": "Creating customised advertising",
    "title": "Step 1",
    "content": "We already used AdRendererEventHandler.downloadBitmap. Here are all event method we can use: . | AdRendererEventHandler.downloadBitmap | AdRendererEventHandler.performCustomTrackingEvent | AdRendererEventHandler.performTapEvent | AdRendererEventHandler.sendMessage | AdRendererEventHandler.unloadRequest | . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/creating-customised-advertising.html#step-1-3",
    
    "relUrl": "/5.0.1/creating-customised-advertising.html#step-1-3"
  },"109": {
    "doc": "Creating customised advertising",
    "title": "Step 2",
    "content": "We will use AdRendererEventHandler.performTapEvent to trigger the tap event. Note: You can see all possible types of tap events and the difference between them in the AdTapEvent documentation. File: TutorialRenderer.kt . internal class TutorialRenderer : AdComposeRenderer { private lateinit var eventHandler: AdRendererEventHandler // ... @Composable override fun RenderAd(modifier: Modifier) { val imageBitmap = rememberUpdatedState(this.imageBitmap) imageBitmap.value?.let { val borderColor = if (isBlackFraming) Color.Black else Color.White Box( modifier = Modifier .fillMaxWidth() .aspectRatio(it.width.toFloat() / it.height) .border( width = framingWidth.dp, color = borderColor ) ) { Image( bitmap = it, contentDescription = null, modifier.clickable { eventHandler.performTapEvent(AdTapEvent.Tap) } ) } } } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/creating-customised-advertising.html#step-2-3",
    
    "relUrl": "/5.0.1/creating-customised-advertising.html#step-2-3"
  },"110": {
    "doc": "Creating customised advertising",
    "title": "Section 5: Prepare to present the custom ad",
    "content": "Let’s create a screen to present our custom ad. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/creating-customised-advertising.html#section-5-prepare-to-present-the-custom-ad",
    
    "relUrl": "/5.0.1/creating-customised-advertising.html#section-5-prepare-to-present-the-custom-ad"
  },"111": {
    "doc": "Creating customised advertising",
    "title": "Step 1",
    "content": "Create a new file CustomAd. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/creating-customised-advertising.html#step-1-4",
    
    "relUrl": "/5.0.1/creating-customised-advertising.html#step-1-4"
  },"112": {
    "doc": "Creating customised advertising",
    "title": "Step 2",
    "content": "Add a CustomAd composable and a CustomAdViewModel. File: CustomAd.kt . @Composable fun CustomAd() { val viewModel: CustomAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { it.data.adMetadata Ad(it.data) } } } } class CustomAdViewModel: ViewModel() { private val adRequest = AdRequest(\"5227780\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, ).get( onSuccess = { advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"CustomAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/creating-customised-advertising.html#step-2-4",
    
    "relUrl": "/5.0.1/creating-customised-advertising.html#step-2-4"
  },"113": {
    "doc": "Creating customised advertising",
    "title": "Step 3",
    "content": "Add the CustomAd into the MainScreen. File: MainScreen.kt . @Composable fun Navigation() { val navController = rememberNavController() NavHost(navController = navController, startDestination = \"mainScreen\") { composable(\"mainScreen\") { MainScreen(navController) } composable(\"interstitial\") { InterstitialScreen() } } } @Composable fun MainScreen(navController: NavController) { Scaffold( floatingActionButton = { ExtendedFloatingActionButton( onClick = { navController.navigate(\"interstitial\") }, content = { Text(\"Go to Interstitial\") }, ) } ) { innerPadding -&gt; Column( modifier = Modifier .fillMaxSize() .padding(innerPadding), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { InlineAd() CustomAd() } } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/creating-customised-advertising.html#step-3-1",
    
    "relUrl": "/5.0.1/creating-customised-advertising.html#step-3-1"
  },"114": {
    "doc": "Creating customised advertising",
    "title": "Section 6: Registering a renderer in the SDK",
    "content": "Although we have created a custom ad, in order for the SDK to use it, we need to pass it to the SDK somehow. Let’s do that. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/creating-customised-advertising.html#section-6-registering-a-renderer-in-the-sdk",
    
    "relUrl": "/5.0.1/creating-customised-advertising.html#section-6-registering-a-renderer-in-the-sdk"
  },"115": {
    "doc": "Creating customised advertising",
    "title": "Step 1",
    "content": "First of all, let’s get back to our response from the server. As you can see, it includes the ad_name field. It is this field that the SDK will use to identify your renderer. { // ... \"ad_name\": \"tutorialad\", // &lt;------- \"body\": { // ... \"ext\": { // ... \"adData\": { \"banner_image\": \"Banner URL\", \"framing_width\": \"Framing width\", \"is_black_framing\": \"Boolean value – whether the color should be black or white.\" } } } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/creating-customised-advertising.html#step-1-5",
    
    "relUrl": "/5.0.1/creating-customised-advertising.html#step-1-5"
  },"116": {
    "doc": "Creating customised advertising",
    "title": "Step 2",
    "content": "All we need to do is use the AdService.registerRenderer method, passing in the value we expect to receive in the ad_name field and the renderer factory. This way, every time the ad_name field in the server response is the same as the string you passed to this method, the SDK will display the TutorialRenderer. Step 3 . We call the AdService.registerRenderer method in the App class. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure( \"1800\", applicationContext, cacheSizeInMb = 20u, cachePath = cacheDir.path + \"/tutorialApp/\" ) initResult.get( onSuccess = { launch { AdService.registerRenderer(\"tutorialad\") { TutorialRenderer() } adServiceStatus.postValue(ResultState.Success(Unit)) } }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } } . Now you can launch the app and see your new custom ad, congratulations! . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/creating-customised-advertising.html#step-2-5",
    
    "relUrl": "/5.0.1/creating-customised-advertising.html#step-2-5"
  },"117": {
    "doc": "First steps for working with AdSDK",
    "title": "First steps for working with AdSDK",
    "content": "This tutorial will guide you through the first steps of working with the AdSDK - creating an AdService. You can download this this project which already implements all the steps of this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/first-steps.html",
    
    "relUrl": "/5.0.1/first-steps.html"
  },"118": {
    "doc": "First steps for working with AdSDK",
    "title": "Creating an AdService",
    "content": "Creating and configuring an AdService for later ad creation and loading. Step 1 . Create a new Android project and remove any unnecessary code. Make sure you have added the correct packages from the readme. Step 2 . The entry point into the SDK is the AdService class. This is the first thing we should create, as it will be used to generate advertisements in the future. For an easy start, we will simply configure the AdService in the App class. We create a file called App and add it to the MainActivity as well. File: App.kt . class App : Application() { override fun onCreate() { super.onCreate() } } . File: MainActivity.kt . class MainActivity : ComponentActivity() { override fun onCreate() { super.onCreate() val app = application as App // ... } } // ... Remember to add this class as an entry point, so add it to the application in your Manifest. File: AndroidManifest.xml . android:name=\"com.adition.tutorial_app.App\" . Step 3 . Before using the AdService, we should first configure it. To do this, we will use the AdService.configure method in the App class. The only mandatory parameter when configuring an AdService is AdService.networkId. The network identifier is the identifier of your advertising account. The configure method is suspendable, so we should use the coroutine. To do this, we need to create a coroutineScope and add this code to the onCreate function of the App class. class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) override fun onCreate() { super.onCreate() coroutineScope.launch { AdService.configure(\"1800\", applicationContext) } } } . Step 4 . AdService.configure returns AdResult, which is our custom AdSDK implementation of Kotlin’s Result. AdResult contains AdError the only type of error which the SDK supports. We can use AdResult to check that the AdService has been successfully configured and initialised. Let us add a ResultState class to monitor the status. File: ResultState . sealed class ResultState&lt;out T&gt; { data class Success&lt;out T&gt;(val data: T) : ResultState&lt;T&gt;() data class Error&lt;T&gt;(val exception: AdError) : ResultState&lt;T&gt;() } . We can use this status in the App file. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure(\"1800\", applicationContext) initResult.get( onSuccess = { adServiceStatus.value = ResultState.Success(Unit) }, onError = { adServiceStatus.value = ResultState.Error(it) } ) } } } . Step 5 . We can now use adServiceStatus in the onCreate function of the MainActivity. File: MainActivity.kt . class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val app = application as App app.adServiceStatus.observe(this) { result -&gt; when(result) { is ResultState.Error -&gt; { // We will handle in the next step. } is ResultState.Success -&gt; { setContent { TutorialAppTheme { Greeting(name = \"AdSDK\") } } } } } } } // ... Step 6 . We could react on all the different error cases AdError contains. To keeps it easy we just show the description of the AdError. File: MainActivity.kt . class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val app = application as App app.adServiceStatus.observe(this) { result -&gt; when(result) { is ResultState.Error -&gt; { showAppError(result.exception) } is ResultState.Success -&gt; { setContent { TutorialAppTheme { Greeting(name = \"AdSDK\") } } } } } } private fun showAppError(adError: AdError) { Toast.makeText(this, \"Initialization failed: ${adError.description}\", Toast.LENGTH_LONG).show() } } // ... Now, if you’ve done everything right, you should see the greeting message when you launch the app. This completes the AdService configuration, congratulations! . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/first-steps.html#creating-an-adservice",
    
    "relUrl": "/5.0.1/first-steps.html#creating-an-adservice"
  },"119": {
    "doc": "Global request parameters",
    "title": "Global request parameters",
    "content": "We already know how to create and perform AdRequest, TagRequest, and TrackingRequest. However, each of them can have additional parameters, which are called global parameters because they are specified globally for all requests. The SDK provides the ability to add global parameters once so that you don’t have to copy them when creating each request. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/global-request-parameters.html",
    
    "relUrl": "/5.0.1/global-request-parameters.html"
  },"120": {
    "doc": "Global request parameters",
    "title": "Modifying global parameters",
    "content": "In this section we’ll configure the AdRequestGlobalParameters and TrackingGlobalParameters for each AdRequest, TagRequest, and TrackingRequest we have in our application. We will also look at the possibility of removing global parameters. Step 1 . We can add global parameters using the AdService. The AdService has a AdService.setAdRequestGlobalParameter method which we will use to set the gdpr parameter for each AdRequest. Add the global parameters to the App class and a function addGlobalParameters(). Note: If we want to remove a ad request global parameter we could use the AdService.removeAdRequestGlobalParameter method. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure(\"1800\", applicationContext) initResult.get( onSuccess = { addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } private fun addGlobalParameters() { val gdpr = GDPR(consent = \"gdprconsentexample\", isRulesEnabled = true) AdService.setAdRequestGlobalParameter(AdRequestGlobalParameters::gdpr, gdpr) // AdService.removeAdRequestGlobalParameter(AdRequestGlobalParameters::gdpr) } } . Step 2 . We can also modify TrackingGlobalParameters for each TagRequest and TrackingRequest using the AdService.setTrackingGlobalParameter method. Let’s add this code to the addGlobalParameters method. Note: If we want to remove a tracking global parameter we could use the AdService.removeTrackingGlobalParameter method. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure(\"1800\", applicationContext) initResult.get( onSuccess = { addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } private fun addGlobalParameters() { val gdpr = GDPR(consent = \"gdprconsentexample\", isRulesEnabled = true) AdService.setAdRequestGlobalParameter(AdRequestGlobalParameters::gdpr, gdpr) // AdService.removeAdRequestGlobalParameter(AdRequestGlobalParameters::gdpr) AdService.setTrackingGlobalParameter(TrackingGlobalParameters::gdpr, gdpr) // AdService.removeTrackingGlobalParameter(TrackingGlobalParameters::gdpr) } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/global-request-parameters.html#modifying-global-parameters",
    
    "relUrl": "/5.0.1/global-request-parameters.html#modifying-global-parameters"
  },"121": {
    "doc": "Handling the ad events",
    "title": "Monitor and process ad-related events",
    "content": "Advertisement do a lot of work under the hood and can send messages about them to the app. In turn, you can monitor and react to it in some way. In this tutorial, we’ll look at what events are handled by Advertisement and how we can interact with them. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/handling-the-ad-events.html#monitor-and-process-ad-related-events",
    
    "relUrl": "/5.0.1/handling-the-ad-events.html#monitor-and-process-ad-related-events"
  },"122": {
    "doc": "Handling the ad events",
    "title": "Section 1: Observing events",
    "content": "We will use the AdEventListener to observe the AdEventType. Since we used the AdEventListener in the interstitial tutorial, this time we will add it to the other InlineAdViewModel to observe all the AdEventType. Step 1 . Lets add an AdEventListener to the InlineAdViewModel and pass it to the AdService.makeAdvertisement. File: InlineAd.kt . // ... class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f val adEventListener: AdEventListener = object : AdEventListener { override fun eventProcessed(adEventType: AdEventType, adMetadata: AdMetadata) { Log.d(\"InlineAdViewModel events\", \"Collected EVENT - $adEventType\") } } init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, adEventListener = adEventListener ).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 2 . Here we can see the different AdEventType we can observe: . | Impression | Viewable | Tap | UnloadRequest | RendererMessageReceived | CustomTrackingEvent | . Now let us add all possible AdEventType to the AdEventListener.eventProcessed method of the adEventListener. File: InlineAd.kt . // ... class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f val adEventListener: AdEventListener = object : AdEventListener { override fun eventProcessed(adEventType: AdEventType, adMetadata: AdMetadata) { Log.d(\"InlineAdViewModel events\", \"Collected EVENT - $adEventType\") when (adEventType) { is AdEventType.Impression -&gt; {} is AdEventType.RendererMessageReceived -&gt; {} is AdEventType.CustomTrackingEvent -&gt; {} is AdEventType.Tap -&gt; {} is AdEventType.UnloadRequest -&gt; {} is AdEventType.Viewable -&gt; {} } } } init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, adEventListener = adEventListener ).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 3 . We have already seen UnloadRequest in the interstitial example. Lets look at the Viewable event and monitor each VisibilityPercentage in this example. Note: Impression and Viewable can only be observed if they are configured in the ad server backend. Otherwise they are not part of the ad response. File: InlineAd.kt . // ... class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f val adEventListener: AdEventListener = object : AdEventListener { override fun eventProcessed(adEventType: AdEventType, adMetadata: AdMetadata) { Log.d(\"InlineAdViewModel events\", \"Collected EVENT - $adEventType\") when (adEventType) { is AdEventType.Impression -&gt; {} is AdEventType.RendererMessageReceived -&gt; {} is AdEventType.CustomTrackingEvent -&gt; {} is AdEventType.Tap -&gt; {} is AdEventType.UnloadRequest -&gt; {} is AdEventType.Viewable -&gt; { when (adEventType.percentage) { AdEventType.VisibilityPercentage.ONE -&gt; { Log.d(\"InlineAdViewModel events\", \"1% of my ads are now visible on the screen.\") } AdEventType.VisibilityPercentage.FIFTY -&gt; { Log.d(\"InlineAdViewModel events\", \"50% of my ads are now visible on the screen.\") } AdEventType.VisibilityPercentage.ONE_HUNDRED -&gt; { Log.d(\"InlineAdViewModel events\", \"100% of my ads are now visible on the screen.\") } } } } } } init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, adEventListener = adEventListener ).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/handling-the-ad-events.html#section-1-observing-events",
    
    "relUrl": "/5.0.1/handling-the-ad-events.html#section-1-observing-events"
  },"123": {
    "doc": "Handling the ad events",
    "title": "Handling the ad events",
    "content": " ",
    "url": "/nextgen-adsdk-android-release/5.0.1/handling-the-ad-events.html",
    
    "relUrl": "/5.0.1/handling-the-ad-events.html"
  },"124": {
    "doc": "Meet nextgen AdSDK",
    "title": "Meet nextgen AdSDK",
    "content": "Manage, display, and create your custom advertisements on Android using cutting-edge technologies such as Jetpack Compose and Coroutines based on the AdSDK. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/meet-adsdk.html",
    
    "relUrl": "/5.0.1/meet-adsdk.html"
  },"125": {
    "doc": "Meet nextgen AdSDK",
    "title": "Chapter 1",
    "content": "Working with the built-in capabilities of the SDK. In this chapter, you will learn how to create, display, and manage advertisements using AdSDK. | First steps for working with AdSDK | Create and display inline ads | Create and display interstitial ad | Handling the ad events | User tagging and conversion tracking | Global request parameters | AdSDK Cache Management | . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/meet-adsdk.html#chapter-1",
    
    "relUrl": "/5.0.1/meet-adsdk.html#chapter-1"
  },"126": {
    "doc": "Meet nextgen AdSDK",
    "title": "Chapter 2",
    "content": "Extending the SDK with your custom advertisements. In this chapter, you will learn about the possibilities of extending and substituting the AdSDK functionality. | Creating customised advertising | . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/meet-adsdk.html#chapter-2",
    
    "relUrl": "/5.0.1/meet-adsdk.html#chapter-2"
  },"127": {
    "doc": "Meet nextgen AdSDK",
    "title": "Chapter 3",
    "content": "Additional infos and guides. In this chapter, you can learn about special cases, like using the AdSDK with XML views. | How to use AdSDK with XML views | . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/meet-adsdk.html#chapter-3",
    
    "relUrl": "/5.0.1/meet-adsdk.html#chapter-3"
  },"128": {
    "doc": "User tagging and conversion tracking",
    "title": "User tagging and conversion tracking",
    "content": "AdSDK provides powerful functionality for user tagging and conversion tracking. In this tutorial we will explore this functionality. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/user-tagging-conversion-tracking.html",
    
    "relUrl": "/5.0.1/user-tagging-conversion-tracking.html"
  },"129": {
    "doc": "User tagging and conversion tracking",
    "title": "Section 1: User tagging",
    "content": "The SDK provides functionality to put a user identifier, such as a cookie id, into a retargeting segment (to tag a user). This allows advertisers to create a segment of users with certain interests or affinities, and to re-advertise to this segment (retargeting). In this section, we will look at how to perform a tag request using the AdSDK. Step 1 . To tag a user we need a TagRequest, that describes the request for tagging and consists of tags with a key, a subkey, and a value. We keep it simple and just add a tagUser() method to the InlineAdViewModel and create a TagRequest with one TagRequest.Tag. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) } } . Step 2 . We pass the TagRequest to the AdService.tagUser. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request) } } . Step 3 . The AdService.tagUser method returns an AdResult, so let’s log the result. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } } . Step 4 . To make sure the user is tagged before we call AdService.makeAdvertisement, we will use the coroutines async method. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { val tagUser = async { tagUser() } tagUser.await() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/user-tagging-conversion-tracking.html#section-1-user-tagging",
    
    "relUrl": "/5.0.1/user-tagging-conversion-tracking.html#section-1-user-tagging"
  },"130": {
    "doc": "User tagging and conversion tracking",
    "title": "Section 2: Conversion tracking",
    "content": "The SDK allows you to track conversions. This is useful for advertisers as conversion details are available in post tracking reports via the ad server. In this section we will look at how to perform a tracking request using the AdSDK. Step 1 . A conversion tracking request is described using TrackingRequest. We add a conversionTracking() function to the InlineAdViewModel . File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() conversionTracking() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } private suspend fun conversionTracking() { val request = TrackingRequest( landingPageId = 1, trackingSpotId = 1, orderId = \"orderId\", itemNumber = \"itemNumber\", description = \"description\", quantity = 1, price = 19.99f, total = 39.98f ) } } . Step 2 . We pass the TrackingRequest to the AdService.trackingRequest. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() conversionTracking() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } private suspend fun conversionTracking() { val request = TrackingRequest( landingPageId = 1, trackingSpotId = 1, orderId = \"orderId\", itemNumber = \"itemNumber\", description = \"description\", quantity = 1, price = 19.99f, total = 39.98f ) AdService.trackingRequest(request) } } . Step 3 . The AdService.trackingRequest method also returns an AdResult, so let’s log the result. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() conversionTracking() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } private suspend fun conversionTracking() { val request = TrackingRequest( landingPageId = 1, trackingSpotId = 1, orderId = \"orderId\", itemNumber = \"itemNumber\", description = \"description\", quantity = 1, price = 19.99f, total = 39.98f ) AdService.trackingRequest(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"Conversion tracking was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed conversion tracking: ${it.description}\") } ) } } . Step 4 . To ensure that the conversion tracking is done before we call the AdService.makeAdvertisement method, we will use the coroutines async method. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { val tagUser = async { tagUser() } val conversionTracking = async { conversionTracking() } tagUser.await() conversionTracking.await() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } private suspend fun conversionTracking() { val request = TrackingRequest( landingPageId = 1, trackingSpotId = 1, orderId = \"orderId\", itemNumber = \"itemNumber\", description = \"description\", quantity = 1, price = 19.99f, total = 39.98f ) AdService.trackingRequest(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"Conversion tracking was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed conversion tracking: ${it.description}\") } ) } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/user-tagging-conversion-tracking.html#section-2-conversion-tracking",
    
    "relUrl": "/5.0.1/user-tagging-conversion-tracking.html#section-2-conversion-tracking"
  },"131": {
    "doc": "AdSDK Cache Management",
    "title": "AdSDK Cache Management",
    "content": "The SDK supports a persistent cache with resources related to ad, these can be banners or other resources, depending on the type of ad. In this tutorial, we’ll look at how an application developer can control the cache. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.0.0/cache-management.html",
    
    "relUrl": "/5.0.0/cache-management.html"
  },"132": {
    "doc": "AdSDK Cache Management",
    "title": "Section 1: Limiting the cache size",
    "content": "In this section, we will learn how to limit the size of the cache. Step 1 . When we creating an AdService, we can specify the size of our cache in MB. Let’s change it to 20 MB. The cache size parameter is optional. If you do not specify it, the default cache size is 100 MB. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure( \"1800\", applicationContext, cacheSizeInMb = 20u ) initResult.get( onSuccess = { addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } // ... } . Step 2 . In addition, the SDK allows you to change the size of the cache over time. You can use AdService.setCacheSize method for this purpose. If the specified cache size is smaller than the size of already cached resources, the cache will delete resources to fit the new specified limit. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure( \"1800\", applicationContext, cacheSizeInMb = 20u ) initResult.get( onSuccess = { // coroutineScope.launch { AdService.setCacheSize(20u) } addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } // ... } . ",
    "url": "/nextgen-adsdk-android-release/5.0.0/cache-management.html#section-1-limiting-the-cache-size",
    
    "relUrl": "/5.0.0/cache-management.html#section-1-limiting-the-cache-size"
  },"133": {
    "doc": "AdSDK Cache Management",
    "title": "Section 2: Flushing the cache",
    "content": "Although the cache size reached to it limit, SDK will removes resources in FIFO order, sometimes you need to clear the cache completely. In this section, we will learn how we can do this. Step 1 . For example, let’s clear the cache in the case of an AdError.CacheWriteAction. To do this, let’s go back to the InlineAd file and add this code in the case of a AdService.makeAdvertisement method failure. File: InlineAd.kt . // ... class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { val tagUser = async { tagUser() } val conversionTracking = async { conversionTracking() } tagUser.await() conversionTracking.await() AdService.makeAdvertisement( adRequest, adEventListener = adEventListener ).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") when(it) { is AdError.CacheWriteAction -&gt; { } else -&gt; {} } advertisementState.value = ResultState.Error(it) } ) } } //... } . Step 2 . We create an method flushCache and use AdService.flushCache. File: InlineAd.kt . // ... class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { val tagUser = async { tagUser() } val conversionTracking = async { conversionTracking() } tagUser.await() conversionTracking.await() AdService.makeAdvertisement( adRequest, adEventListener = adEventListener ).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") when(it) { is AdError.CacheWriteAction -&gt; { flushCache() } else -&gt; {} } advertisementState.value = ResultState.Error(it) } ) } } fun flushCache() { viewModelScope.launch { AdService.flushCache().get( onSuccess = { Log.d(\"InlineAdViewModel\", \"FlushCache was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed flushCache: ${it.description}\") } ) } } // ... } . ",
    "url": "/nextgen-adsdk-android-release/5.0.0/cache-management.html#section-2-flushing-the-cache",
    
    "relUrl": "/5.0.0/cache-management.html#section-2-flushing-the-cache"
  },"134": {
    "doc": "AdSDK Cache Management",
    "title": "Section 3: Specify the cache path",
    "content": "In this section, we will see how to set the path of the cache. Step 1 . Like the size we can also set the custom path of the cache when we configure the AdService. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure( \"1800\", applicationContext, cacheSizeInMb = 20u, cachePath = cacheDir.path + \"/tutorialApp/\" ) initResult.get( onSuccess = { // coroutineScope.launch { AdService.setCacheSize(20u) } addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } // ... } . Step 2 . Similar to the size, the SDK allows you to change the path of the cache over time. You can use AdService.setCachePath method for this purpose. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure( \"1800\", applicationContext, cacheSizeInMb = 20u, cachePath = cacheDir.path + \"/tutorialApp/\" ) initResult.get( onSuccess = { // coroutineScope.launch { AdService.setCacheSize(20u) } // coroutineScope.launch { // AdService.setCachePath(cacheDir.path + \"/tutorialApp/\") // } addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } // ... } . ",
    "url": "/nextgen-adsdk-android-release/5.0.0/cache-management.html#section-3-specify-the-cache-path",
    
    "relUrl": "/5.0.0/cache-management.html#section-3-specify-the-cache-path"
  },"135": {
    "doc": "Create and display inline ads",
    "title": "Create and display inline ads",
    "content": "This tutorial will guide you how to create and display inline ads. An inline ad is an ad created to be displayed in your view hierarchy. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.0.0/create-and-display-inline-ads.html",
    
    "relUrl": "/5.0.0/create-and-display-inline-ads.html"
  },"136": {
    "doc": "Create and display inline ads",
    "title": "Creating an inline ads",
    "content": "Your AdService is ready for creating advertisements, so in this section, we will create an InlineAd composable for future ad display. Step 1 . Lets create an InlineAd composable and an InlineAdViewModel class. File: InlineAd.kt . @Composable fun InlineAd() { Text( text = \"Advertisement should be here\" ) } class InlineAdViewModel : ViewModel() { } . Step 2 . To create advertisements, we use the AdService.makeAdvertisement method. The most important parameter now is AdRequest, which describes the request that will be sent to the server to receive ads. The only mandatory parameter when creating the AdRequest is AdRequest.contentUnit or AdRequest.learningTag. Content unit is unique ID of a content space. You can also use AdRequest.learningTag, but we use AdRequest.contentUnit in this tutorial because it is more commonly used. File: InlineAd.kt . @Composable fun InlineAd() { Text( text = \"Advertisement should be here\" ) } class InlineAdViewModel : ViewModel() { private val adRequest = AdRequest(\"4810915\") } . Step 3 . The AdService.makeAdvertisement method returns AdResult. It is also suspendable we will use it in the viewModelScope. If the ad is created and loaded successfully, you will receive the downloaded Advertisement object. You can think of it as a ViewModel that holds the data and state of your ad. We’ll again use ResultState with Advertisement to identify whether the ad was created and loaded successfully. File: InlineAd.kt . @Composable fun InlineAd() { Text( text = \"Advertisement should be here\" ) } class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) init { viewModelScope.launch { AdService.makeAdvertisement(adRequest).get( onSuccess = { advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 4 . If we have an Advertisement instance, it remains to add a Composable. The sdk_presentation_compose has Ad, which is the presentation layer of your inline ad. File: InlineAd.kt . @Composable fun InlineAd() { val viewModel: InlineAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Ad(it.data) } } } } class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) init { viewModelScope.launch { AdService.makeAdvertisement(adRequest).get( onSuccess = { advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 5 . The last thing we need to do is add our Composable to the MainActivity. File: MainActivity.kt . class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val app = application as App app.adServiceStatus.observe(this) { result -&gt; when(result) { is ResultState.Error -&gt; { showAppError(result.exception) } is ResultState.Success -&gt; { setContent { TutorialAppTheme { InlineAd() } } } } } } private fun showAppError(adError: AdError) { Toast.makeText(this, \"Initialization failed: ${adError.description}\", Toast.LENGTH_LONG).show() } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.0/create-and-display-inline-ads.html#creating-an-inline-ads",
    
    "relUrl": "/5.0.0/create-and-display-inline-ads.html#creating-an-inline-ads"
  },"137": {
    "doc": "Create and display inline ads",
    "title": "Section 2: Defining the size of the advertisement",
    "content": "Our InlineAdViewModel and InlineAd can load and display ads, but how can we understand what size the Ad should be? In this section we will deal with this question. Step 1 . As we already know, Advertisement stores advertising data. Let’s try to get it! We can obtain all possible advertising data using AdMetadata. This is the one we will use to obtain the size data. We are interested in AdMetadata.aspectRatio, which is optional. We have implemented the logic so that in cases where it is not present, we will use the 2:1 ratio. File: InlineAd.kt . @Composable fun InlineAd() { val viewModel: InlineAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { it.data.adMetadata Ad(it.data) } } } } class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f init { viewModelScope.launch { AdService.makeAdvertisement(adRequest).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 2 . Now we can add the AdMetadata.aspectRatio via the Modifier into the Ad. File: InlineAd.kt . @Composable fun InlineAd() { val viewModel: InlineAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { it.data.adMetadata Ad( it.data, modifier = Modifier.aspectRatio(viewModel.aspectRatio) ) } } } } class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f init { viewModelScope.launch { AdService.makeAdvertisement(adRequest).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Now we should see the banner on our device. Congrats! . ",
    "url": "/nextgen-adsdk-android-release/5.0.0/create-and-display-inline-ads.html#section-2-defining-the-size-of-the-advertisement",
    
    "relUrl": "/5.0.0/create-and-display-inline-ads.html#section-2-defining-the-size-of-the-advertisement"
  },"138": {
    "doc": "Create and display interstitial ad",
    "title": "Create and display interstitial ad",
    "content": "A full-screen advertisement that fills the host app’s interface is known as an interstitial ad. In this tutorial we will add an interstitial ad to our application. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.0.0/create-and-display-interstitial-ad.html",
    
    "relUrl": "/5.0.0/create-and-display-interstitial-ad.html"
  },"139": {
    "doc": "Create and display interstitial ad",
    "title": "Section 1: Prepare app for interstitial ad",
    "content": "We want to present the interstitial on a different screen and add navigation buttons for it. Step 1 . Let’s create a new MainScreen file in which we add Navigation and MainScreen. Note: At the moment you will get an error, because we have not created InterstitialScreen yet. File: MainScreen.kt . @Composable fun Navigation() { val navController = rememberNavController() NavHost(navController = navController, startDestination = \"mainScreen\") { composable(\"mainScreen\") { MainScreen(navController) } composable(\"interstitial\") { InterstitialScreen() } } } @Composable fun MainScreen(navController: NavController) { Scaffold( floatingActionButton = { ExtendedFloatingActionButton( onClick = { navController.navigate(\"interstitial\") }, content = { Text(\"Go to Interstitial\") }, ) } ) { innerPadding -&gt; Column( modifier = Modifier .fillMaxSize() .padding(innerPadding), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { InlineAd() Spacer(modifier = Modifier.height(16.dp)) } } } . Step 2 . The next step is to create our future screen for displaying interstitial ads. Create a new InterstitialScreen file and add a screen with a button to it. File: InterstitialScreen.kt . @Composable fun InterstitialScreen() { Box( modifier = Modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { Button( onClick = { }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } } } class InterstitialAdViewModel : ViewModel() { } . ",
    "url": "/nextgen-adsdk-android-release/5.0.0/create-and-display-interstitial-ad.html#section-1-prepare-app-for-interstitial-ad",
    
    "relUrl": "/5.0.0/create-and-display-interstitial-ad.html#section-1-prepare-app-for-interstitial-ad"
  },"140": {
    "doc": "Create and display interstitial ad",
    "title": "Section 2: Creating interstitial advertisements",
    "content": "We have already created an inline Advertisement on a previous chapter. In this section, we will create a interstitial ad for the future presentation. Step 1 . Interstitial ad is created in the same way as inline ads, with one difference – the placementType parameter must be AdPlacementType.INTERSTITIAL. Let’s add the logic for loading the advertisement into InterstitialAdViewModel. We’ll again use ResultState with Advertisement to identify whether the ad was created and loaded successfully. File: InterstitialScreen.kt . @Composable fun InterstitialScreen() { Box( modifier = Modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { Button( onClick = { }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = AdPlacementType.INTERSTITIAL, ).get( onSuccess = { advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 2 . We add the InterstitialAdViewModel to the InterstitialAd. File: InterstitialScreen.kt . @Composable fun InterstitialScreen() { val viewModel: InterstitialAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = AdPlacementType.INTERSTITIAL, ).get( onSuccess = { advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.0/create-and-display-interstitial-ad.html#section-2-creating-interstitial-advertisements",
    
    "relUrl": "/5.0.0/create-and-display-interstitial-ad.html#section-2-creating-interstitial-advertisements"
  },"141": {
    "doc": "Create and display interstitial ad",
    "title": "Section 3: Presenting interstitial ad",
    "content": "We learnt how to create interstitial advertisement. Now, we are ready to present our interstitial ad. In this section, we will display interstitial ad in our app. Step 1 . Our AdSDK provides AdInterstitialState to control the state of the interstitial ad presentation. Add a property for this in the InterstitialAdViewModel. File: InterstitialScreen.kt . fun InterstitialScreen() { val viewModel: InterstitialAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisement = mutableStateOf&lt;Advertisement?&gt;(null) lateinit var interstitialState: AdInterstitialState init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = PlacementType.INTERSTITIAL, adEventListener = adEventListener ).get( onSuccess = { interstitialState = AdInterstitialState(it, this) advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"AdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 2 . The next step will be adding a presentation layer. To display interstitial ads, SDK has an Interstitial composable. Add it to your InterstitialScreen and pass the state value from the InterstitialAdViewModel. File: InterstitialScreen.kt . @Composable fun InterstitialScreen(modifier: Modifier) { val viewModel: InterstitialAdViewModel = viewModel() Box( modifier = modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } Interstitial(viewModel.interstitialState) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisement = mutableStateOf&lt;Advertisement?&gt;(null) lateinit var interstitialState: AdInterstitialState init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = PlacementType.INTERSTITIAL ).get( onSuccess = { interstitialState = AdInterstitialState(it, this) advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 3 . To show an interstitial ad, you can use the AdInterstitialState.presentIfLoaded method. Note: If you don’t use the Advertisement.reload method, your Advertisement object will always be loaded, which means that the ad will be presented to the user immediately when AdInterstitialState.presentIfLoaded method called. Otherwise, the ad will be presented immediately after loading. File: InterstitialScreen.kt . fun InterstitialScreen() { val viewModel: InterstitialAdViewModel = viewModel() Box( modifier = modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { viewModel.interstitialState.presentIfLoaded() }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } Interstitial(viewModel.interstitialState) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisement = mutableStateOf&lt;Advertisement?&gt;(null) lateinit var interstitialState: AdInterstitialState init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = PlacementType.INTERSTITIAL ).get( onSuccess = { interstitialState = AdInterstitialState(it, this) advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.0/create-and-display-interstitial-ad.html#section-3-presenting-interstitial-ad",
    
    "relUrl": "/5.0.0/create-and-display-interstitial-ad.html#section-3-presenting-interstitial-ad"
  },"142": {
    "doc": "Create and display interstitial ad",
    "title": "Section 3: Hiding interstitial ad",
    "content": "We managed to successfully show the ad, but we would like to be able to close interstitial. In this section, we implement this logic. Step 1 . Let’s continue the development in our InterstitialScreen file. We could hide the ad by simply calling the AdInterstitialState.hide method, but we don’t know when to call it. In order to understand when ad should be hidden, we need to use AdEventListener. We will explain the AdEventListener in more detail in the next chapter. Let’s create an adEventListener in InterstitialAdViewModel, and then pass it to the AdService.makeAdvertisement. File: InterstitialScreen.kt . fun InterstitialScreen() { val viewModel: InterstitialAdViewModel = viewModel() Box( modifier = modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { viewModel.interstitialState.presentIfLoaded() }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } Interstitial(viewModel.interstitialState) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) lateinit var interstitialState: AdInterstitialState val adEventListener: AdEventListener = object : AdEventListener { override fun eventProcessed(adEventType: AdEventType, adMetadata: AdMetadata) { Log.d(\"InterstitialAdViewModel events\", \"Collected EVENT - $adEventType\") } } init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = AdPlacementType.INTERSTITIAL, adEventListener = adEventListener ).get( onSuccess = { interstitialState = AdInterstitialState(it, this) advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 2 . The event we are interested in is AdEventType.UnloadRequest. We need to observe it to make sure that the ad is hidden when it is needed. Note: You should not change the state from presented to hidden without using AdEventType.UnloadRequest event. The advert itself knows when it needs to be hidden and asks you to hide it using this method. File: InterstitialScreen.kt . fun InterstitialScreen() { val viewModel: InterstitialAdViewModel = viewModel() Box( modifier = modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { viewModel.interstitialState.presentIfLoaded() }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } Interstitial(viewModel.interstitialState) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) lateinit var interstitialState: AdInterstitialState val adEventListener: AdEventListener = object : AdEventListener { override fun eventProcessed(adEventType: AdEventType, adMetadata: AdMetadata) { Log.d(\"InterstitialAdViewModel events\", \"Collected EVENT - $adEventType\") if (adEventType == AdEventType.UnloadRequest) { interstitialState.hide() } } } init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = AdPlacementType.INTERSTITIAL, adEventListener= adEventListener ).get( onSuccess = { interstitialState = AdInterstitialState(it, this) advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Now, if you launch the app, you should see an interstitial ad. ",
    "url": "/nextgen-adsdk-android-release/5.0.0/create-and-display-interstitial-ad.html#section-3-hiding-interstitial-ad",
    
    "relUrl": "/5.0.0/create-and-display-interstitial-ad.html#section-3-hiding-interstitial-ad"
  },"143": {
    "doc": "First steps for working with AdSDK",
    "title": "First steps for working with AdSDK",
    "content": "This tutorial will guide you through the first steps of working with the AdSDK - creating an AdService. You can download this this project which already implements all the steps of this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.0.0/first-steps.html",
    
    "relUrl": "/5.0.0/first-steps.html"
  },"144": {
    "doc": "First steps for working with AdSDK",
    "title": "Creating an AdService",
    "content": "Creating and configuring an AdService for later ad creation and loading. Step 1 . Create a new Android project and remove any unnecessary code. Make sure you have added the correct packages from the readme. Step 2 . The entry point into the SDK is the AdService class. This is the first thing we should create, as it will be used to generate advertisements in the future. For an easy start, we will simply configure the AdService in the App class. We create a file called App and add it to the MainActivity as well. File: App.kt . class App : Application() { override fun onCreate() { super.onCreate() } } . File: MainActivity.kt . class MainActivity : ComponentActivity() { override fun onCreate() { super.onCreate() val app = application as App // ... } } // ... Remember to add this class as an entry point, so add it to the application in your Manifest. File: AndroidManifest.xml . android:name=\"com.adition.tutorial_app.App\" . Step 3 . Before using the AdService, we should first configure it. To do this, we will use the AdService.configure method in the App class. The only mandatory parameter when configuring an AdService is AdService.networkId. The network identifier is the identifier of your advertising account. The configure method is suspendable, so we should use the coroutine. To do this, we need to create a coroutineScope and add this code to the onCreate function of the App class. class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) override fun onCreate() { super.onCreate() coroutineScope.launch { AdService.configure(\"1800\", applicationContext) } } } . Step 4 . AdService.configure returns AdResult, which is our custom AdSDK implementation of Kotlin’s Result. AdResult contains AdError the only type of error which the SDK supports. We can use AdResult to check that the AdService has been successfully configured and initialised. Let us add a ResultState class to monitor the status. File: ResultState . sealed class ResultState&lt;out T&gt; { data class Success&lt;out T&gt;(val data: T) : ResultState&lt;T&gt;() data class Error&lt;T&gt;(val exception: AdError) : ResultState&lt;T&gt;() } . We can use this status in the App file. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure(\"1800\", applicationContext) initResult.get( onSuccess = { adServiceStatus.value = ResultState.Success(Unit) }, onError = { adServiceStatus.value = ResultState.Error(it) } ) } } } . Step 5 . We can now use adServiceStatus in the onCreate function of the MainActivity. File: MainActivity.kt . class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val app = application as App app.adServiceStatus.observe(this) { result -&gt; when(result) { is ResultState.Error -&gt; { // We will handle in the next step. } is ResultState.Success -&gt; { setContent { TutorialAppTheme { Greeting(name = \"AdSDK\") } } } } } } } // ... Step 6 . We could react on all the different error cases AdError contains. To keeps it easy we just show the description of the AdError. File: MainActivity.kt . class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val app = application as App app.adServiceStatus.observe(this) { result -&gt; when(result) { is ResultState.Error -&gt; { showAppError(result.exception) } is ResultState.Success -&gt; { setContent { TutorialAppTheme { Greeting(name = \"AdSDK\") } } } } } } private fun showAppError(adError: AdError) { Toast.makeText(this, \"Initialization failed: ${adError.description}\", Toast.LENGTH_LONG).show() } } // ... Now, if you’ve done everything right, you should see the greeting message when you launch the app. This completes the AdService configuration, congratulations! . ",
    "url": "/nextgen-adsdk-android-release/5.0.0/first-steps.html#creating-an-adservice",
    
    "relUrl": "/5.0.0/first-steps.html#creating-an-adservice"
  },"145": {
    "doc": "Global request parameters",
    "title": "Global request parameters",
    "content": "We already know how to create and perform AdRequest, TagRequest, and TrackingRequest. However, each of them can have additional parameters, which are called global parameters because they are specified globally for all requests. The SDK provides the ability to add global parameters once so that you don’t have to copy them when creating each request. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.0.0/global-request-parameters.html",
    
    "relUrl": "/5.0.0/global-request-parameters.html"
  },"146": {
    "doc": "Global request parameters",
    "title": "Modifying global parameters",
    "content": "In this section we’ll configure the AdRequestGlobalParameters and TrackingGlobalParameters for each AdRequest, TagRequest, and TrackingRequest we have in our application. We will also look at the possibility of removing global parameters. Step 1 . We can add global parameters using the AdService. The AdService has a AdService.setAdRequestGlobalParameter method which we will use to set the gdpr parameter for each AdRequest. Add the global parameters to the App class and a function addGlobalParameters(). Note: If we want to remove a ad request global parameter we could use the AdService.removeAdRequestGlobalParameter method. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure(\"1800\", applicationContext) initResult.get( onSuccess = { addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } private fun addGlobalParameters() { val gdpr = GDPR(consent = \"gdprconsentexample\", isRulesEnabled = true) AdService.setAdRequestGlobalParameter(AdRequestGlobalParameters::gdpr, gdpr) // AdService.removeAdRequestGlobalParameter(AdRequestGlobalParameters::gdpr) } } . Step 2 . We can also modify TrackingGlobalParameters for each TagRequest and TrackingRequest using the AdService.setTrackingGlobalParameter method. Let’s add this code to the addGlobalParameters method. Note: If we want to remove a tracking global parameter we could use the AdService.removeTrackingGlobalParameter method. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure(\"1800\", applicationContext) initResult.get( onSuccess = { addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } private fun addGlobalParameters() { val gdpr = GDPR(consent = \"gdprconsentexample\", isRulesEnabled = true) AdService.setAdRequestGlobalParameter(AdRequestGlobalParameters::gdpr, gdpr) // AdService.removeAdRequestGlobalParameter(AdRequestGlobalParameters::gdpr) AdService.setTrackingGlobalParameter(TrackingGlobalParameters::gdpr, gdpr) // AdService.removeTrackingGlobalParameter(TrackingGlobalParameters::gdpr) } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.0/global-request-parameters.html#modifying-global-parameters",
    
    "relUrl": "/5.0.0/global-request-parameters.html#modifying-global-parameters"
  },"147": {
    "doc": "Handling the ad events",
    "title": "Monitor and process ad-related events",
    "content": "Advertisement do a lot of work under the hood and can send messages about them to the app. In turn, you can monitor and react to it in some way. In this tutorial, we’ll look at what events are handled by Advertisement and how we can interact with them. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.0.0/handling-the-ad-events.html#monitor-and-process-ad-related-events",
    
    "relUrl": "/5.0.0/handling-the-ad-events.html#monitor-and-process-ad-related-events"
  },"148": {
    "doc": "Handling the ad events",
    "title": "Section 1: Observing events",
    "content": "We will use the AdEventListener to observe the AdEventType. Since we used the AdEventListener in the interstitial tutorial, this time we will add it to the other InlineAdViewModel to observe all the AdEventType. Step 1 . Lets add an AdEventListener to the InlineAdViewModel and pass it to the AdService.makeAdvertisement. File: InlineAd.kt . // ... class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f val adEventListener: AdEventListener = object : AdEventListener { override fun eventProcessed(adEventType: AdEventType, adMetadata: AdMetadata) { Log.d(\"InlineAdViewModel events\", \"Collected EVENT - $adEventType\") } } init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, adEventListener = adEventListener ).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 2 . Here we can see the different AdEventType we can observe: . | Impression | Viewable | Tap | UnloadRequest | RendererMessageReceived | CustomTrackingEvent | . Now let us add all possible AdEventType to the AdEventListener.eventProcessed method of the adEventListener. File: InlineAd.kt . // ... class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f val adEventListener: AdEventListener = object : AdEventListener { override fun eventProcessed(adEventType: AdEventType, adMetadata: AdMetadata) { Log.d(\"InlineAdViewModel events\", \"Collected EVENT - $adEventType\") when (adEventType) { is AdEventType.Impression -&gt; {} is AdEventType.RendererMessageReceived -&gt; {} is AdEventType.CustomTrackingEvent -&gt; {} is AdEventType.Tap -&gt; {} is AdEventType.UnloadRequest -&gt; {} is AdEventType.Viewable -&gt; {} } } } init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, adEventListener = adEventListener ).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 3 . We have already seen UnloadRequest in the interstitial example. Lets look at the Viewable event and monitor each VisibilityPercentage in this example. Note: Impression and Viewable can only be observed if they are configured in the ad server backend. Otherwise they are not part of the ad response. File: InlineAd.kt . // ... class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f val adEventListener: AdEventListener = object : AdEventListener { override fun eventProcessed(adEventType: AdEventType, adMetadata: AdMetadata) { Log.d(\"InlineAdViewModel events\", \"Collected EVENT - $adEventType\") when (adEventType) { is AdEventType.Impression -&gt; {} is AdEventType.RendererMessageReceived -&gt; {} is AdEventType.CustomTrackingEvent -&gt; {} is AdEventType.Tap -&gt; {} is AdEventType.UnloadRequest -&gt; {} is AdEventType.Viewable -&gt; { when (adEventType.percentage) { AdEventType.VisibilityPercentage.ONE -&gt; { Log.d(\"InlineAdViewModel events\", \"1% of my ads are now visible on the screen.\") } AdEventType.VisibilityPercentage.FIFTY -&gt; { Log.d(\"InlineAdViewModel events\", \"50% of my ads are now visible on the screen.\") } AdEventType.VisibilityPercentage.ONE_HUNDRED -&gt; { Log.d(\"InlineAdViewModel events\", \"100% of my ads are now visible on the screen.\") } } } } } } init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, adEventListener = adEventListener ).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.0/handling-the-ad-events.html#section-1-observing-events",
    
    "relUrl": "/5.0.0/handling-the-ad-events.html#section-1-observing-events"
  },"149": {
    "doc": "Handling the ad events",
    "title": "Handling the ad events",
    "content": " ",
    "url": "/nextgen-adsdk-android-release/5.0.0/handling-the-ad-events.html",
    
    "relUrl": "/5.0.0/handling-the-ad-events.html"
  },"150": {
    "doc": "Meet nextgen AdSDK",
    "title": "Meet nextgen AdSDK",
    "content": "Manage, display, and create your custom advertisements on Android using cutting-edge technologies such as Jetpack Compose and Coroutines based on the AdSDK. ",
    "url": "/nextgen-adsdk-android-release/5.0.0/meet-adsdk.html",
    
    "relUrl": "/5.0.0/meet-adsdk.html"
  },"151": {
    "doc": "Meet nextgen AdSDK",
    "title": "Chapter 1",
    "content": "Working with the built-in capabilities of the SDK. In this chapter, you will learn how to create, display, and manage advertisements using AdSDK. | First steps for working with AdSDK | Create and display inline ads | Create and display interstitial ad | Handling the ad events | User tagging and conversion tracking | Global request parameters | AdSDK Cache Management | . ",
    "url": "/nextgen-adsdk-android-release/5.0.0/meet-adsdk.html#chapter-1",
    
    "relUrl": "/5.0.0/meet-adsdk.html#chapter-1"
  },"152": {
    "doc": "User tagging and conversion tracking",
    "title": "User tagging and conversion tracking",
    "content": "AdSDK provides powerful functionality for user tagging and conversion tracking. In this tutorial we will explore this functionality. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.0.0/user-tagging-conversion-tracking.html",
    
    "relUrl": "/5.0.0/user-tagging-conversion-tracking.html"
  },"153": {
    "doc": "User tagging and conversion tracking",
    "title": "Section 1: User tagging",
    "content": "The SDK provides functionality to put a user identifier, such as a cookie id, into a retargeting segment (to tag a user). This allows advertisers to create a segment of users with certain interests or affinities, and to re-advertise to this segment (retargeting). In this section, we will look at how to perform a tag request using the AdSDK. Step 1 . To tag a user we need a TagRequest, that describes the request for tagging and consists of tags with a key, a subkey, and a value. We keep it simple and just add a tagUser() method to the InlineAdViewModel and create a TagRequest with one TagRequest.Tag. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) } } . Step 2 . We pass the TagRequest to the AdService.tagUser. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request) } } . Step 3 . The AdService.tagUser method returns an AdResult, so let’s log the result. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } } . Step 4 . To make sure the user is tagged before we call AdService.makeAdvertisement, we will use the coroutines async method. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { val tagUser = async { tagUser() } tagUser.await() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.0/user-tagging-conversion-tracking.html#section-1-user-tagging",
    
    "relUrl": "/5.0.0/user-tagging-conversion-tracking.html#section-1-user-tagging"
  },"154": {
    "doc": "User tagging and conversion tracking",
    "title": "Section 2: Conversion tracking",
    "content": "The SDK allows you to track conversions. This is useful for advertisers as conversion details are available in post tracking reports via the ad server. In this section we will look at how to perform a tracking request using the AdSDK. Step 1 . A conversion tracking request is described using TrackingRequest. We add a conversionTracking() function to the InlineAdViewModel . File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() conversionTracking() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } private suspend fun conversionTracking() { val request = TrackingRequest( landingPageId = 1, trackingSpotId = 1, orderId = \"orderId\", itemNumber = \"itemNumber\", description = \"description\", quantity = 1, price = 19.99f, total = 39.98f ) } } . Step 2 . We pass the TrackingRequest to the AdService.trackingRequest. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() conversionTracking() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } private suspend fun conversionTracking() { val request = TrackingRequest( landingPageId = 1, trackingSpotId = 1, orderId = \"orderId\", itemNumber = \"itemNumber\", description = \"description\", quantity = 1, price = 19.99f, total = 39.98f ) AdService.trackingRequest(request) } } . Step 3 . The AdService.trackingRequest method also returns an AdResult, so let’s log the result. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() conversionTracking() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } private suspend fun conversionTracking() { val request = TrackingRequest( landingPageId = 1, trackingSpotId = 1, orderId = \"orderId\", itemNumber = \"itemNumber\", description = \"description\", quantity = 1, price = 19.99f, total = 39.98f ) AdService.trackingRequest(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"Conversion tracking was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed conversion tracking: ${it.description}\") } ) } } . Step 4 . To ensure that the conversion tracking is done before we call the AdService.makeAdvertisement method, we will use the coroutines async method. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { val tagUser = async { tagUser() } val conversionTracking = async { conversionTracking() } tagUser.await() conversionTracking.await() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } private suspend fun conversionTracking() { val request = TrackingRequest( landingPageId = 1, trackingSpotId = 1, orderId = \"orderId\", itemNumber = \"itemNumber\", description = \"description\", quantity = 1, price = 19.99f, total = 39.98f ) AdService.trackingRequest(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"Conversion tracking was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed conversion tracking: ${it.description}\") } ) } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.0/user-tagging-conversion-tracking.html#section-2-conversion-tracking",
    
    "relUrl": "/5.0.0/user-tagging-conversion-tracking.html#section-2-conversion-tracking"
  },"155": {
    "doc": "Create and display inline ads",
    "title": "Create and display inline ads",
    "content": "This tutorial will guide you through creating a simple application that can load and display a list of ads. ",
    "url": "/nextgen-adsdk-android-release/4.6.0/create-and-display-inline-ads.html",
    
    "relUrl": "/4.6.0/create-and-display-inline-ads.html"
  },"156": {
    "doc": "Create and display inline ads",
    "title": "Section 1: Getting started with AdSDK",
    "content": "Add and configure the AdSDK to create and load ads. Step 1 . Let’s create a new Android project and remove all unnecessary code. Make sure you have added the correct packages from the readme. Step 2 . The entry point into the SDK is the AdService class. To make an easy start we just initialize the AdService in the onCreate method of the MainActivity. This is the first thing we should create, as it will be used to generate advertisements in the future. To do this, we will add this code: . coroutineScope.launch { val isSuccess = AdService.init(\"1800\", applicationContext, EventHandler()) Log.d(\"AdSDK\", \"Init is success: $isSuccess\") } . Lets create an App file and class to add the AdService initialisation. To do this, create this class and add the code snippet from above. The only mandatory parameter when creating AdService is the networkId. Network ID is the ID of your advertising account. Our Code should now look like this: . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) override fun onCreate() { super.onCreate() coroutineScope.launch { val isSuccess = AdService.init(\"1800\", applicationContext, EventHandler()) Log.d(\"App\", \"Init is success: $isSuccess\") } } } . Remember to add this class as an entry point, so add it to the application in your `Manifest: . android:name=\"com.adition.adsdk.App\" . Step 3 . The next step will be to create a composable, which we will display upon successful creation of AdService. On this composable, we will be creating and displaying our advertisement. @Composable fun AdView() { Text( text = \"Advertisement should be here\" ) } . Now we can call this in our composable in the MainActivity. class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { AdsdkdemoappandroidTheme { AdView() } } } } . ",
    "url": "/nextgen-adsdk-android-release/4.6.0/create-and-display-inline-ads.html#section-1-getting-started-with-adsdk",
    
    "relUrl": "/4.6.0/create-and-display-inline-ads.html#section-1-getting-started-with-adsdk"
  },"157": {
    "doc": "Create and display inline ads",
    "title": "Section 2: Loading and displaying advertisements",
    "content": "Step 1 . Before we create an Advertisement object we want to add a ViewModel: . class MainViewModel: ViewModel() { } . Step 2 . To create an Advertisement object, you need to specify parameters, two of which are required: . | contentId or learningTag | adTypes We’re going to use the contentId because it’s used more often than the learningTag. Content Unit is the unique ID of your advertising space and for ad type we use AdComposeRenderRegistry.getAllRendererNames() this will enable all available adTypes. Another important parameter is placementType. In this case, we need AdPlacementType.INLINE, which is the default, so we ignore it. All possible parameters can be found in the AdvertisementParameters documentation. | . class MainViewModel: ViewModel() { var ad: Advertisement = Advertisement( \"4810915\", AdComposeRenderRegistry.getAllRendererNames(), ) } . We can now load this advertisement using loadAdvertisement: . class MainViewModel: ViewModel() { var ad: Advertisement = Advertisement( \"4810915\", AdComposeRenderRegistry.getAllRendererNames(), ) init { viewModelScope.launch { ad.loadAdvertisement() } } } . Step 3 . We can pass this Advertisement now to the rememberAdState composable. The rememberAdState creates the AdState which we will use later. There are multiple versions of the rememberAdState. For example we could pass a content unit directly to the rememberAdState and it would create the Advertisement for us. @Composable fun AdView(viewModel: MainViewModel) { val adState = rememberAdState(advertisement = viewModel.ad) } . Step 4 . We can pass the AdState to Ad composable. The Ad is the main composable used to display the ad with provided adState. @Composable fun AdView() { val adState = rememberAdState(advertisement = viewModel.ad) Ad(adState = adState, modifier = Modifier) } . How our MainActivity should look like: . class MainActivity : ComponentActivity() { private val viewModel by viewModels&lt;MainViewModel&gt;() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { AdsdkdemoappandroidTheme { AdView(viewModel) } } } } @Composable fun AdView(viewModel: MainViewModel) { val adState = rememberAdState(advertisement = viewModel.ad) Ad(adState = adState, modifier = Modifier) } . Now we should see the Banner on our device: . ",
    "url": "/nextgen-adsdk-android-release/4.6.0/create-and-display-inline-ads.html#section-2-loading-and-displaying-advertisements",
    
    "relUrl": "/4.6.0/create-and-display-inline-ads.html#section-2-loading-and-displaying-advertisements"
  },"158": {
    "doc": "Create and display interstitial ad section",
    "title": "Create and display interstitial ad section",
    "content": "A full-screen advertisement that fills the host app’s interface is known as an interstitial ad. In this tutorial we are going to add interstitial ad into our application. ",
    "url": "/nextgen-adsdk-android-release/4.6.0/create-and-display-interstitial-ad-section.html",
    
    "relUrl": "/4.6.0/create-and-display-interstitial-ad-section.html"
  },"159": {
    "doc": "Create and display interstitial ad section",
    "title": "Section 1: Interstitial Ad Object",
    "content": "In this section we will create an interstitial Advertisement object. Step 1 . Lets change the structure of our AdsdkdemoappandroidTheme composable. We create a MainContent composable and move the AdView call over there. AdsdkdemoappandroidTheme { MainContent(viewModel) } . @Composable fun MainContent(viewModel: MainViewModel) { Box(modifier = Modifier.fillMaxSize()) { AdView(viewModel) } } . Step 2 . To create a interstitial banner we use the Advertisement class again. Only difference this time we add the different placementType INTERSTITIAL We add the interstitialAd in the MainViewModel. var interstitialAd: Advertisement = Advertisement( \"5192923\", AdComposeRenderRegistry.getAllRendererNames(), placementType = PlacementType.INTERSTITIAL ) . Step 3 . We can add now a composable for the fullscreen interstitial. @Composable fun ShowInterstitial(viewModel: MainViewModel) { var adState = rememberAdState(viewModel.interstitialAd) Box ( contentAlignment = Alignment.Center, modifier = Modifier.fillMaxSize() ){ Ad(adState = adState) } } . Step 4 . To trigger the interstitial composable we will use a button which we add at the bottom. @Composable fun BottomButton(onClick: () -&gt; Unit) { Box(modifier = Modifier.fillMaxSize()) { Button( onClick = onClick, modifier = Modifier .align(Alignment.BottomCenter) .padding(bottom = 16.dp) ) { Text(\"Show interstitial\") } } } . Step 5 . To control the interstitial presentation we will use a state value, which will be set to true if we click on the button. val showInterstitialComposable = remember { mutableStateOf(false) } BottomButton( onClick = { showInterstitialComposable.value = !showInterstitialComposable.value } ) . Step 6 . Now lets structure this all together in our MainContent composable we created above. @Composable fun MainContent(viewModel: MainViewModel) { val showInterstitialComposable = remember { mutableStateOf(false) } Box(modifier = Modifier.fillMaxSize()) { AdView(viewModel) BottomButton( onClick = { showInterstitialComposable.value = !showInterstitialComposable.value } ) if (showInterstitialComposable.value) { ShowInterstitial(viewModel) } } } . ",
    "url": "/nextgen-adsdk-android-release/4.6.0/create-and-display-interstitial-ad-section.html#section-1-interstitial-ad-object",
    
    "relUrl": "/4.6.0/create-and-display-interstitial-ad-section.html#section-1-interstitial-ad-object"
  },"160": {
    "doc": "Defining the size of the advertisement",
    "title": "Defining the size of the advertisement",
    "content": "This tutorial will teach you how to define the size of the advertisement, taking into account the aspect ratio parameter. In it, we will continue the development of the application we started in the previous section. ",
    "url": "/nextgen-adsdk-android-release/4.6.0/defining-the-size-of-the-advertisement.html",
    
    "relUrl": "/4.6.0/defining-the-size-of-the-advertisement.html"
  },"161": {
    "doc": "Defining the size of the advertisement",
    "title": "Section 1: Defining the size of the advertisement",
    "content": "Step 1 . For the the size of the advertisement we can use AdMetadata. From this object we can get the basic information after the advertising content has been loaded from the server. We will use the aspectRatio from the adMetadata. So let’s get the adMetadata from adState: . val aspectRatio = adState.adMetaData?.aspectRatio ?: 2F . Since aspectRatio is optional, we use the default value of 2:1 in this project. Step 2 . Now we can add the aspectRatio via the Modifier into the Ad composable. @Composable fun AdView(viewModel: MainViewModel) { val adState = rememberAdState(advertisement = viewModel.ad) val aspectRatio = adState.adMetaData?.aspectRatio ?: 2F Ad( adState = adState, modifier = Modifier .aspectRatio(aspectRatio) ) when (val state = adState?.state) { is AdState.State.Error -&gt; { when(state.adException.adError) { AdError.DECODING -&gt; { Log.e(\"MainActivity\", \"Decoding error: ${state.adException.exception}\") } } } is AdState.State.Loading -&gt; { // We are Caching. } is AdState.State.Caching -&gt; { // We are Caching. } is AdState.State.AdReadyToDisplay -&gt; { // Ad is ready and will be displayed. } else -&gt; {} } } . Note: In this case, we are requesting the adMetaData before the ad is successfully loaded, but when the ad is successfully loaded, the composable will be updated and we will get this data. In a real-world scenario, you would most likely use a ViewModel‘ or other state management mechanism where you could implement logic to ensure that the adMetaData’ is only requested when the ad is already loaded. ",
    "url": "/nextgen-adsdk-android-release/4.6.0/defining-the-size-of-the-advertisement.html#section-1-defining-the-size-of-the-advertisement",
    
    "relUrl": "/4.6.0/defining-the-size-of-the-advertisement.html#section-1-defining-the-size-of-the-advertisement"
  },"162": {
    "doc": "Global ad request parameters",
    "title": "Global ad request parameters",
    "content": "An ad request can have additional parameters beyond those you pass during initialization. These additional parameters are global for all ad requests. The SDK provides the ability to add global parameters once so that you don’t have to copy them when creating each ad request. ",
    "url": "/nextgen-adsdk-android-release/4.6.0/global-adRequest-parameters.html",
    
    "relUrl": "/4.6.0/global-adRequest-parameters.html"
  },"163": {
    "doc": "Global ad request parameters",
    "title": "Section 1: Modifying global parameters",
    "content": "In this section, we’ll configure the gdpr parameter for each ad request that we have in our app. In addition, we will review the possibility of removing global parameters. You can configure not only GDPR but also other parameters. You can find a list of all global parameters in the AdRequestGlobalParameters documentation. Step 1 . We can add global parameters via the AdService. The AdService has setAdRequestGlobalParameter method which we use to set the gdpr parameter. AdService.getInstance().setAdRequestGlobalParameter( AdRequestGlobalParameters::gdpr, GDPR(consent = \"gdprconsentexample\", isRulesEnabled = true) ) . Step 2 . To make it easy we will add the global parameters in the App class. class App : Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) override fun onCreate() { super.onCreate() coroutineScope.launch { val isSuccess = AdService.init(\"1800\", applicationContext, EventHandler()) Log.d(\"App\", \"Init is success: $isSuccess\") launch { AdService.getInstance().eventHandler?.events?.collect { event -&gt; Log.d(\"Events\", \"Collected EVENT - $event\") when (event.eventType) { is EventType.Tap -&gt; { // Ad got tapped. } else -&gt; {} } } } launch { AdService.getInstance().setAdRequestGlobalParameter( AdRequestGlobalParameters::gdpr, GDPR(consent = \"gdprconsentexample\", isRulesEnabled = true) ) } } } override fun onTerminate() { super.onTerminate() coroutineScope.cancel() } } . Step 3 . If we want to remove an global parameter we could use the removeAdRequestGlobalParameter method. AdService.getInstance().removeAdRequestGlobalParameter( AdRequestGlobalParameters::gdpr ) . ",
    "url": "/nextgen-adsdk-android-release/4.6.0/global-adRequest-parameters.html#section-1-modifying-global-parameters",
    
    "relUrl": "/4.6.0/global-adRequest-parameters.html#section-1-modifying-global-parameters"
  },"164": {
    "doc": "Handling the state and events of advertising",
    "title": "Handling the state and events",
    "content": "This tutorial will help you observe and respond to changes in the state and events. In it, we will continue the development of the application we started in the previous section. ",
    "url": "/nextgen-adsdk-android-release/4.6.0/handling-the-state-and-events-of-advertising.html#handling-the-state-and-events",
    
    "relUrl": "/4.6.0/handling-the-state-and-events-of-advertising.html#handling-the-state-and-events"
  },"165": {
    "doc": "Handling the state and events of advertising",
    "title": "Section 1: Observing the states",
    "content": "When we talk about state we mean the lifecycle state of the Ads composable. Step 1 . The state of an Ad is called AdState. This is an example of how we can observe the AdState: . when (val state = adState?.state) { is AdState.State.Error -&gt; { // We have an error. } is AdState.State.Loading -&gt; { // We are Caching. } is AdState.State.Caching -&gt; { // We are Caching. } is AdState.State.AdReadyToDisplay -&gt; { // Ad is ready and will be displayed. } else -&gt; {} } . Here we can see the different ad states we can observe: . | Error | Loading | Caching | ",
    "url": "/nextgen-adsdk-android-release/4.6.0/handling-the-state-and-events-of-advertising.html#section-1-observing-the-states",
    
    "relUrl": "/4.6.0/handling-the-state-and-events-of-advertising.html#section-1-observing-the-states"
  },"166": {
    "doc": "Handling the state and events of advertising",
    "title": "AdReadyToDisplay",
    "content": "Step 2 . Let’s add the code snippet from above to our AdView example: . @Composable fun AdView() { val adState = rememberAdState(advertisement = viewModel.ad) Ad(adState = adState, modifier = Modifier) when (val state = adState?.state) { is AdState.State.Error -&gt; { // We have an error. } is AdState.State.Loading -&gt; { // We are Caching. } is AdState.State.Caching -&gt; { // We are Caching. } is AdState.State.AdReadyToDisplay -&gt; { // Ad is ready and will be displayed and we could additional work } else -&gt; {} } } . We are able now to act accordingly to each AdState state. | . ",
    "url": "/nextgen-adsdk-android-release/4.6.0/handling-the-state-and-events-of-advertising.html#adreadytodisplay",
    
    "relUrl": "/4.6.0/handling-the-state-and-events-of-advertising.html#adreadytodisplay"
  },"167": {
    "doc": "Handling the state and events of advertising",
    "title": "Section 2: Handling errors during the loading and decoding",
    "content": "Sometimes it’s important for an app to be able to handle errors correctly. With the help of AdError, you can catch a specific error and implement the logic for handling it the way you need. Step 1 . We can observe errors in the AdSDK with AdException. An AdException holds the exception itself and the type of the error via AdError. With AdError we can observe different error types. For example lets catch a decoding error. when(state.adException.adError) { AdError.DECODING -&gt; { // Act accordingly e.g. repeat the request. } } . Step 2 . You can catch a number of different error types, just check AdError. Let’s just log the error and have a look how our composable should look like. @Composable fun AdView(viewModel: MainViewModel) { val adState = rememberAdState(advertisement = viewModel.ad) Ad(adState = adState, modifier = Modifier) when (val state = adState?.state) { is AdState.State.Error -&gt; { when(state.adException.adError) { AdError.DECODING -&gt; { Log.e(\"MainActivity\", \"Decoding error: ${state.adException.exception}\") } } } is AdState.State.Loading -&gt; { // We are Caching. } is AdState.State.Caching -&gt; { // We are Caching. } is AdState.State.AdReadyToDisplay -&gt; { // Ad is ready and will be displayed. } else -&gt; {} } } . ",
    "url": "/nextgen-adsdk-android-release/4.6.0/handling-the-state-and-events-of-advertising.html#section-2-handling-errors-during-the-loading-and-decoding",
    
    "relUrl": "/4.6.0/handling-the-state-and-events-of-advertising.html#section-2-handling-errors-during-the-loading-and-decoding"
  },"168": {
    "doc": "Handling the state and events of advertising",
    "title": "Section 3: Observing the advertising events",
    "content": "Observe the advertising events to respond to them in the application. The SDK can send many events related to advertisements, like impressions, visibility percentages and tap events. Step 1 . With the use of the AdService we can collect all ad Event. AdService.getInstance().eventHandler?.events?.collect { event -&gt; Log.d(\"Events\", \"Collected EVENT - $event\") } . Step 2 . Start the event observing before the composable loads if you want to make sure you get every event. For example, we could add it in the App class. class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) override fun onCreate() { super.onCreate() coroutineScope.launch { val isSuccess = AdService.init(\"1800\", applicationContext, EventHandler()) Log.d(\"App\", \"Init is success: $isSuccess\") launch { AdService.getInstance().eventHandler?.events?.collect { event -&gt; Log.d(\"Events\", \"Collected EVENT - $event\") when (event.eventType) { is EventType.Tap -&gt; { // Ad got tapped. } else -&gt; {} } } } } } } . Step 3 . You can observe the specific EventTypes you are interested in. For example, you can react to the tap on ads: . when(event.eventType) { is EventType.Tap -&gt; { // Ad got tapped. } else -&gt; {} } . Step 4 . Let’s add this to the App class as well. class App : Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) override fun onCreate() { super.onCreate() coroutineScope.launch { val isSuccess = AdService.init(\"1800\", applicationContext, EventHandler()) Log.d(\"App\", \"Init is success: $isSuccess\") launch { AdService.getInstance().eventHandler?.events?.collect { event -&gt; Log.d(\"Events\", \"Collected EVENT - $event\") when (event.eventType) { is EventType.Tap -&gt; { // Ad got tapped. } else -&gt; {} } } } } } } . Now we could act accordingly to a specific event in any way we wanted. ",
    "url": "/nextgen-adsdk-android-release/4.6.0/handling-the-state-and-events-of-advertising.html#section-3-observing-the-advertising-events",
    
    "relUrl": "/4.6.0/handling-the-state-and-events-of-advertising.html#section-3-observing-the-advertising-events"
  },"169": {
    "doc": "Handling the state and events of advertising",
    "title": "Handling the state and events of advertising",
    "content": " ",
    "url": "/nextgen-adsdk-android-release/4.6.0/handling-the-state-and-events-of-advertising.html",
    
    "relUrl": "/4.6.0/handling-the-state-and-events-of-advertising.html"
  },"170": {
    "doc": "Meet nextgen AdSDK",
    "title": "Meet nextgen AdSDK",
    "content": "Manage, display, and create your custom advertisements on Android using cutting-edge technologies such as Compose and Coroutines based on the AdSDK. ",
    "url": "/nextgen-adsdk-android-release/4.6.0/meet-adsdk.html",
    
    "relUrl": "/4.6.0/meet-adsdk.html"
  },"171": {
    "doc": "Meet nextgen AdSDK",
    "title": "Chapter 1",
    "content": "Working with the built-in capabilities of the SDK In this chapter, you will learn how to create, display, and manage advertisements using AdSDK. | Create and display inline ads | Handling the state and events of advertising | Defining the size of the advertisement | Create and display interstitial ad | Global ad request parameters | . ",
    "url": "/nextgen-adsdk-android-release/4.6.0/meet-adsdk.html#chapter-1",
    
    "relUrl": "/4.6.0/meet-adsdk.html#chapter-1"
  }
}
