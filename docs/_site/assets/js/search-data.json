{"0": {
    "doc": "AdSDK Cache Management",
    "title": "AdSDK Cache Management",
    "content": "The SDK supports a persistent cache with resources related to ad, these can be banners or other resources, depending on the type of ad. In this tutorial, we’ll look at how an application developer can control the cache. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/cache-management.html",
    
    "relUrl": "/5.3.0/cache-management.html"
  },"1": {
    "doc": "AdSDK Cache Management",
    "title": "Section 1: Limiting the cache size",
    "content": "In this section, we will learn how to limit the size of the cache. Step 1 . When we creating an AdService, we can specify the size of our cache in MB. Let’s change it to 20 MB. The cache size parameter is optional. If you do not specify it, the default cache size is 100 MB. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure( \"1800\", applicationContext, cacheSizeInMb = 20u ) initResult.get( onSuccess = { addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } // ... } . Step 2 . In addition, the SDK allows you to change the size of the cache over time. You can use AdService.setCacheSize method for this purpose. If the specified cache size is smaller than the size of already cached resources, the cache will delete resources to fit the new specified limit. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure( \"1800\", applicationContext, cacheSizeInMb = 20u ) initResult.get( onSuccess = { // coroutineScope.launch { AdService.setCacheSize(20u) } addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } // ... } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/cache-management.html#section-1-limiting-the-cache-size",
    
    "relUrl": "/5.3.0/cache-management.html#section-1-limiting-the-cache-size"
  },"2": {
    "doc": "AdSDK Cache Management",
    "title": "Section 2: Flushing the cache",
    "content": "Although the cache size reached to it limit, SDK will removes resources in FIFO order, sometimes you need to clear the cache completely. In this section, we will learn how we can do this. Step 1 . For example, let’s clear the cache in the case of an AdError.CacheWriteAction. To do this, let’s go back to the InlineAd file and add this code in the case of a AdService.makeAdvertisement method failure. File: InlineAd.kt . // ... class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { val tagUser = async { tagUser() } val conversionTracking = async { conversionTracking() } tagUser.await() conversionTracking.await() AdService.makeAdvertisement( adRequest, adEventListener = adEventListener ).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") when(it) { is AdError.CacheWriteAction -&gt; { } else -&gt; {} } advertisementState.value = ResultState.Error(it) } ) } } //... } . Step 2 . We create an method flushCache and use AdService.flushCache. File: InlineAd.kt . // ... class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { val tagUser = async { tagUser() } val conversionTracking = async { conversionTracking() } tagUser.await() conversionTracking.await() AdService.makeAdvertisement( adRequest, adEventListener = adEventListener ).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") when(it) { is AdError.CacheWriteAction -&gt; { flushCache() } else -&gt; {} } advertisementState.value = ResultState.Error(it) } ) } } fun flushCache() { viewModelScope.launch { AdService.flushCache().get( onSuccess = { Log.d(\"InlineAdViewModel\", \"FlushCache was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed flushCache: ${it.description}\") } ) } } // ... } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/cache-management.html#section-2-flushing-the-cache",
    
    "relUrl": "/5.3.0/cache-management.html#section-2-flushing-the-cache"
  },"3": {
    "doc": "AdSDK Cache Management",
    "title": "Section 3: Specify the cache path",
    "content": "In this section, we will see how to set the path of the cache. Step 1 . Like the size we can also set the custom path of the cache when we configure the AdService. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure( \"1800\", applicationContext, cacheSizeInMb = 20u, cachePath = cacheDir.path + \"/tutorialApp/\" ) initResult.get( onSuccess = { // coroutineScope.launch { AdService.setCacheSize(20u) } addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } // ... } . Step 2 . Similar to the size, the SDK allows you to change the path of the cache over time. You can use AdService.setCachePath method for this purpose. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure( \"1800\", applicationContext, cacheSizeInMb = 20u, cachePath = cacheDir.path + \"/tutorialApp/\" ) initResult.get( onSuccess = { // coroutineScope.launch { AdService.setCacheSize(20u) } // coroutineScope.launch { // AdService.setCachePath(cacheDir.path + \"/tutorialApp/\") // } addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } // ... } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/cache-management.html#section-3-specify-the-cache-path",
    
    "relUrl": "/5.3.0/cache-management.html#section-3-specify-the-cache-path"
  },"4": {
    "doc": "How to use AdSDK with XML views",
    "title": "How to use AdSDK with XML views",
    "content": "You can follow the tutorial documentation almost entirely. We will highlight the few differences in this guide. We’ll also provide some examples of how to integrate the functionality. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/compose_with_xml_guide.html",
    
    "relUrl": "/5.3.0/compose_with_xml_guide.html"
  },"5": {
    "doc": "How to use AdSDK with XML views",
    "title": "AdSDK configuration",
    "content": "For setting up AdService, creating AdRequest and Advertisement, you can follow the previous tutorial exactly, as it does not include any Compose-specific code. The first thing to be careful about when following the tutorial is how the advertisement state is shared in the view model. In the tutorial, we use mutableStateOf, which is a feature from Jetpack Compose. An alternative could be MutableLiveData. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/compose_with_xml_guide.html#adsdk-configuration",
    
    "relUrl": "/5.3.0/compose_with_xml_guide.html#adsdk-configuration"
  },"6": {
    "doc": "How to use AdSDK with XML views",
    "title": "Use AdSDK composable with views",
    "content": "The major difference when using XML instead of Compose comes when you try to use the Ad or the Interstitial composable, since they are built with Compose. To integrate them into an XML-based layout, you’ll need to use Android’s setContent(). There are several ways to do this. You can use the XML layout. &lt;androidx.compose.ui.platform.ComposeView android:id=\"@+id/composeView1\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; . is ResultState.Success -&gt; { findViewById&lt;ComposeView&gt;(R.id.composeView1).setContent { Ad(it.data) } } . You can also create the layout in the code directly. ComposeView(context).apply { layoutParams = AdsListView.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT ) setContent { Interstitial(viewModel.interstitialState) } } . For more information, you can refer to the Compose documentation. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/compose_with_xml_guide.html#use-adsdk-composable-with-views",
    
    "relUrl": "/5.3.0/compose_with_xml_guide.html#use-adsdk-composable-with-views"
  },"7": {
    "doc": "Create and display inline ads",
    "title": "Create and display inline ads",
    "content": "This tutorial will guide you how to create and display inline ads. An inline ad is an ad created to be displayed in your view hierarchy. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/create-and-display-inline-ads.html",
    
    "relUrl": "/5.3.0/create-and-display-inline-ads.html"
  },"8": {
    "doc": "Create and display inline ads",
    "title": "Creating an inline ads",
    "content": "Your AdService is ready for creating advertisements, so in this section, we will create an InlineAd composable for future ad display. Step 1 . Lets create an InlineAd composable and an InlineAdViewModel class. File: InlineAd.kt . @Composable fun InlineAd() { Text( text = \"Advertisement should be here\" ) } class InlineAdViewModel : ViewModel() { } . Step 2 . To create advertisements, we use the AdService.makeAdvertisement method. The most important parameter now is AdRequest, which describes the request that will be sent to the server to receive ads. The only mandatory parameter when creating the AdRequest is AdRequest.contentUnit or AdRequest.learningTag. Content unit is unique ID of a content space. You can also use AdRequest.learningTag, but we use AdRequest.contentUnit in this tutorial because it is more commonly used. File: InlineAd.kt . @Composable fun InlineAd() { Text( text = \"Advertisement should be here\" ) } class InlineAdViewModel : ViewModel() { private val adRequest = AdRequest(\"4810915\") } . Step 3 . The AdService.makeAdvertisement method returns AdResult. It is also suspendable we will use it in the viewModelScope. If the ad is created and loaded successfully, you will receive the downloaded Advertisement object. You can think of it as a ViewModel that holds the data and state of your ad. We’ll again use ResultState with Advertisement to identify whether the ad was created and loaded successfully. File: InlineAd.kt . @Composable fun InlineAd() { Text( text = \"Advertisement should be here\" ) } class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) init { viewModelScope.launch { AdService.makeAdvertisement(adRequest).get( onSuccess = { advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 4 . If we have an Advertisement instance, it remains to add a Composable. The sdk_presentation_compose has Ad, which is the presentation layer of your inline ad. File: InlineAd.kt . @Composable fun InlineAd() { val viewModel: InlineAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Ad(it.data) } } } } class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) init { viewModelScope.launch { AdService.makeAdvertisement(adRequest).get( onSuccess = { advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 5 . The last thing we need to do is add our Composable to the MainActivity. File: MainActivity.kt . class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val app = application as App app.adServiceStatus.observe(this) { result -&gt; when(result) { is ResultState.Error -&gt; { showAppError(result.exception) } is ResultState.Success -&gt; { setContent { TutorialAppTheme { InlineAd() } } } } } } private fun showAppError(adError: AdError) { Toast.makeText(this, \"Initialization failed: ${adError.description}\", Toast.LENGTH_LONG).show() } } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/create-and-display-inline-ads.html#creating-an-inline-ads",
    
    "relUrl": "/5.3.0/create-and-display-inline-ads.html#creating-an-inline-ads"
  },"9": {
    "doc": "Create and display inline ads",
    "title": "Section 2: Defining the size of the advertisement",
    "content": "Our InlineAdViewModel and InlineAd can load and display ads, but how can we understand what size the Ad should be? In this section we will deal with this question. Step 1 . As we already know, Advertisement stores advertising data. Let’s try to get it! We can obtain all possible advertising data using AdMetadata. This is the one we will use to obtain the size data. We are interested in AdMetadata.aspectRatio, which is optional. We have implemented the logic so that in cases where it is not present, we will use the 2:1 ratio. File: InlineAd.kt . @Composable fun InlineAd() { val viewModel: InlineAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { it.data.adMetadata Ad(it.data) } } } } class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f init { viewModelScope.launch { AdService.makeAdvertisement(adRequest).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 2 . Now we can add the AdMetadata.aspectRatio via the Modifier into the Ad. File: InlineAd.kt . @Composable fun InlineAd() { val viewModel: InlineAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { it.data.adMetadata Ad( it.data, modifier = Modifier.aspectRatio(viewModel.aspectRatio) ) } } } } class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f init { viewModelScope.launch { AdService.makeAdvertisement(adRequest).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Now we should see the banner on our device. Congrats! . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/create-and-display-inline-ads.html#section-2-defining-the-size-of-the-advertisement",
    
    "relUrl": "/5.3.0/create-and-display-inline-ads.html#section-2-defining-the-size-of-the-advertisement"
  },"10": {
    "doc": "Create and display interstitial ad",
    "title": "Create and display interstitial ad",
    "content": "A full-screen advertisement that fills the host app’s interface is known as an interstitial ad. In this tutorial we will add an interstitial ad to our application. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/create-and-display-interstitial-ad.html",
    
    "relUrl": "/5.3.0/create-and-display-interstitial-ad.html"
  },"11": {
    "doc": "Create and display interstitial ad",
    "title": "Section 1: Prepare app for interstitial ad",
    "content": "We want to present the interstitial on a different screen and add navigation buttons for it. Step 1 . Let’s create a new MainScreen file in which we add Navigation and MainScreen. Note: At the moment you will get an error, because we have not created InterstitialScreen yet. File: MainScreen.kt . @Composable fun Navigation() { val navController = rememberNavController() NavHost(navController = navController, startDestination = \"mainScreen\") { composable(\"mainScreen\") { MainScreen(navController) } composable(\"interstitial\") { InterstitialScreen() } } } @Composable fun MainScreen(navController: NavController) { Scaffold( floatingActionButton = { ExtendedFloatingActionButton( onClick = { navController.navigate(\"interstitial\") }, content = { Text(\"Go to Interstitial\") }, ) } ) { innerPadding -&gt; Column( modifier = Modifier .fillMaxSize() .padding(innerPadding), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { InlineAd() Spacer(modifier = Modifier.height(16.dp)) } } } . Step 2 . The next step is to create our future screen for displaying interstitial ads. Create a new InterstitialScreen file and add a screen with a button to it. File: InterstitialScreen.kt . @Composable fun InterstitialScreen() { Box( modifier = Modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { Button( onClick = { }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } } } class InterstitialAdViewModel : ViewModel() { } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/create-and-display-interstitial-ad.html#section-1-prepare-app-for-interstitial-ad",
    
    "relUrl": "/5.3.0/create-and-display-interstitial-ad.html#section-1-prepare-app-for-interstitial-ad"
  },"12": {
    "doc": "Create and display interstitial ad",
    "title": "Section 2: Creating interstitial advertisements",
    "content": "We have already created an inline Advertisement on a previous chapter. In this section, we will create a interstitial ad for the future presentation. Step 1 . Interstitial ad is created in the same way as inline ads, with one difference – the placementType parameter must be AdPlacementType.INTERSTITIAL. Let’s add the logic for loading the advertisement into InterstitialAdViewModel. We’ll again use ResultState with Advertisement to identify whether the ad was created and loaded successfully. File: InterstitialScreen.kt . @Composable fun InterstitialScreen() { Box( modifier = Modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { Button( onClick = { }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = AdPlacementType.INTERSTITIAL, ).get( onSuccess = { advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 2 . We add the InterstitialAdViewModel to the InterstitialAd. File: InterstitialScreen.kt . @Composable fun InterstitialScreen() { val viewModel: InterstitialAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = AdPlacementType.INTERSTITIAL, ).get( onSuccess = { advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/create-and-display-interstitial-ad.html#section-2-creating-interstitial-advertisements",
    
    "relUrl": "/5.3.0/create-and-display-interstitial-ad.html#section-2-creating-interstitial-advertisements"
  },"13": {
    "doc": "Create and display interstitial ad",
    "title": "Section 3: Presenting interstitial ad",
    "content": "We learnt how to create interstitial advertisement. Now, we are ready to present our interstitial ad. In this section, we will display interstitial ad in our app. Step 1 . Our AdSDK provides AdInterstitialState to control the state of the interstitial ad presentation. Add a property for this in the InterstitialAdViewModel. File: InterstitialScreen.kt . fun InterstitialScreen() { val viewModel: InterstitialAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisement = mutableStateOf&lt;Advertisement?&gt;(null) lateinit var interstitialState: AdInterstitialState init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = PlacementType.INTERSTITIAL, adEventListener = adEventListener ).get( onSuccess = { interstitialState = AdInterstitialState(it, this) advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"AdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 2 . The next step will be adding a presentation layer. To display interstitial ads, SDK has an Interstitial composable. Add it to your InterstitialScreen and pass the state value from the InterstitialAdViewModel. File: InterstitialScreen.kt . @Composable fun InterstitialScreen(modifier: Modifier) { val viewModel: InterstitialAdViewModel = viewModel() Box( modifier = modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } Interstitial(viewModel.interstitialState) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisement = mutableStateOf&lt;Advertisement?&gt;(null) lateinit var interstitialState: AdInterstitialState init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = PlacementType.INTERSTITIAL ).get( onSuccess = { interstitialState = AdInterstitialState(it, this) advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 3 . To show an interstitial ad, you can use the AdInterstitialState.presentIfLoaded method. Note: If you don’t use the Advertisement.reload method, your Advertisement object will always be loaded, which means that the ad will be presented to the user immediately when AdInterstitialState.presentIfLoaded method called. Otherwise, the ad will be presented immediately after loading. File: InterstitialScreen.kt . fun InterstitialScreen() { val viewModel: InterstitialAdViewModel = viewModel() Box( modifier = modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { viewModel.interstitialState.presentIfLoaded() }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } Interstitial(viewModel.interstitialState) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisement = mutableStateOf&lt;Advertisement?&gt;(null) lateinit var interstitialState: AdInterstitialState init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = PlacementType.INTERSTITIAL ).get( onSuccess = { interstitialState = AdInterstitialState(it, this) advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/create-and-display-interstitial-ad.html#section-3-presenting-interstitial-ad",
    
    "relUrl": "/5.3.0/create-and-display-interstitial-ad.html#section-3-presenting-interstitial-ad"
  },"14": {
    "doc": "Create and display interstitial ad",
    "title": "Section 3: Hiding interstitial ad",
    "content": "We managed to successfully show the ad, but we would like to be able to close interstitial. In this section, we implement this logic. Step 1 . Let’s continue the development in our InterstitialScreen file. We could hide the ad by simply calling the AdInterstitialState.hide method, but we don’t know when to call it. In order to understand when ad should be hidden, we need to use AdEventListener. We will explain the AdEventListener in more detail in the next chapter. Let’s create an adEventListener in InterstitialAdViewModel, and then pass it to the AdService.makeAdvertisement. File: InterstitialScreen.kt . fun InterstitialScreen() { val viewModel: InterstitialAdViewModel = viewModel() Box( modifier = modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { viewModel.interstitialState.presentIfLoaded() }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } Interstitial(viewModel.interstitialState) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) lateinit var interstitialState: AdInterstitialState val adEventListener: AdEventListener = object : AdEventListener { override fun eventProcessed(adEventType: AdEventType, adMetadata: AdMetadata) { Log.d(\"InterstitialAdViewModel events\", \"Collected EVENT - $adEventType\") } } init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = AdPlacementType.INTERSTITIAL, adEventListener = adEventListener ).get( onSuccess = { interstitialState = AdInterstitialState(it, this) advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 2 . The event we are interested in is AdEventType.UnloadRequest. We need to observe it to make sure that the ad is hidden when it is needed. Note: You should not change the state from presented to hidden without using AdEventType.UnloadRequest event. The advert itself knows when it needs to be hidden and asks you to hide it using this method. File: InterstitialScreen.kt . fun InterstitialScreen() { val viewModel: InterstitialAdViewModel = viewModel() Box( modifier = modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { viewModel.interstitialState.presentIfLoaded() }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } Interstitial(viewModel.interstitialState) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) lateinit var interstitialState: AdInterstitialState val adEventListener: AdEventListener = object : AdEventListener { override fun eventProcessed(adEventType: AdEventType, adMetadata: AdMetadata) { Log.d(\"InterstitialAdViewModel events\", \"Collected EVENT - $adEventType\") if (adEventType == AdEventType.UnloadRequest) { interstitialState.hide() } } } init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = AdPlacementType.INTERSTITIAL, adEventListener= adEventListener ).get( onSuccess = { interstitialState = AdInterstitialState(it, this) advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Now, if you launch the app, you should see an interstitial ad. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/create-and-display-interstitial-ad.html#section-3-hiding-interstitial-ad",
    
    "relUrl": "/5.3.0/create-and-display-interstitial-ad.html#section-3-hiding-interstitial-ad"
  },"15": {
    "doc": "Creating customised advertising",
    "title": "Creating customised advertising",
    "content": "In this tutorial, we will learn how to create custom ads using AdSDK. This process is the same for both inline and interstitial ads. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. Note: In this tutorial, we want to display a picture and frame it, but in real-world projects, your ad can be anything - video, HTML, graphics, etc. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/creating-customised-advertising.html",
    
    "relUrl": "/5.3.0/creating-customised-advertising.html"
  },"16": {
    "doc": "Creating customised advertising",
    "title": "Section 1: Creating a custom renderer",
    "content": "We will create an custom composable ad. Let’s start by using the AdComposeRenderer. Step 1 . Create a new file TutorialRenderer and TutorialRenderer class on it. Step 2 . TutorialRenderer need to implement AdComposeRenderer, override AdComposeRenderer.configure, and AdComposeRenderer.RenderAd. We’ll take a closer look at each of these methods in separate sections. File: TutorialRenderer.kt . internal class TutorialRenderer : AdComposeRenderer { override suspend fun configure( rendererEventHandler: AdRendererEventHandler, adMetadata: AdMetadata, adResponseBundle: AdResponseBundle ): AdResult&lt;Unit&gt; {} @Composable override fun RenderAd(modifier: Modifier) {} } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/creating-customised-advertising.html#section-1-creating-a-custom-renderer",
    
    "relUrl": "/5.3.0/creating-customised-advertising.html#section-1-creating-a-custom-renderer"
  },"17": {
    "doc": "Creating customised advertising",
    "title": "Section 2: Get the data",
    "content": "In this section, we will learn how the renderer can receive data from the ad server using the AdComposeRenderer.configure method. Step 1 . The server should always be configured to return a custom response when using custom advertising. In this tutorial, the server is configured to give us the following response. { // ... \"ad_name\": \"tutorialad\", \"body\": { // ... \"ext\": { // ... \"adData\": { \"banner_image\": \"Banner URL\", \"framing_width\": \"Framing width\", \"is_black_framing\": \"Boolean value – whether the color should be black or white.\" } } } } . Step 2 . We will use kotlinx.serialization.json.JsonObject to parse the JSON. We have to import it in our build gradle file. File: build.gradle.kts . implementation(\"org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.3\") . Step 3 . The AdComposeRenderer.configure method is the key to creating ads. Within it, you have to perform all the logic to prepare the ad for display - decoding, additional downloads, etc. Note: This method is directly related to the [AdService.makeAdvertisement] and [Advertisement.reload] methods. As soon as this method is completed, the Advertisement will be returned to the app. The AdResponseBundle parameter contains the entire response from the server we need. It contains the data as AdResponse and JSON as a string. We will keep it easy and just use a method to get the 3 values from the AdResponse. You could do this with your own decoding logic or anything similar and use JSON string. File: TutorialRenderer.kt . internal class TutorialRenderer : AdComposeRenderer { private var framingWidth: Int = 1 private var isBlackFraming: Boolean = false override suspend fun configure( rendererEventHandler: AdRendererEventHandler, adMetadata: AdMetadata, adResponseBundle: AdResponseBundle ): AdResult&lt;Unit&gt; { val adDataMap = adResponseBundle.adResponse.body?.ext?.adData as? Map&lt;*, *&gt; ?: return AdResult.Error(AdError.Decoding(Exception(\"adData is missing.\"))) val jsonString = JSONObject(adDataMap).toString() val adData = Json.parseToJsonElement(jsonString).jsonObject val bannerURL = adData[\"banner_image\"]?.jsonPrimitive?.content ?: return AdResult.Error(AdError.Decoding(Exception(\"Banner URL is null.\"))) framingWidth = adData[\"framing_width\"]?.jsonPrimitive?.intOrNull ?: framingWidth isBlackFraming = adData[\"is_black_framing\"]?.jsonPrimitive?.booleanOrNull ?: isBlackFraming } @Composable override fun RenderAd(modifier: Modifier) {} } . Step 4 . We will use the banner URL to get the image from the cache or download it from the server. We get a cache instance with AdService.getCacheInstance and can use DriveCache.find to get the image from cache. If not, we will use AdRendererEventHandler.downloadBitmap to download the image. We will take a closer look at [AdRendererEventHandler] in the next sections. File: TutorialRenderer.kt . internal class TutorialRenderer : AdComposeRenderer { private lateinit var eventHandler: AdRendererEventHandler private var framingWidth: Int = 1 private var isBlackFraming: Boolean = false override suspend fun configure( rendererEventHandler: AdRendererEventHandler, adMetadata: AdMetadata, adResponseBundle: AdResponseBundle ): AdResult&lt;Unit&gt; { this.eventHandler = rendererEventHandler val adDataMap = adResponseBundle.adResponse.body?.ext?.adData as? Map&lt;*, *&gt; ?: return AdResult.Error(AdError.Decoding(Exception(\"adData is missing.\"))) val jsonString = JSONObject(adDataMap).toString() val adData = Json.parseToJsonElement(jsonString).jsonObject val bannerURL = adData[\"banner_image\"]?.jsonPrimitive?.content ?: return AdResult.Error(AdError.Decoding(Exception(\"Banner URL is null.\"))) framingWidth = adData[\"framing_width\"]?.jsonPrimitive?.intOrNull ?: framingWidth isBlackFraming = adData[\"is_black_framing\"]?.jsonPrimitive?.booleanOrNull ?: isBlackFraming val bannerResult = getBanner(bannerURL) return when (bannerResult) { is AdResult.Success -&gt; { imageBitmap = bannerResult.result AdResult.Success(Unit) } is AdResult.Error -&gt; AdResult.Error(bannerResult.error) } } private suspend fun getBanner(url: String): AdResult&lt;ImageBitmap&gt; { val cachedBanner = getCachedBanner(url) if (cachedBanner != null) { return AdResult.Success(cachedBanner) } return loadAndCacheBanner(url) } private suspend fun getCachedBanner(url: String): ImageBitmap? { val cache = AdService.getCacheInstance().getOrNull() val banner = cache?.find(url)?.getOrNull() if (banner != null) { return BitmapFactory.decodeByteArray( banner.data, 0, banner.data.size )?.asImageBitmap() } return null } private suspend fun loadAndCacheBanner(url: String): AdResult&lt;ImageBitmap&gt; { val bitmapResult = eventHandler.downloadBitmap(url) return when (bitmapResult) { is AdResult.Error -&gt; AdResult.Error(bitmapResult.error) is AdResult.Success -&gt; { AdResult.Success(bitmapResult.result.asImageBitmap()) } } } @Composable override fun RenderAd(modifier: Modifier) {} } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/creating-customised-advertising.html#section-2-get-the-data",
    
    "relUrl": "/5.3.0/creating-customised-advertising.html#section-2-get-the-data"
  },"18": {
    "doc": "Creating customised advertising",
    "title": "Section 3: Create the renderer UI",
    "content": "Now our data is ready. Lets create the renderer UI. To do this, we will use the AdComposeRenderer.RenderAd composable method. Step 1 . We will only show a framed image when the imageBitmap is loaded. File: TutorialRenderer.kt . internal class TutorialRenderer : AdComposeRenderer { private lateinit var eventHandler: AdRendererEventHandler private var imageBitmap by mutableStateOf&lt;ImageBitmap?&gt;(null) private var framingWidth: Int = 1 private var isBlackFraming: Boolean = false // ... @Composable override fun RenderAd(modifier: Modifier) { val imageBitmap = rememberUpdatedState(this.imageBitmap) imageBitmap.value?.let { // Framed image goes here. } } } . Step 2 . We create a box for the framing and show the image inside. File: TutorialRenderer.kt . internal class TutorialRenderer : AdComposeRenderer { private lateinit var eventHandler: AdRendererEventHandler private var imageBitmap by mutableStateOf&lt;ImageBitmap?&gt;(null) private var framingWidth: Int = 1 private var isBlackFraming: Boolean = false // ... @Composable override fun RenderAd(modifier: Modifier) { val imageBitmap = rememberUpdatedState(this.imageBitmap) imageBitmap.value?.let { val borderColor = if (isBlackFraming) Color.Black else Color.White Box( modifier = Modifier .fillMaxWidth() .aspectRatio(it.width.toFloat() / it.height) .border( width = framingWidth.dp, color = borderColor ) ) { Image( bitmap = it, contentDescription = null ) } } } } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/creating-customised-advertising.html#section-3-create-the-renderer-ui",
    
    "relUrl": "/5.3.0/creating-customised-advertising.html#section-3-create-the-renderer-ui"
  },"19": {
    "doc": "Creating customised advertising",
    "title": "Section 4: Event management",
    "content": "The next step will be to implement the processing of ad-related events. We can do this using the [AdRendererEventHandler]. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/creating-customised-advertising.html#section-4-event-management",
    
    "relUrl": "/5.3.0/creating-customised-advertising.html#section-4-event-management"
  },"20": {
    "doc": "Creating customised advertising",
    "title": "Step 1",
    "content": "We already used AdRendererEventHandler.downloadBitmap. Here are all event method we can use: . | AdRendererEventHandler.downloadBitmap | AdRendererEventHandler.performCustomTrackingEvent | AdRendererEventHandler.performTapEvent | AdRendererEventHandler.sendMessage | AdRendererEventHandler.unloadRequest | . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/creating-customised-advertising.html#step-1-3",
    
    "relUrl": "/5.3.0/creating-customised-advertising.html#step-1-3"
  },"21": {
    "doc": "Creating customised advertising",
    "title": "Step 2",
    "content": "We will use AdRendererEventHandler.performTapEvent to trigger the tap event. Note: You can see all possible types of tap events and the difference between them in the AdTapEvent documentation. File: TutorialRenderer.kt . internal class TutorialRenderer : AdComposeRenderer { private lateinit var eventHandler: AdRendererEventHandler // ... @Composable override fun RenderAd(modifier: Modifier) { val imageBitmap = rememberUpdatedState(this.imageBitmap) imageBitmap.value?.let { val borderColor = if (isBlackFraming) Color.Black else Color.White Box( modifier = Modifier .fillMaxWidth() .aspectRatio(it.width.toFloat() / it.height) .border( width = framingWidth.dp, color = borderColor ) ) { Image( bitmap = it, contentDescription = null, modifier.clickable { eventHandler.performTapEvent(AdTapEvent.Tap) } ) } } } } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/creating-customised-advertising.html#step-2-3",
    
    "relUrl": "/5.3.0/creating-customised-advertising.html#step-2-3"
  },"22": {
    "doc": "Creating customised advertising",
    "title": "Section 5: Prepare to present the custom ad",
    "content": "Let’s create a screen to present our custom ad. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/creating-customised-advertising.html#section-5-prepare-to-present-the-custom-ad",
    
    "relUrl": "/5.3.0/creating-customised-advertising.html#section-5-prepare-to-present-the-custom-ad"
  },"23": {
    "doc": "Creating customised advertising",
    "title": "Step 1",
    "content": "Create a new file CustomAd. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/creating-customised-advertising.html#step-1-4",
    
    "relUrl": "/5.3.0/creating-customised-advertising.html#step-1-4"
  },"24": {
    "doc": "Creating customised advertising",
    "title": "Step 2",
    "content": "Add a CustomAd composable and a CustomAdViewModel. File: CustomAd.kt . @Composable fun CustomAd() { val viewModel: CustomAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { it.data.adMetadata Ad(it.data) } } } } class CustomAdViewModel: ViewModel() { private val adRequest = AdRequest(\"5227780\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, ).get( onSuccess = { advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"CustomAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/creating-customised-advertising.html#step-2-4",
    
    "relUrl": "/5.3.0/creating-customised-advertising.html#step-2-4"
  },"25": {
    "doc": "Creating customised advertising",
    "title": "Step 3",
    "content": "Add the CustomAd into the MainScreen. File: MainScreen.kt . @Composable fun Navigation() { val navController = rememberNavController() NavHost(navController = navController, startDestination = \"mainScreen\") { composable(\"mainScreen\") { MainScreen(navController) } composable(\"interstitial\") { InterstitialScreen() } } } @Composable fun MainScreen(navController: NavController) { Scaffold( floatingActionButton = { ExtendedFloatingActionButton( onClick = { navController.navigate(\"interstitial\") }, content = { Text(\"Go to Interstitial\") }, ) } ) { innerPadding -&gt; Column( modifier = Modifier .fillMaxSize() .padding(innerPadding), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { InlineAd() CustomAd() } } } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/creating-customised-advertising.html#step-3-1",
    
    "relUrl": "/5.3.0/creating-customised-advertising.html#step-3-1"
  },"26": {
    "doc": "Creating customised advertising",
    "title": "Section 6: Registering a renderer in the SDK",
    "content": "Although we have created a custom ad, in order for the SDK to use it, we need to pass it to the SDK somehow. Let’s do that. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/creating-customised-advertising.html#section-6-registering-a-renderer-in-the-sdk",
    
    "relUrl": "/5.3.0/creating-customised-advertising.html#section-6-registering-a-renderer-in-the-sdk"
  },"27": {
    "doc": "Creating customised advertising",
    "title": "Step 1",
    "content": "First of all, let’s get back to our response from the server. As you can see, it includes the ad_name field. It is this field that the SDK will use to identify your renderer. { // ... \"ad_name\": \"tutorialad\", // &lt;------- \"body\": { // ... \"ext\": { // ... \"adData\": { \"banner_image\": \"Banner URL\", \"framing_width\": \"Framing width\", \"is_black_framing\": \"Boolean value – whether the color should be black or white.\" } } } } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/creating-customised-advertising.html#step-1-5",
    
    "relUrl": "/5.3.0/creating-customised-advertising.html#step-1-5"
  },"28": {
    "doc": "Creating customised advertising",
    "title": "Step 2",
    "content": "All we need to do is use the AdService.registerRenderer method, passing in the value we expect to receive in the ad_name field and the renderer factory. This way, every time the ad_name field in the server response is the same as the string you passed to this method, the SDK will display the TutorialRenderer. Step 3 . We call the AdService.registerRenderer method in the App class. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure( \"1800\", applicationContext, cacheSizeInMb = 20u, cachePath = cacheDir.path + \"/tutorialApp/\" ) initResult.get( onSuccess = { launch { AdService.registerRenderer(\"tutorialad\") { TutorialRenderer() } adServiceStatus.postValue(ResultState.Success(Unit)) } }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } } . Now you can launch the app and see your new custom ad, congratulations! . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/creating-customised-advertising.html#step-2-5",
    
    "relUrl": "/5.3.0/creating-customised-advertising.html#step-2-5"
  },"29": {
    "doc": "First steps for working with AdSDK",
    "title": "First steps for working with AdSDK",
    "content": "This tutorial will guide you through the first steps of working with the AdSDK - creating an AdService. You can download this this project which already implements all the steps of this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/first-steps.html",
    
    "relUrl": "/5.3.0/first-steps.html"
  },"30": {
    "doc": "First steps for working with AdSDK",
    "title": "Creating an AdService",
    "content": "Creating and configuring an AdService for later ad creation and loading. Step 1 . Create a new Android project and remove any unnecessary code. Make sure you have added the correct packages from the readme. Step 2 . The entry point into the SDK is the AdService class. This is the first thing we should create, as it will be used to generate advertisements in the future. For an easy start, we will simply configure the AdService in the App class. We create a file called App and add it to the MainActivity as well. File: App.kt . class App : Application() { override fun onCreate() { super.onCreate() } } . File: MainActivity.kt . class MainActivity : ComponentActivity() { override fun onCreate() { super.onCreate() val app = application as App // ... } } // ... Remember to add this class as an entry point, so add it to the application in your Manifest. File: AndroidManifest.xml . android:name=\"com.adition.tutorial_app.App\" . Step 3 . Before using the AdService, we should first configure it. To do this, we will use the AdService.configure method in the App class. The only mandatory parameter when configuring an AdService is AdService.networkId. The network identifier is the identifier of your advertising account. The configure method is suspendable, so we should use the coroutine. To do this, we need to create a coroutineScope and add this code to the onCreate function of the App class. class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) override fun onCreate() { super.onCreate() coroutineScope.launch { AdService.configure(\"1800\", applicationContext) } } } . Step 4 . AdService.configure returns AdResult, which is our custom AdSDK implementation of Kotlin’s Result. AdResult contains AdError the only type of error which the SDK supports. We can use AdResult to check that the AdService has been successfully configured and initialised. Let us add a ResultState class to monitor the status. File: ResultState . sealed class ResultState&lt;out T&gt; { data class Success&lt;out T&gt;(val data: T) : ResultState&lt;T&gt;() data class Error&lt;T&gt;(val exception: AdError) : ResultState&lt;T&gt;() } . We can use this status in the App file. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure(\"1800\", applicationContext) initResult.get( onSuccess = { adServiceStatus.value = ResultState.Success(Unit) }, onError = { adServiceStatus.value = ResultState.Error(it) } ) } } } . Step 5 . We can now use adServiceStatus in the onCreate function of the MainActivity. File: MainActivity.kt . class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val app = application as App app.adServiceStatus.observe(this) { result -&gt; when(result) { is ResultState.Error -&gt; { // We will handle in the next step. } is ResultState.Success -&gt; { setContent { TutorialAppTheme { Greeting(name = \"AdSDK\") } } } } } } } // ... Step 6 . We could react on all the different error cases AdError contains. To keeps it easy we just show the description of the AdError. File: MainActivity.kt . class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val app = application as App app.adServiceStatus.observe(this) { result -&gt; when(result) { is ResultState.Error -&gt; { showAppError(result.exception) } is ResultState.Success -&gt; { setContent { TutorialAppTheme { Greeting(name = \"AdSDK\") } } } } } } private fun showAppError(adError: AdError) { Toast.makeText(this, \"Initialization failed: ${adError.description}\", Toast.LENGTH_LONG).show() } } // ... Now, if you’ve done everything right, you should see the greeting message when you launch the app. This completes the AdService configuration, congratulations! . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/first-steps.html#creating-an-adservice",
    
    "relUrl": "/5.3.0/first-steps.html#creating-an-adservice"
  },"31": {
    "doc": "Global request parameters",
    "title": "Global request parameters",
    "content": "We already know how to create and perform AdRequest, TagRequest, and TrackingRequest. However, each of them can have additional parameters, which are called global parameters because they are specified globally for all requests. The SDK provides the ability to add global parameters once so that you don’t have to copy them when creating each request. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/global-request-parameters.html",
    
    "relUrl": "/5.3.0/global-request-parameters.html"
  },"32": {
    "doc": "Global request parameters",
    "title": "Modifying global parameters",
    "content": "In this section we’ll configure the AdRequestGlobalParameters and TrackingGlobalParameters for each AdRequest, TagRequest, and TrackingRequest we have in our application. We will also look at the possibility of removing global parameters. Step 1 . We can add global parameters using the AdService. The AdService has a AdService.setAdRequestGlobalParameter method which we will use to set the gdpr parameter for each AdRequest. Add the global parameters to the App class and a function addGlobalParameters(). Note: If we want to remove a ad request global parameter we could use the AdService.removeAdRequestGlobalParameter method. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure(\"1800\", applicationContext) initResult.get( onSuccess = { addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } private fun addGlobalParameters() { val gdpr = GDPR(consent = \"gdprconsentexample\", isRulesEnabled = true) AdService.setAdRequestGlobalParameter(AdRequestGlobalParameters::gdpr, gdpr) // AdService.removeAdRequestGlobalParameter(AdRequestGlobalParameters::gdpr) } } . Step 2 . We can also modify TrackingGlobalParameters for each TagRequest and TrackingRequest using the AdService.setTrackingGlobalParameter method. Let’s add this code to the addGlobalParameters method. Note: If we want to remove a tracking global parameter we could use the AdService.removeTrackingGlobalParameter method. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure(\"1800\", applicationContext) initResult.get( onSuccess = { addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } private fun addGlobalParameters() { val gdpr = GDPR(consent = \"gdprconsentexample\", isRulesEnabled = true) AdService.setAdRequestGlobalParameter(AdRequestGlobalParameters::gdpr, gdpr) // AdService.removeAdRequestGlobalParameter(AdRequestGlobalParameters::gdpr) AdService.setTrackingGlobalParameter(TrackingGlobalParameters::gdpr, gdpr) // AdService.removeTrackingGlobalParameter(TrackingGlobalParameters::gdpr) } } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/global-request-parameters.html#modifying-global-parameters",
    
    "relUrl": "/5.3.0/global-request-parameters.html#modifying-global-parameters"
  },"33": {
    "doc": "Handling the ad events",
    "title": "Monitor and process ad-related events",
    "content": "Advertisement do a lot of work under the hood and can send messages about them to the app. In turn, you can monitor and react to it in some way. In this tutorial, we’ll look at what events are handled by Advertisement and how we can interact with them. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/handling-the-ad-events.html#monitor-and-process-ad-related-events",
    
    "relUrl": "/5.3.0/handling-the-ad-events.html#monitor-and-process-ad-related-events"
  },"34": {
    "doc": "Handling the ad events",
    "title": "Section 1: Observing events",
    "content": "We will use the AdEventListener to observe the AdEventType. Since we used the AdEventListener in the interstitial tutorial, this time we will add it to the other InlineAdViewModel to observe all the AdEventType. Step 1 . Lets add an AdEventListener to the InlineAdViewModel and pass it to the AdService.makeAdvertisement. File: InlineAd.kt . // ... class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f val adEventListener: AdEventListener = object : AdEventListener { override fun eventProcessed(adEventType: AdEventType, adMetadata: AdMetadata) { Log.d(\"InlineAdViewModel events\", \"Collected EVENT - $adEventType\") } } init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, adEventListener = adEventListener ).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 2 . Here we can see the different AdEventType we can observe: . | Impression | Viewable | Tap | UnloadRequest | RendererMessageReceived | CustomTrackingEvent | . Now let us add all possible AdEventType to the AdEventListener.eventProcessed method of the adEventListener. File: InlineAd.kt . // ... class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f val adEventListener: AdEventListener = object : AdEventListener { override fun eventProcessed(adEventType: AdEventType, adMetadata: AdMetadata) { Log.d(\"InlineAdViewModel events\", \"Collected EVENT - $adEventType\") when (adEventType) { is AdEventType.Impression -&gt; {} is AdEventType.RendererMessageReceived -&gt; {} is AdEventType.CustomTrackingEvent -&gt; {} is AdEventType.Tap -&gt; {} is AdEventType.UnloadRequest -&gt; {} is AdEventType.Viewable -&gt; {} } } } init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, adEventListener = adEventListener ).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 3 . We have already seen UnloadRequest in the interstitial example. Lets look at the Viewable event and monitor each VisibilityPercentage in this example. Note: Impression and Viewable can only be observed if they are configured in the ad server backend. Otherwise they are not part of the ad response. File: InlineAd.kt . // ... class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f val adEventListener: AdEventListener = object : AdEventListener { override fun eventProcessed(adEventType: AdEventType, adMetadata: AdMetadata) { Log.d(\"InlineAdViewModel events\", \"Collected EVENT - $adEventType\") when (adEventType) { is AdEventType.Impression -&gt; {} is AdEventType.RendererMessageReceived -&gt; {} is AdEventType.CustomTrackingEvent -&gt; {} is AdEventType.Tap -&gt; {} is AdEventType.UnloadRequest -&gt; {} is AdEventType.Viewable -&gt; { when (adEventType.percentage) { AdEventType.VisibilityPercentage.ONE -&gt; { Log.d(\"InlineAdViewModel events\", \"1% of my ads are now visible on the screen.\") } AdEventType.VisibilityPercentage.FIFTY -&gt; { Log.d(\"InlineAdViewModel events\", \"50% of my ads are now visible on the screen.\") } AdEventType.VisibilityPercentage.ONE_HUNDRED -&gt; { Log.d(\"InlineAdViewModel events\", \"100% of my ads are now visible on the screen.\") } } } } } } init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, adEventListener = adEventListener ).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/handling-the-ad-events.html#section-1-observing-events",
    
    "relUrl": "/5.3.0/handling-the-ad-events.html#section-1-observing-events"
  },"35": {
    "doc": "Handling the ad events",
    "title": "Handling the ad events",
    "content": " ",
    "url": "/nextgen-adsdk-android-release/5.3.0/handling-the-ad-events.html",
    
    "relUrl": "/5.3.0/handling-the-ad-events.html"
  },"36": {
    "doc": "Meet nextgen AdSDK",
    "title": "Meet nextgen AdSDK",
    "content": "Manage, display, and create your custom advertisements on Android using cutting-edge technologies such as Jetpack Compose and Coroutines based on the AdSDK. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/meet-adsdk.html",
    
    "relUrl": "/5.3.0/meet-adsdk.html"
  },"37": {
    "doc": "Meet nextgen AdSDK",
    "title": "Chapter 1",
    "content": "Working with the built-in capabilities of the SDK. In this chapter, you will learn how to create, display, and manage advertisements using AdSDK. | First steps for working with AdSDK | Create and display inline ads | Create and display interstitial ad | Handling the ad events | User tagging and conversion tracking | Global request parameters | AdSDK Cache Management | . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/meet-adsdk.html#chapter-1",
    
    "relUrl": "/5.3.0/meet-adsdk.html#chapter-1"
  },"38": {
    "doc": "Meet nextgen AdSDK",
    "title": "Chapter 2",
    "content": "Extending the SDK with your custom advertisements. In this chapter, you will learn about the possibilities of extending and substituting the AdSDK functionality. | Creating customised advertising | . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/meet-adsdk.html#chapter-2",
    
    "relUrl": "/5.3.0/meet-adsdk.html#chapter-2"
  },"39": {
    "doc": "Meet nextgen AdSDK",
    "title": "Chapter 3",
    "content": "Additional infos and guides. In this chapter, you can learn about special cases, like using the AdSDK with XML views. | How to use AdSDK with XML views | . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/meet-adsdk.html#chapter-3",
    
    "relUrl": "/5.3.0/meet-adsdk.html#chapter-3"
  },"40": {
    "doc": "User tagging and conversion tracking",
    "title": "User tagging and conversion tracking",
    "content": "AdSDK provides powerful functionality for user tagging and conversion tracking. In this tutorial we will explore this functionality. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.3.0/user-tagging-conversion-tracking.html",
    
    "relUrl": "/5.3.0/user-tagging-conversion-tracking.html"
  },"41": {
    "doc": "User tagging and conversion tracking",
    "title": "Section 1: User tagging",
    "content": "The SDK provides functionality to put a user identifier, such as a cookie id, into a retargeting segment (to tag a user). This allows advertisers to create a segment of users with certain interests or affinities, and to re-advertise to this segment (retargeting). In this section, we will look at how to perform a tag request using the AdSDK. Step 1 . To tag a user we need a TagRequest, that describes the request for tagging and consists of tags with a key, a subkey, and a value. We keep it simple and just add a tagUser() method to the InlineAdViewModel and create a TagRequest with one TagRequest.Tag. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) } } . Step 2 . We pass the TagRequest to the AdService.tagUser. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request) } } . Step 3 . The AdService.tagUser method returns an AdResult, so let’s log the result. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } } . Step 4 . To make sure the user is tagged before we call AdService.makeAdvertisement, we will use the coroutines async method. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { val tagUser = async { tagUser() } tagUser.await() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/user-tagging-conversion-tracking.html#section-1-user-tagging",
    
    "relUrl": "/5.3.0/user-tagging-conversion-tracking.html#section-1-user-tagging"
  },"42": {
    "doc": "User tagging and conversion tracking",
    "title": "Section 2: Conversion tracking",
    "content": "The SDK allows you to track conversions. This is useful for advertisers as conversion details are available in post tracking reports via the ad server. In this section we will look at how to perform a tracking request using the AdSDK. Step 1 . A conversion tracking request is described using TrackingRequest. We add a conversionTracking() function to the InlineAdViewModel . File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() conversionTracking() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } private suspend fun conversionTracking() { val request = TrackingRequest( landingPageId = 1, trackingSpotId = 1, orderId = \"orderId\", itemNumber = \"itemNumber\", description = \"description\", quantity = 1, price = 19.99f, total = 39.98f ) } } . Step 2 . We pass the TrackingRequest to the AdService.trackingRequest. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() conversionTracking() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } private suspend fun conversionTracking() { val request = TrackingRequest( landingPageId = 1, trackingSpotId = 1, orderId = \"orderId\", itemNumber = \"itemNumber\", description = \"description\", quantity = 1, price = 19.99f, total = 39.98f ) AdService.trackingRequest(request) } } . Step 3 . The AdService.trackingRequest method also returns an AdResult, so let’s log the result. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() conversionTracking() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } private suspend fun conversionTracking() { val request = TrackingRequest( landingPageId = 1, trackingSpotId = 1, orderId = \"orderId\", itemNumber = \"itemNumber\", description = \"description\", quantity = 1, price = 19.99f, total = 39.98f ) AdService.trackingRequest(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"Conversion tracking was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed conversion tracking: ${it.description}\") } ) } } . Step 4 . To ensure that the conversion tracking is done before we call the AdService.makeAdvertisement method, we will use the coroutines async method. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { val tagUser = async { tagUser() } val conversionTracking = async { conversionTracking() } tagUser.await() conversionTracking.await() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } private suspend fun conversionTracking() { val request = TrackingRequest( landingPageId = 1, trackingSpotId = 1, orderId = \"orderId\", itemNumber = \"itemNumber\", description = \"description\", quantity = 1, price = 19.99f, total = 39.98f ) AdService.trackingRequest(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"Conversion tracking was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed conversion tracking: ${it.description}\") } ) } } . ",
    "url": "/nextgen-adsdk-android-release/5.3.0/user-tagging-conversion-tracking.html#section-2-conversion-tracking",
    
    "relUrl": "/5.3.0/user-tagging-conversion-tracking.html#section-2-conversion-tracking"
  },"43": {
    "doc": "AdSDK Cache Management",
    "title": "AdSDK Cache Management",
    "content": "The SDK supports a persistent cache with resources related to ad, these can be banners or other resources, depending on the type of ad. In this tutorial, we’ll look at how an application developer can control the cache. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/cache-management.html",
    
    "relUrl": "/5.0.1/cache-management.html"
  },"44": {
    "doc": "AdSDK Cache Management",
    "title": "Section 1: Limiting the cache size",
    "content": "In this section, we will learn how to limit the size of the cache. Step 1 . When we creating an AdService, we can specify the size of our cache in MB. Let’s change it to 20 MB. The cache size parameter is optional. If you do not specify it, the default cache size is 100 MB. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure( \"1800\", applicationContext, cacheSizeInMb = 20u ) initResult.get( onSuccess = { addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } // ... } . Step 2 . In addition, the SDK allows you to change the size of the cache over time. You can use AdService.setCacheSize method for this purpose. If the specified cache size is smaller than the size of already cached resources, the cache will delete resources to fit the new specified limit. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure( \"1800\", applicationContext, cacheSizeInMb = 20u ) initResult.get( onSuccess = { // coroutineScope.launch { AdService.setCacheSize(20u) } addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } // ... } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/cache-management.html#section-1-limiting-the-cache-size",
    
    "relUrl": "/5.0.1/cache-management.html#section-1-limiting-the-cache-size"
  },"45": {
    "doc": "AdSDK Cache Management",
    "title": "Section 2: Flushing the cache",
    "content": "Although the cache size reached to it limit, SDK will removes resources in FIFO order, sometimes you need to clear the cache completely. In this section, we will learn how we can do this. Step 1 . For example, let’s clear the cache in the case of an AdError.CacheWriteAction. To do this, let’s go back to the InlineAd file and add this code in the case of a AdService.makeAdvertisement method failure. File: InlineAd.kt . // ... class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { val tagUser = async { tagUser() } val conversionTracking = async { conversionTracking() } tagUser.await() conversionTracking.await() AdService.makeAdvertisement( adRequest, adEventListener = adEventListener ).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") when(it) { is AdError.CacheWriteAction -&gt; { } else -&gt; {} } advertisementState.value = ResultState.Error(it) } ) } } //... } . Step 2 . We create an method flushCache and use AdService.flushCache. File: InlineAd.kt . // ... class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { val tagUser = async { tagUser() } val conversionTracking = async { conversionTracking() } tagUser.await() conversionTracking.await() AdService.makeAdvertisement( adRequest, adEventListener = adEventListener ).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") when(it) { is AdError.CacheWriteAction -&gt; { flushCache() } else -&gt; {} } advertisementState.value = ResultState.Error(it) } ) } } fun flushCache() { viewModelScope.launch { AdService.flushCache().get( onSuccess = { Log.d(\"InlineAdViewModel\", \"FlushCache was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed flushCache: ${it.description}\") } ) } } // ... } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/cache-management.html#section-2-flushing-the-cache",
    
    "relUrl": "/5.0.1/cache-management.html#section-2-flushing-the-cache"
  },"46": {
    "doc": "AdSDK Cache Management",
    "title": "Section 3: Specify the cache path",
    "content": "In this section, we will see how to set the path of the cache. Step 1 . Like the size we can also set the custom path of the cache when we configure the AdService. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure( \"1800\", applicationContext, cacheSizeInMb = 20u, cachePath = cacheDir.path + \"/tutorialApp/\" ) initResult.get( onSuccess = { // coroutineScope.launch { AdService.setCacheSize(20u) } addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } // ... } . Step 2 . Similar to the size, the SDK allows you to change the path of the cache over time. You can use AdService.setCachePath method for this purpose. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure( \"1800\", applicationContext, cacheSizeInMb = 20u, cachePath = cacheDir.path + \"/tutorialApp/\" ) initResult.get( onSuccess = { // coroutineScope.launch { AdService.setCacheSize(20u) } // coroutineScope.launch { // AdService.setCachePath(cacheDir.path + \"/tutorialApp/\") // } addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } // ... } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/cache-management.html#section-3-specify-the-cache-path",
    
    "relUrl": "/5.0.1/cache-management.html#section-3-specify-the-cache-path"
  },"47": {
    "doc": "How to use AdSDK with XML views",
    "title": "How to use AdSDK with XML views",
    "content": "You can follow the tutorial documentation almost entirely. We will highlight the few differences in this guide. We’ll also provide some examples of how to integrate the functionality. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/compose_with_xml_guide.html",
    
    "relUrl": "/5.0.1/compose_with_xml_guide.html"
  },"48": {
    "doc": "How to use AdSDK with XML views",
    "title": "AdSDK configuration",
    "content": "For setting up AdService, creating AdRequest and Advertisement, you can follow the previous tutorial exactly, as it does not include any Compose-specific code. The first thing to be careful about when following the tutorial is how the advertisement state is shared in the view model. In the tutorial, we use mutableStateOf, which is a feature from Jetpack Compose. An alternative could be MutableLiveData. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/compose_with_xml_guide.html#adsdk-configuration",
    
    "relUrl": "/5.0.1/compose_with_xml_guide.html#adsdk-configuration"
  },"49": {
    "doc": "How to use AdSDK with XML views",
    "title": "Use AdSDK composable with views",
    "content": "The major difference when using XML instead of Compose comes when you try to use the Ad or the Interstitial composable, since they are built with Compose. To integrate them into an XML-based layout, you’ll need to use Android’s setContent(). There are several ways to do this. You can use the XML layout. &lt;androidx.compose.ui.platform.ComposeView android:id=\"@+id/composeView1\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; . is ResultState.Success -&gt; { findViewById&lt;ComposeView&gt;(R.id.composeView1).setContent { Ad(it.data) } } . You can also create the layout in the code directly. ComposeView(context).apply { layoutParams = AdsListView.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT ) setContent { Interstitial(viewModel.interstitialState) } } . For more information, you can refer to the Compose documentation. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/compose_with_xml_guide.html#use-adsdk-composable-with-views",
    
    "relUrl": "/5.0.1/compose_with_xml_guide.html#use-adsdk-composable-with-views"
  },"50": {
    "doc": "Create and display inline ads",
    "title": "Create and display inline ads",
    "content": "This tutorial will guide you how to create and display inline ads. An inline ad is an ad created to be displayed in your view hierarchy. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/create-and-display-inline-ads.html",
    
    "relUrl": "/5.0.1/create-and-display-inline-ads.html"
  },"51": {
    "doc": "Create and display inline ads",
    "title": "Creating an inline ads",
    "content": "Your AdService is ready for creating advertisements, so in this section, we will create an InlineAd composable for future ad display. Step 1 . Lets create an InlineAd composable and an InlineAdViewModel class. File: InlineAd.kt . @Composable fun InlineAd() { Text( text = \"Advertisement should be here\" ) } class InlineAdViewModel : ViewModel() { } . Step 2 . To create advertisements, we use the AdService.makeAdvertisement method. The most important parameter now is AdRequest, which describes the request that will be sent to the server to receive ads. The only mandatory parameter when creating the AdRequest is AdRequest.contentUnit or AdRequest.learningTag. Content unit is unique ID of a content space. You can also use AdRequest.learningTag, but we use AdRequest.contentUnit in this tutorial because it is more commonly used. File: InlineAd.kt . @Composable fun InlineAd() { Text( text = \"Advertisement should be here\" ) } class InlineAdViewModel : ViewModel() { private val adRequest = AdRequest(\"4810915\") } . Step 3 . The AdService.makeAdvertisement method returns AdResult. It is also suspendable we will use it in the viewModelScope. If the ad is created and loaded successfully, you will receive the downloaded Advertisement object. You can think of it as a ViewModel that holds the data and state of your ad. We’ll again use ResultState with Advertisement to identify whether the ad was created and loaded successfully. File: InlineAd.kt . @Composable fun InlineAd() { Text( text = \"Advertisement should be here\" ) } class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) init { viewModelScope.launch { AdService.makeAdvertisement(adRequest).get( onSuccess = { advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 4 . If we have an Advertisement instance, it remains to add a Composable. The sdk_presentation_compose has Ad, which is the presentation layer of your inline ad. File: InlineAd.kt . @Composable fun InlineAd() { val viewModel: InlineAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Ad(it.data) } } } } class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) init { viewModelScope.launch { AdService.makeAdvertisement(adRequest).get( onSuccess = { advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 5 . The last thing we need to do is add our Composable to the MainActivity. File: MainActivity.kt . class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val app = application as App app.adServiceStatus.observe(this) { result -&gt; when(result) { is ResultState.Error -&gt; { showAppError(result.exception) } is ResultState.Success -&gt; { setContent { TutorialAppTheme { InlineAd() } } } } } } private fun showAppError(adError: AdError) { Toast.makeText(this, \"Initialization failed: ${adError.description}\", Toast.LENGTH_LONG).show() } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/create-and-display-inline-ads.html#creating-an-inline-ads",
    
    "relUrl": "/5.0.1/create-and-display-inline-ads.html#creating-an-inline-ads"
  },"52": {
    "doc": "Create and display inline ads",
    "title": "Section 2: Defining the size of the advertisement",
    "content": "Our InlineAdViewModel and InlineAd can load and display ads, but how can we understand what size the Ad should be? In this section we will deal with this question. Step 1 . As we already know, Advertisement stores advertising data. Let’s try to get it! We can obtain all possible advertising data using AdMetadata. This is the one we will use to obtain the size data. We are interested in AdMetadata.aspectRatio, which is optional. We have implemented the logic so that in cases where it is not present, we will use the 2:1 ratio. File: InlineAd.kt . @Composable fun InlineAd() { val viewModel: InlineAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { it.data.adMetadata Ad(it.data) } } } } class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f init { viewModelScope.launch { AdService.makeAdvertisement(adRequest).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 2 . Now we can add the AdMetadata.aspectRatio via the Modifier into the Ad. File: InlineAd.kt . @Composable fun InlineAd() { val viewModel: InlineAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { it.data.adMetadata Ad( it.data, modifier = Modifier.aspectRatio(viewModel.aspectRatio) ) } } } } class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f init { viewModelScope.launch { AdService.makeAdvertisement(adRequest).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Now we should see the banner on our device. Congrats! . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/create-and-display-inline-ads.html#section-2-defining-the-size-of-the-advertisement",
    
    "relUrl": "/5.0.1/create-and-display-inline-ads.html#section-2-defining-the-size-of-the-advertisement"
  },"53": {
    "doc": "Create and display interstitial ad",
    "title": "Create and display interstitial ad",
    "content": "A full-screen advertisement that fills the host app’s interface is known as an interstitial ad. In this tutorial we will add an interstitial ad to our application. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/create-and-display-interstitial-ad.html",
    
    "relUrl": "/5.0.1/create-and-display-interstitial-ad.html"
  },"54": {
    "doc": "Create and display interstitial ad",
    "title": "Section 1: Prepare app for interstitial ad",
    "content": "We want to present the interstitial on a different screen and add navigation buttons for it. Step 1 . Let’s create a new MainScreen file in which we add Navigation and MainScreen. Note: At the moment you will get an error, because we have not created InterstitialScreen yet. File: MainScreen.kt . @Composable fun Navigation() { val navController = rememberNavController() NavHost(navController = navController, startDestination = \"mainScreen\") { composable(\"mainScreen\") { MainScreen(navController) } composable(\"interstitial\") { InterstitialScreen() } } } @Composable fun MainScreen(navController: NavController) { Scaffold( floatingActionButton = { ExtendedFloatingActionButton( onClick = { navController.navigate(\"interstitial\") }, content = { Text(\"Go to Interstitial\") }, ) } ) { innerPadding -&gt; Column( modifier = Modifier .fillMaxSize() .padding(innerPadding), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { InlineAd() Spacer(modifier = Modifier.height(16.dp)) } } } . Step 2 . The next step is to create our future screen for displaying interstitial ads. Create a new InterstitialScreen file and add a screen with a button to it. File: InterstitialScreen.kt . @Composable fun InterstitialScreen() { Box( modifier = Modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { Button( onClick = { }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } } } class InterstitialAdViewModel : ViewModel() { } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/create-and-display-interstitial-ad.html#section-1-prepare-app-for-interstitial-ad",
    
    "relUrl": "/5.0.1/create-and-display-interstitial-ad.html#section-1-prepare-app-for-interstitial-ad"
  },"55": {
    "doc": "Create and display interstitial ad",
    "title": "Section 2: Creating interstitial advertisements",
    "content": "We have already created an inline Advertisement on a previous chapter. In this section, we will create a interstitial ad for the future presentation. Step 1 . Interstitial ad is created in the same way as inline ads, with one difference – the placementType parameter must be AdPlacementType.INTERSTITIAL. Let’s add the logic for loading the advertisement into InterstitialAdViewModel. We’ll again use ResultState with Advertisement to identify whether the ad was created and loaded successfully. File: InterstitialScreen.kt . @Composable fun InterstitialScreen() { Box( modifier = Modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { Button( onClick = { }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = AdPlacementType.INTERSTITIAL, ).get( onSuccess = { advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 2 . We add the InterstitialAdViewModel to the InterstitialAd. File: InterstitialScreen.kt . @Composable fun InterstitialScreen() { val viewModel: InterstitialAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = AdPlacementType.INTERSTITIAL, ).get( onSuccess = { advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/create-and-display-interstitial-ad.html#section-2-creating-interstitial-advertisements",
    
    "relUrl": "/5.0.1/create-and-display-interstitial-ad.html#section-2-creating-interstitial-advertisements"
  },"56": {
    "doc": "Create and display interstitial ad",
    "title": "Section 3: Presenting interstitial ad",
    "content": "We learnt how to create interstitial advertisement. Now, we are ready to present our interstitial ad. In this section, we will display interstitial ad in our app. Step 1 . Our AdSDK provides AdInterstitialState to control the state of the interstitial ad presentation. Add a property for this in the InterstitialAdViewModel. File: InterstitialScreen.kt . fun InterstitialScreen() { val viewModel: InterstitialAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisement = mutableStateOf&lt;Advertisement?&gt;(null) lateinit var interstitialState: AdInterstitialState init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = PlacementType.INTERSTITIAL, adEventListener = adEventListener ).get( onSuccess = { interstitialState = AdInterstitialState(it, this) advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"AdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 2 . The next step will be adding a presentation layer. To display interstitial ads, SDK has an Interstitial composable. Add it to your InterstitialScreen and pass the state value from the InterstitialAdViewModel. File: InterstitialScreen.kt . @Composable fun InterstitialScreen(modifier: Modifier) { val viewModel: InterstitialAdViewModel = viewModel() Box( modifier = modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } Interstitial(viewModel.interstitialState) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisement = mutableStateOf&lt;Advertisement?&gt;(null) lateinit var interstitialState: AdInterstitialState init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = PlacementType.INTERSTITIAL ).get( onSuccess = { interstitialState = AdInterstitialState(it, this) advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 3 . To show an interstitial ad, you can use the AdInterstitialState.presentIfLoaded method. Note: If you don’t use the Advertisement.reload method, your Advertisement object will always be loaded, which means that the ad will be presented to the user immediately when AdInterstitialState.presentIfLoaded method called. Otherwise, the ad will be presented immediately after loading. File: InterstitialScreen.kt . fun InterstitialScreen() { val viewModel: InterstitialAdViewModel = viewModel() Box( modifier = modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { viewModel.interstitialState.presentIfLoaded() }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } Interstitial(viewModel.interstitialState) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisement = mutableStateOf&lt;Advertisement?&gt;(null) lateinit var interstitialState: AdInterstitialState init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = PlacementType.INTERSTITIAL ).get( onSuccess = { interstitialState = AdInterstitialState(it, this) advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/create-and-display-interstitial-ad.html#section-3-presenting-interstitial-ad",
    
    "relUrl": "/5.0.1/create-and-display-interstitial-ad.html#section-3-presenting-interstitial-ad"
  },"57": {
    "doc": "Create and display interstitial ad",
    "title": "Section 3: Hiding interstitial ad",
    "content": "We managed to successfully show the ad, but we would like to be able to close interstitial. In this section, we implement this logic. Step 1 . Let’s continue the development in our InterstitialScreen file. We could hide the ad by simply calling the AdInterstitialState.hide method, but we don’t know when to call it. In order to understand when ad should be hidden, we need to use AdEventListener. We will explain the AdEventListener in more detail in the next chapter. Let’s create an adEventListener in InterstitialAdViewModel, and then pass it to the AdService.makeAdvertisement. File: InterstitialScreen.kt . fun InterstitialScreen() { val viewModel: InterstitialAdViewModel = viewModel() Box( modifier = modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { viewModel.interstitialState.presentIfLoaded() }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } Interstitial(viewModel.interstitialState) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) lateinit var interstitialState: AdInterstitialState val adEventListener: AdEventListener = object : AdEventListener { override fun eventProcessed(adEventType: AdEventType, adMetadata: AdMetadata) { Log.d(\"InterstitialAdViewModel events\", \"Collected EVENT - $adEventType\") } } init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = AdPlacementType.INTERSTITIAL, adEventListener = adEventListener ).get( onSuccess = { interstitialState = AdInterstitialState(it, this) advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 2 . The event we are interested in is AdEventType.UnloadRequest. We need to observe it to make sure that the ad is hidden when it is needed. Note: You should not change the state from presented to hidden without using AdEventType.UnloadRequest event. The advert itself knows when it needs to be hidden and asks you to hide it using this method. File: InterstitialScreen.kt . fun InterstitialScreen() { val viewModel: InterstitialAdViewModel = viewModel() Box( modifier = modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { viewModel.interstitialState.presentIfLoaded() }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } Interstitial(viewModel.interstitialState) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) lateinit var interstitialState: AdInterstitialState val adEventListener: AdEventListener = object : AdEventListener { override fun eventProcessed(adEventType: AdEventType, adMetadata: AdMetadata) { Log.d(\"InterstitialAdViewModel events\", \"Collected EVENT - $adEventType\") if (adEventType == AdEventType.UnloadRequest) { interstitialState.hide() } } } init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = AdPlacementType.INTERSTITIAL, adEventListener= adEventListener ).get( onSuccess = { interstitialState = AdInterstitialState(it, this) advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Now, if you launch the app, you should see an interstitial ad. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/create-and-display-interstitial-ad.html#section-3-hiding-interstitial-ad",
    
    "relUrl": "/5.0.1/create-and-display-interstitial-ad.html#section-3-hiding-interstitial-ad"
  },"58": {
    "doc": "Creating customised advertising",
    "title": "Creating customised advertising",
    "content": "In this tutorial, we will learn how to create custom ads using AdSDK. This process is the same for both inline and interstitial ads. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. Note: In this tutorial, we want to display a picture and frame it, but in real-world projects, your ad can be anything - video, HTML, graphics, etc. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/creating-customised-advertising.html",
    
    "relUrl": "/5.0.1/creating-customised-advertising.html"
  },"59": {
    "doc": "Creating customised advertising",
    "title": "Section 1: Creating a custom renderer",
    "content": "We will create an custom composable ad. Let’s start by using the AdComposeRenderer. Step 1 . Create a new file TutorialRenderer and TutorialRenderer class on it. Step 2 . TutorialRenderer need to implement AdComposeRenderer, override AdComposeRenderer.configure, and AdComposeRenderer.RenderAd. We’ll take a closer look at each of these methods in separate sections. File: TutorialRenderer.kt . internal class TutorialRenderer : AdComposeRenderer { override suspend fun configure( rendererEventHandler: AdRendererEventHandler, adMetadata: AdMetadata, adResponseBundle: AdResponseBundle ): AdResult&lt;Unit&gt; {} @Composable override fun RenderAd(modifier: Modifier) {} } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/creating-customised-advertising.html#section-1-creating-a-custom-renderer",
    
    "relUrl": "/5.0.1/creating-customised-advertising.html#section-1-creating-a-custom-renderer"
  },"60": {
    "doc": "Creating customised advertising",
    "title": "Section 2: Get the data",
    "content": "In this section, we will learn how the renderer can receive data from the ad server using the AdComposeRenderer.configure method. Step 1 . The server should always be configured to return a custom response when using custom advertising. In this tutorial, the server is configured to give us the following response. { // ... \"ad_name\": \"tutorialad\", \"body\": { // ... \"ext\": { // ... \"adData\": { \"banner_image\": \"Banner URL\", \"framing_width\": \"Framing width\", \"is_black_framing\": \"Boolean value – whether the color should be black or white.\" } } } } . Step 2 . We will use kotlinx.serialization.json.JsonObject to parse the JSON. We have to import it in our build gradle file. File: build.gradle.kts . implementation(\"org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.3\") . Step 3 . The AdComposeRenderer.configure method is the key to creating ads. Within it, you have to perform all the logic to prepare the ad for display - decoding, additional downloads, etc. Note: This method is directly related to the [AdService.makeAdvertisement] and [Advertisement.reload] methods. As soon as this method is completed, the Advertisement will be returned to the app. The AdResponseBundle parameter contains the entire response from the server we need. It contains the data as AdResponse and JSON as a string. We will keep it easy and just use a method to get the 3 values from the AdResponse. You could do this with your own decoding logic or anything similar and use JSON string. File: TutorialRenderer.kt . internal class TutorialRenderer : AdComposeRenderer { private var framingWidth: Int = 1 private var isBlackFraming: Boolean = false override suspend fun configure( rendererEventHandler: AdRendererEventHandler, adMetadata: AdMetadata, adResponseBundle: AdResponseBundle ): AdResult&lt;Unit&gt; { val adDataMap = adResponseBundle.adResponse.body?.ext?.adData as? Map&lt;*, *&gt; ?: return AdResult.Error(AdError.Decoding(Exception(\"adData is missing.\"))) val jsonString = JSONObject(adDataMap).toString() val adData = Json.parseToJsonElement(jsonString).jsonObject val bannerURL = adData[\"banner_image\"]?.jsonPrimitive?.content ?: return AdResult.Error(AdError.Decoding(Exception(\"Banner URL is null.\"))) framingWidth = adData[\"framing_width\"]?.jsonPrimitive?.intOrNull ?: framingWidth isBlackFraming = adData[\"is_black_framing\"]?.jsonPrimitive?.booleanOrNull ?: isBlackFraming } @Composable override fun RenderAd(modifier: Modifier) {} } . Step 4 . We will use the banner URL to get the image from the cache or download it from the server. We get a cache instance with AdService.getCacheInstance and can use DriveCache.find to get the image from cache. If not, we will use AdRendererEventHandler.downloadBitmap to download the image. We will take a closer look at [AdRendererEventHandler] in the next sections. File: TutorialRenderer.kt . internal class TutorialRenderer : AdComposeRenderer { private lateinit var eventHandler: AdRendererEventHandler private var framingWidth: Int = 1 private var isBlackFraming: Boolean = false override suspend fun configure( rendererEventHandler: AdRendererEventHandler, adMetadata: AdMetadata, adResponseBundle: AdResponseBundle ): AdResult&lt;Unit&gt; { this.eventHandler = rendererEventHandler val adDataMap = adResponseBundle.adResponse.body?.ext?.adData as? Map&lt;*, *&gt; ?: return AdResult.Error(AdError.Decoding(Exception(\"adData is missing.\"))) val jsonString = JSONObject(adDataMap).toString() val adData = Json.parseToJsonElement(jsonString).jsonObject val bannerURL = adData[\"banner_image\"]?.jsonPrimitive?.content ?: return AdResult.Error(AdError.Decoding(Exception(\"Banner URL is null.\"))) framingWidth = adData[\"framing_width\"]?.jsonPrimitive?.intOrNull ?: framingWidth isBlackFraming = adData[\"is_black_framing\"]?.jsonPrimitive?.booleanOrNull ?: isBlackFraming val bannerResult = getBanner(bannerURL) return when (bannerResult) { is AdResult.Success -&gt; { imageBitmap = bannerResult.result AdResult.Success(Unit) } is AdResult.Error -&gt; AdResult.Error(bannerResult.error) } } private suspend fun getBanner(url: String): AdResult&lt;ImageBitmap&gt; { val cachedBanner = getCachedBanner(url) if (cachedBanner != null) { return AdResult.Success(cachedBanner) } return loadAndCacheBanner(url) } private suspend fun getCachedBanner(url: String): ImageBitmap? { val cache = AdService.getCacheInstance().getOrNull() val banner = cache?.find(url)?.getOrNull() if (banner != null) { return BitmapFactory.decodeByteArray( banner.data, 0, banner.data.size )?.asImageBitmap() } return null } private suspend fun loadAndCacheBanner(url: String): AdResult&lt;ImageBitmap&gt; { val bitmapResult = eventHandler.downloadBitmap(url) return when (bitmapResult) { is AdResult.Error -&gt; AdResult.Error(bitmapResult.error) is AdResult.Success -&gt; { AdResult.Success(bitmapResult.result.asImageBitmap()) } } } @Composable override fun RenderAd(modifier: Modifier) {} } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/creating-customised-advertising.html#section-2-get-the-data",
    
    "relUrl": "/5.0.1/creating-customised-advertising.html#section-2-get-the-data"
  },"61": {
    "doc": "Creating customised advertising",
    "title": "Section 3: Create the renderer UI",
    "content": "Now our data is ready. Lets create the renderer UI. To do this, we will use the AdComposeRenderer.RenderAd composable method. Step 1 . We will only show a framed image when the imageBitmap is loaded. File: TutorialRenderer.kt . internal class TutorialRenderer : AdComposeRenderer { private lateinit var eventHandler: AdRendererEventHandler private var imageBitmap by mutableStateOf&lt;ImageBitmap?&gt;(null) private var framingWidth: Int = 1 private var isBlackFraming: Boolean = false // ... @Composable override fun RenderAd(modifier: Modifier) { val imageBitmap = rememberUpdatedState(this.imageBitmap) imageBitmap.value?.let { // Framed image goes here. } } } . Step 2 . We create a box for the framing and show the image inside. File: TutorialRenderer.kt . internal class TutorialRenderer : AdComposeRenderer { private lateinit var eventHandler: AdRendererEventHandler private var imageBitmap by mutableStateOf&lt;ImageBitmap?&gt;(null) private var framingWidth: Int = 1 private var isBlackFraming: Boolean = false // ... @Composable override fun RenderAd(modifier: Modifier) { val imageBitmap = rememberUpdatedState(this.imageBitmap) imageBitmap.value?.let { val borderColor = if (isBlackFraming) Color.Black else Color.White Box( modifier = Modifier .fillMaxWidth() .aspectRatio(it.width.toFloat() / it.height) .border( width = framingWidth.dp, color = borderColor ) ) { Image( bitmap = it, contentDescription = null ) } } } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/creating-customised-advertising.html#section-3-create-the-renderer-ui",
    
    "relUrl": "/5.0.1/creating-customised-advertising.html#section-3-create-the-renderer-ui"
  },"62": {
    "doc": "Creating customised advertising",
    "title": "Section 4: Event management",
    "content": "The next step will be to implement the processing of ad-related events. We can do this using the [AdRendererEventHandler]. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/creating-customised-advertising.html#section-4-event-management",
    
    "relUrl": "/5.0.1/creating-customised-advertising.html#section-4-event-management"
  },"63": {
    "doc": "Creating customised advertising",
    "title": "Step 1",
    "content": "We already used AdRendererEventHandler.downloadBitmap. Here are all event method we can use: . | AdRendererEventHandler.downloadBitmap | AdRendererEventHandler.performCustomTrackingEvent | AdRendererEventHandler.performTapEvent | AdRendererEventHandler.sendMessage | AdRendererEventHandler.unloadRequest | . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/creating-customised-advertising.html#step-1-3",
    
    "relUrl": "/5.0.1/creating-customised-advertising.html#step-1-3"
  },"64": {
    "doc": "Creating customised advertising",
    "title": "Step 2",
    "content": "We will use AdRendererEventHandler.performTapEvent to trigger the tap event. Note: You can see all possible types of tap events and the difference between them in the AdTapEvent documentation. File: TutorialRenderer.kt . internal class TutorialRenderer : AdComposeRenderer { private lateinit var eventHandler: AdRendererEventHandler // ... @Composable override fun RenderAd(modifier: Modifier) { val imageBitmap = rememberUpdatedState(this.imageBitmap) imageBitmap.value?.let { val borderColor = if (isBlackFraming) Color.Black else Color.White Box( modifier = Modifier .fillMaxWidth() .aspectRatio(it.width.toFloat() / it.height) .border( width = framingWidth.dp, color = borderColor ) ) { Image( bitmap = it, contentDescription = null, modifier.clickable { eventHandler.performTapEvent(AdTapEvent.Tap) } ) } } } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/creating-customised-advertising.html#step-2-3",
    
    "relUrl": "/5.0.1/creating-customised-advertising.html#step-2-3"
  },"65": {
    "doc": "Creating customised advertising",
    "title": "Section 5: Prepare to present the custom ad",
    "content": "Let’s create a screen to present our custom ad. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/creating-customised-advertising.html#section-5-prepare-to-present-the-custom-ad",
    
    "relUrl": "/5.0.1/creating-customised-advertising.html#section-5-prepare-to-present-the-custom-ad"
  },"66": {
    "doc": "Creating customised advertising",
    "title": "Step 1",
    "content": "Create a new file CustomAd. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/creating-customised-advertising.html#step-1-4",
    
    "relUrl": "/5.0.1/creating-customised-advertising.html#step-1-4"
  },"67": {
    "doc": "Creating customised advertising",
    "title": "Step 2",
    "content": "Add a CustomAd composable and a CustomAdViewModel. File: CustomAd.kt . @Composable fun CustomAd() { val viewModel: CustomAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { it.data.adMetadata Ad(it.data) } } } } class CustomAdViewModel: ViewModel() { private val adRequest = AdRequest(\"5227780\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, ).get( onSuccess = { advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"CustomAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/creating-customised-advertising.html#step-2-4",
    
    "relUrl": "/5.0.1/creating-customised-advertising.html#step-2-4"
  },"68": {
    "doc": "Creating customised advertising",
    "title": "Step 3",
    "content": "Add the CustomAd into the MainScreen. File: MainScreen.kt . @Composable fun Navigation() { val navController = rememberNavController() NavHost(navController = navController, startDestination = \"mainScreen\") { composable(\"mainScreen\") { MainScreen(navController) } composable(\"interstitial\") { InterstitialScreen() } } } @Composable fun MainScreen(navController: NavController) { Scaffold( floatingActionButton = { ExtendedFloatingActionButton( onClick = { navController.navigate(\"interstitial\") }, content = { Text(\"Go to Interstitial\") }, ) } ) { innerPadding -&gt; Column( modifier = Modifier .fillMaxSize() .padding(innerPadding), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { InlineAd() CustomAd() } } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/creating-customised-advertising.html#step-3-1",
    
    "relUrl": "/5.0.1/creating-customised-advertising.html#step-3-1"
  },"69": {
    "doc": "Creating customised advertising",
    "title": "Section 6: Registering a renderer in the SDK",
    "content": "Although we have created a custom ad, in order for the SDK to use it, we need to pass it to the SDK somehow. Let’s do that. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/creating-customised-advertising.html#section-6-registering-a-renderer-in-the-sdk",
    
    "relUrl": "/5.0.1/creating-customised-advertising.html#section-6-registering-a-renderer-in-the-sdk"
  },"70": {
    "doc": "Creating customised advertising",
    "title": "Step 1",
    "content": "First of all, let’s get back to our response from the server. As you can see, it includes the ad_name field. It is this field that the SDK will use to identify your renderer. { // ... \"ad_name\": \"tutorialad\", // &lt;------- \"body\": { // ... \"ext\": { // ... \"adData\": { \"banner_image\": \"Banner URL\", \"framing_width\": \"Framing width\", \"is_black_framing\": \"Boolean value – whether the color should be black or white.\" } } } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/creating-customised-advertising.html#step-1-5",
    
    "relUrl": "/5.0.1/creating-customised-advertising.html#step-1-5"
  },"71": {
    "doc": "Creating customised advertising",
    "title": "Step 2",
    "content": "All we need to do is use the AdService.registerRenderer method, passing in the value we expect to receive in the ad_name field and the renderer factory. This way, every time the ad_name field in the server response is the same as the string you passed to this method, the SDK will display the TutorialRenderer. Step 3 . We call the AdService.registerRenderer method in the App class. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure( \"1800\", applicationContext, cacheSizeInMb = 20u, cachePath = cacheDir.path + \"/tutorialApp/\" ) initResult.get( onSuccess = { launch { AdService.registerRenderer(\"tutorialad\") { TutorialRenderer() } adServiceStatus.postValue(ResultState.Success(Unit)) } }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } } . Now you can launch the app and see your new custom ad, congratulations! . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/creating-customised-advertising.html#step-2-5",
    
    "relUrl": "/5.0.1/creating-customised-advertising.html#step-2-5"
  },"72": {
    "doc": "First steps for working with AdSDK",
    "title": "First steps for working with AdSDK",
    "content": "This tutorial will guide you through the first steps of working with the AdSDK - creating an AdService. You can download this this project which already implements all the steps of this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/first-steps.html",
    
    "relUrl": "/5.0.1/first-steps.html"
  },"73": {
    "doc": "First steps for working with AdSDK",
    "title": "Creating an AdService",
    "content": "Creating and configuring an AdService for later ad creation and loading. Step 1 . Create a new Android project and remove any unnecessary code. Make sure you have added the correct packages from the readme. Step 2 . The entry point into the SDK is the AdService class. This is the first thing we should create, as it will be used to generate advertisements in the future. For an easy start, we will simply configure the AdService in the App class. We create a file called App and add it to the MainActivity as well. File: App.kt . class App : Application() { override fun onCreate() { super.onCreate() } } . File: MainActivity.kt . class MainActivity : ComponentActivity() { override fun onCreate() { super.onCreate() val app = application as App // ... } } // ... Remember to add this class as an entry point, so add it to the application in your Manifest. File: AndroidManifest.xml . android:name=\"com.adition.tutorial_app.App\" . Step 3 . Before using the AdService, we should first configure it. To do this, we will use the AdService.configure method in the App class. The only mandatory parameter when configuring an AdService is AdService.networkId. The network identifier is the identifier of your advertising account. The configure method is suspendable, so we should use the coroutine. To do this, we need to create a coroutineScope and add this code to the onCreate function of the App class. class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) override fun onCreate() { super.onCreate() coroutineScope.launch { AdService.configure(\"1800\", applicationContext) } } } . Step 4 . AdService.configure returns AdResult, which is our custom AdSDK implementation of Kotlin’s Result. AdResult contains AdError the only type of error which the SDK supports. We can use AdResult to check that the AdService has been successfully configured and initialised. Let us add a ResultState class to monitor the status. File: ResultState . sealed class ResultState&lt;out T&gt; { data class Success&lt;out T&gt;(val data: T) : ResultState&lt;T&gt;() data class Error&lt;T&gt;(val exception: AdError) : ResultState&lt;T&gt;() } . We can use this status in the App file. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure(\"1800\", applicationContext) initResult.get( onSuccess = { adServiceStatus.value = ResultState.Success(Unit) }, onError = { adServiceStatus.value = ResultState.Error(it) } ) } } } . Step 5 . We can now use adServiceStatus in the onCreate function of the MainActivity. File: MainActivity.kt . class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val app = application as App app.adServiceStatus.observe(this) { result -&gt; when(result) { is ResultState.Error -&gt; { // We will handle in the next step. } is ResultState.Success -&gt; { setContent { TutorialAppTheme { Greeting(name = \"AdSDK\") } } } } } } } // ... Step 6 . We could react on all the different error cases AdError contains. To keeps it easy we just show the description of the AdError. File: MainActivity.kt . class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val app = application as App app.adServiceStatus.observe(this) { result -&gt; when(result) { is ResultState.Error -&gt; { showAppError(result.exception) } is ResultState.Success -&gt; { setContent { TutorialAppTheme { Greeting(name = \"AdSDK\") } } } } } } private fun showAppError(adError: AdError) { Toast.makeText(this, \"Initialization failed: ${adError.description}\", Toast.LENGTH_LONG).show() } } // ... Now, if you’ve done everything right, you should see the greeting message when you launch the app. This completes the AdService configuration, congratulations! . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/first-steps.html#creating-an-adservice",
    
    "relUrl": "/5.0.1/first-steps.html#creating-an-adservice"
  },"74": {
    "doc": "Global request parameters",
    "title": "Global request parameters",
    "content": "We already know how to create and perform AdRequest, TagRequest, and TrackingRequest. However, each of them can have additional parameters, which are called global parameters because they are specified globally for all requests. The SDK provides the ability to add global parameters once so that you don’t have to copy them when creating each request. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/global-request-parameters.html",
    
    "relUrl": "/5.0.1/global-request-parameters.html"
  },"75": {
    "doc": "Global request parameters",
    "title": "Modifying global parameters",
    "content": "In this section we’ll configure the AdRequestGlobalParameters and TrackingGlobalParameters for each AdRequest, TagRequest, and TrackingRequest we have in our application. We will also look at the possibility of removing global parameters. Step 1 . We can add global parameters using the AdService. The AdService has a AdService.setAdRequestGlobalParameter method which we will use to set the gdpr parameter for each AdRequest. Add the global parameters to the App class and a function addGlobalParameters(). Note: If we want to remove a ad request global parameter we could use the AdService.removeAdRequestGlobalParameter method. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure(\"1800\", applicationContext) initResult.get( onSuccess = { addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } private fun addGlobalParameters() { val gdpr = GDPR(consent = \"gdprconsentexample\", isRulesEnabled = true) AdService.setAdRequestGlobalParameter(AdRequestGlobalParameters::gdpr, gdpr) // AdService.removeAdRequestGlobalParameter(AdRequestGlobalParameters::gdpr) } } . Step 2 . We can also modify TrackingGlobalParameters for each TagRequest and TrackingRequest using the AdService.setTrackingGlobalParameter method. Let’s add this code to the addGlobalParameters method. Note: If we want to remove a tracking global parameter we could use the AdService.removeTrackingGlobalParameter method. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure(\"1800\", applicationContext) initResult.get( onSuccess = { addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } private fun addGlobalParameters() { val gdpr = GDPR(consent = \"gdprconsentexample\", isRulesEnabled = true) AdService.setAdRequestGlobalParameter(AdRequestGlobalParameters::gdpr, gdpr) // AdService.removeAdRequestGlobalParameter(AdRequestGlobalParameters::gdpr) AdService.setTrackingGlobalParameter(TrackingGlobalParameters::gdpr, gdpr) // AdService.removeTrackingGlobalParameter(TrackingGlobalParameters::gdpr) } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/global-request-parameters.html#modifying-global-parameters",
    
    "relUrl": "/5.0.1/global-request-parameters.html#modifying-global-parameters"
  },"76": {
    "doc": "Handling the ad events",
    "title": "Monitor and process ad-related events",
    "content": "Advertisement do a lot of work under the hood and can send messages about them to the app. In turn, you can monitor and react to it in some way. In this tutorial, we’ll look at what events are handled by Advertisement and how we can interact with them. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/handling-the-ad-events.html#monitor-and-process-ad-related-events",
    
    "relUrl": "/5.0.1/handling-the-ad-events.html#monitor-and-process-ad-related-events"
  },"77": {
    "doc": "Handling the ad events",
    "title": "Section 1: Observing events",
    "content": "We will use the AdEventListener to observe the AdEventType. Since we used the AdEventListener in the interstitial tutorial, this time we will add it to the other InlineAdViewModel to observe all the AdEventType. Step 1 . Lets add an AdEventListener to the InlineAdViewModel and pass it to the AdService.makeAdvertisement. File: InlineAd.kt . // ... class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f val adEventListener: AdEventListener = object : AdEventListener { override fun eventProcessed(adEventType: AdEventType, adMetadata: AdMetadata) { Log.d(\"InlineAdViewModel events\", \"Collected EVENT - $adEventType\") } } init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, adEventListener = adEventListener ).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 2 . Here we can see the different AdEventType we can observe: . | Impression | Viewable | Tap | UnloadRequest | RendererMessageReceived | CustomTrackingEvent | . Now let us add all possible AdEventType to the AdEventListener.eventProcessed method of the adEventListener. File: InlineAd.kt . // ... class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f val adEventListener: AdEventListener = object : AdEventListener { override fun eventProcessed(adEventType: AdEventType, adMetadata: AdMetadata) { Log.d(\"InlineAdViewModel events\", \"Collected EVENT - $adEventType\") when (adEventType) { is AdEventType.Impression -&gt; {} is AdEventType.RendererMessageReceived -&gt; {} is AdEventType.CustomTrackingEvent -&gt; {} is AdEventType.Tap -&gt; {} is AdEventType.UnloadRequest -&gt; {} is AdEventType.Viewable -&gt; {} } } } init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, adEventListener = adEventListener ).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 3 . We have already seen UnloadRequest in the interstitial example. Lets look at the Viewable event and monitor each VisibilityPercentage in this example. Note: Impression and Viewable can only be observed if they are configured in the ad server backend. Otherwise they are not part of the ad response. File: InlineAd.kt . // ... class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f val adEventListener: AdEventListener = object : AdEventListener { override fun eventProcessed(adEventType: AdEventType, adMetadata: AdMetadata) { Log.d(\"InlineAdViewModel events\", \"Collected EVENT - $adEventType\") when (adEventType) { is AdEventType.Impression -&gt; {} is AdEventType.RendererMessageReceived -&gt; {} is AdEventType.CustomTrackingEvent -&gt; {} is AdEventType.Tap -&gt; {} is AdEventType.UnloadRequest -&gt; {} is AdEventType.Viewable -&gt; { when (adEventType.percentage) { AdEventType.VisibilityPercentage.ONE -&gt; { Log.d(\"InlineAdViewModel events\", \"1% of my ads are now visible on the screen.\") } AdEventType.VisibilityPercentage.FIFTY -&gt; { Log.d(\"InlineAdViewModel events\", \"50% of my ads are now visible on the screen.\") } AdEventType.VisibilityPercentage.ONE_HUNDRED -&gt; { Log.d(\"InlineAdViewModel events\", \"100% of my ads are now visible on the screen.\") } } } } } } init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, adEventListener = adEventListener ).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/handling-the-ad-events.html#section-1-observing-events",
    
    "relUrl": "/5.0.1/handling-the-ad-events.html#section-1-observing-events"
  },"78": {
    "doc": "Handling the ad events",
    "title": "Handling the ad events",
    "content": " ",
    "url": "/nextgen-adsdk-android-release/5.0.1/handling-the-ad-events.html",
    
    "relUrl": "/5.0.1/handling-the-ad-events.html"
  },"79": {
    "doc": "Meet nextgen AdSDK",
    "title": "Meet nextgen AdSDK",
    "content": "Manage, display, and create your custom advertisements on Android using cutting-edge technologies such as Jetpack Compose and Coroutines based on the AdSDK. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/meet-adsdk.html",
    
    "relUrl": "/5.0.1/meet-adsdk.html"
  },"80": {
    "doc": "Meet nextgen AdSDK",
    "title": "Chapter 1",
    "content": "Working with the built-in capabilities of the SDK. In this chapter, you will learn how to create, display, and manage advertisements using AdSDK. | First steps for working with AdSDK | Create and display inline ads | Create and display interstitial ad | Handling the ad events | User tagging and conversion tracking | Global request parameters | AdSDK Cache Management | . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/meet-adsdk.html#chapter-1",
    
    "relUrl": "/5.0.1/meet-adsdk.html#chapter-1"
  },"81": {
    "doc": "Meet nextgen AdSDK",
    "title": "Chapter 2",
    "content": "Extending the SDK with your custom advertisements. In this chapter, you will learn about the possibilities of extending and substituting the AdSDK functionality. | Creating customised advertising | . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/meet-adsdk.html#chapter-2",
    
    "relUrl": "/5.0.1/meet-adsdk.html#chapter-2"
  },"82": {
    "doc": "Meet nextgen AdSDK",
    "title": "Chapter 3",
    "content": "Additional infos and guides. In this chapter, you can learn about special cases, like using the AdSDK with XML views. | How to use AdSDK with XML views | . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/meet-adsdk.html#chapter-3",
    
    "relUrl": "/5.0.1/meet-adsdk.html#chapter-3"
  },"83": {
    "doc": "User tagging and conversion tracking",
    "title": "User tagging and conversion tracking",
    "content": "AdSDK provides powerful functionality for user tagging and conversion tracking. In this tutorial we will explore this functionality. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.0.1/user-tagging-conversion-tracking.html",
    
    "relUrl": "/5.0.1/user-tagging-conversion-tracking.html"
  },"84": {
    "doc": "User tagging and conversion tracking",
    "title": "Section 1: User tagging",
    "content": "The SDK provides functionality to put a user identifier, such as a cookie id, into a retargeting segment (to tag a user). This allows advertisers to create a segment of users with certain interests or affinities, and to re-advertise to this segment (retargeting). In this section, we will look at how to perform a tag request using the AdSDK. Step 1 . To tag a user we need a TagRequest, that describes the request for tagging and consists of tags with a key, a subkey, and a value. We keep it simple and just add a tagUser() method to the InlineAdViewModel and create a TagRequest with one TagRequest.Tag. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) } } . Step 2 . We pass the TagRequest to the AdService.tagUser. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request) } } . Step 3 . The AdService.tagUser method returns an AdResult, so let’s log the result. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } } . Step 4 . To make sure the user is tagged before we call AdService.makeAdvertisement, we will use the coroutines async method. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { val tagUser = async { tagUser() } tagUser.await() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/user-tagging-conversion-tracking.html#section-1-user-tagging",
    
    "relUrl": "/5.0.1/user-tagging-conversion-tracking.html#section-1-user-tagging"
  },"85": {
    "doc": "User tagging and conversion tracking",
    "title": "Section 2: Conversion tracking",
    "content": "The SDK allows you to track conversions. This is useful for advertisers as conversion details are available in post tracking reports via the ad server. In this section we will look at how to perform a tracking request using the AdSDK. Step 1 . A conversion tracking request is described using TrackingRequest. We add a conversionTracking() function to the InlineAdViewModel . File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() conversionTracking() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } private suspend fun conversionTracking() { val request = TrackingRequest( landingPageId = 1, trackingSpotId = 1, orderId = \"orderId\", itemNumber = \"itemNumber\", description = \"description\", quantity = 1, price = 19.99f, total = 39.98f ) } } . Step 2 . We pass the TrackingRequest to the AdService.trackingRequest. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() conversionTracking() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } private suspend fun conversionTracking() { val request = TrackingRequest( landingPageId = 1, trackingSpotId = 1, orderId = \"orderId\", itemNumber = \"itemNumber\", description = \"description\", quantity = 1, price = 19.99f, total = 39.98f ) AdService.trackingRequest(request) } } . Step 3 . The AdService.trackingRequest method also returns an AdResult, so let’s log the result. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() conversionTracking() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } private suspend fun conversionTracking() { val request = TrackingRequest( landingPageId = 1, trackingSpotId = 1, orderId = \"orderId\", itemNumber = \"itemNumber\", description = \"description\", quantity = 1, price = 19.99f, total = 39.98f ) AdService.trackingRequest(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"Conversion tracking was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed conversion tracking: ${it.description}\") } ) } } . Step 4 . To ensure that the conversion tracking is done before we call the AdService.makeAdvertisement method, we will use the coroutines async method. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { val tagUser = async { tagUser() } val conversionTracking = async { conversionTracking() } tagUser.await() conversionTracking.await() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } private suspend fun conversionTracking() { val request = TrackingRequest( landingPageId = 1, trackingSpotId = 1, orderId = \"orderId\", itemNumber = \"itemNumber\", description = \"description\", quantity = 1, price = 19.99f, total = 39.98f ) AdService.trackingRequest(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"Conversion tracking was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed conversion tracking: ${it.description}\") } ) } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.1/user-tagging-conversion-tracking.html#section-2-conversion-tracking",
    
    "relUrl": "/5.0.1/user-tagging-conversion-tracking.html#section-2-conversion-tracking"
  },"86": {
    "doc": "AdSDK Cache Management",
    "title": "AdSDK Cache Management",
    "content": "The SDK supports a persistent cache with resources related to ad, these can be banners or other resources, depending on the type of ad. In this tutorial, we’ll look at how an application developer can control the cache. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.0.0/cache-management.html",
    
    "relUrl": "/5.0.0/cache-management.html"
  },"87": {
    "doc": "AdSDK Cache Management",
    "title": "Section 1: Limiting the cache size",
    "content": "In this section, we will learn how to limit the size of the cache. Step 1 . When we creating an AdService, we can specify the size of our cache in MB. Let’s change it to 20 MB. The cache size parameter is optional. If you do not specify it, the default cache size is 100 MB. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure( \"1800\", applicationContext, cacheSizeInMb = 20u ) initResult.get( onSuccess = { addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } // ... } . Step 2 . In addition, the SDK allows you to change the size of the cache over time. You can use AdService.setCacheSize method for this purpose. If the specified cache size is smaller than the size of already cached resources, the cache will delete resources to fit the new specified limit. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure( \"1800\", applicationContext, cacheSizeInMb = 20u ) initResult.get( onSuccess = { // coroutineScope.launch { AdService.setCacheSize(20u) } addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } // ... } . ",
    "url": "/nextgen-adsdk-android-release/5.0.0/cache-management.html#section-1-limiting-the-cache-size",
    
    "relUrl": "/5.0.0/cache-management.html#section-1-limiting-the-cache-size"
  },"88": {
    "doc": "AdSDK Cache Management",
    "title": "Section 2: Flushing the cache",
    "content": "Although the cache size reached to it limit, SDK will removes resources in FIFO order, sometimes you need to clear the cache completely. In this section, we will learn how we can do this. Step 1 . For example, let’s clear the cache in the case of an AdError.CacheWriteAction. To do this, let’s go back to the InlineAd file and add this code in the case of a AdService.makeAdvertisement method failure. File: InlineAd.kt . // ... class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { val tagUser = async { tagUser() } val conversionTracking = async { conversionTracking() } tagUser.await() conversionTracking.await() AdService.makeAdvertisement( adRequest, adEventListener = adEventListener ).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") when(it) { is AdError.CacheWriteAction -&gt; { } else -&gt; {} } advertisementState.value = ResultState.Error(it) } ) } } //... } . Step 2 . We create an method flushCache and use AdService.flushCache. File: InlineAd.kt . // ... class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { val tagUser = async { tagUser() } val conversionTracking = async { conversionTracking() } tagUser.await() conversionTracking.await() AdService.makeAdvertisement( adRequest, adEventListener = adEventListener ).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") when(it) { is AdError.CacheWriteAction -&gt; { flushCache() } else -&gt; {} } advertisementState.value = ResultState.Error(it) } ) } } fun flushCache() { viewModelScope.launch { AdService.flushCache().get( onSuccess = { Log.d(\"InlineAdViewModel\", \"FlushCache was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed flushCache: ${it.description}\") } ) } } // ... } . ",
    "url": "/nextgen-adsdk-android-release/5.0.0/cache-management.html#section-2-flushing-the-cache",
    
    "relUrl": "/5.0.0/cache-management.html#section-2-flushing-the-cache"
  },"89": {
    "doc": "AdSDK Cache Management",
    "title": "Section 3: Specify the cache path",
    "content": "In this section, we will see how to set the path of the cache. Step 1 . Like the size we can also set the custom path of the cache when we configure the AdService. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure( \"1800\", applicationContext, cacheSizeInMb = 20u, cachePath = cacheDir.path + \"/tutorialApp/\" ) initResult.get( onSuccess = { // coroutineScope.launch { AdService.setCacheSize(20u) } addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } // ... } . Step 2 . Similar to the size, the SDK allows you to change the path of the cache over time. You can use AdService.setCachePath method for this purpose. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure( \"1800\", applicationContext, cacheSizeInMb = 20u, cachePath = cacheDir.path + \"/tutorialApp/\" ) initResult.get( onSuccess = { // coroutineScope.launch { AdService.setCacheSize(20u) } // coroutineScope.launch { // AdService.setCachePath(cacheDir.path + \"/tutorialApp/\") // } addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } // ... } . ",
    "url": "/nextgen-adsdk-android-release/5.0.0/cache-management.html#section-3-specify-the-cache-path",
    
    "relUrl": "/5.0.0/cache-management.html#section-3-specify-the-cache-path"
  },"90": {
    "doc": "Create and display inline ads",
    "title": "Create and display inline ads",
    "content": "This tutorial will guide you how to create and display inline ads. An inline ad is an ad created to be displayed in your view hierarchy. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.0.0/create-and-display-inline-ads.html",
    
    "relUrl": "/5.0.0/create-and-display-inline-ads.html"
  },"91": {
    "doc": "Create and display inline ads",
    "title": "Creating an inline ads",
    "content": "Your AdService is ready for creating advertisements, so in this section, we will create an InlineAd composable for future ad display. Step 1 . Lets create an InlineAd composable and an InlineAdViewModel class. File: InlineAd.kt . @Composable fun InlineAd() { Text( text = \"Advertisement should be here\" ) } class InlineAdViewModel : ViewModel() { } . Step 2 . To create advertisements, we use the AdService.makeAdvertisement method. The most important parameter now is AdRequest, which describes the request that will be sent to the server to receive ads. The only mandatory parameter when creating the AdRequest is AdRequest.contentUnit or AdRequest.learningTag. Content unit is unique ID of a content space. You can also use AdRequest.learningTag, but we use AdRequest.contentUnit in this tutorial because it is more commonly used. File: InlineAd.kt . @Composable fun InlineAd() { Text( text = \"Advertisement should be here\" ) } class InlineAdViewModel : ViewModel() { private val adRequest = AdRequest(\"4810915\") } . Step 3 . The AdService.makeAdvertisement method returns AdResult. It is also suspendable we will use it in the viewModelScope. If the ad is created and loaded successfully, you will receive the downloaded Advertisement object. You can think of it as a ViewModel that holds the data and state of your ad. We’ll again use ResultState with Advertisement to identify whether the ad was created and loaded successfully. File: InlineAd.kt . @Composable fun InlineAd() { Text( text = \"Advertisement should be here\" ) } class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) init { viewModelScope.launch { AdService.makeAdvertisement(adRequest).get( onSuccess = { advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 4 . If we have an Advertisement instance, it remains to add a Composable. The sdk_presentation_compose has Ad, which is the presentation layer of your inline ad. File: InlineAd.kt . @Composable fun InlineAd() { val viewModel: InlineAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Ad(it.data) } } } } class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) init { viewModelScope.launch { AdService.makeAdvertisement(adRequest).get( onSuccess = { advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 5 . The last thing we need to do is add our Composable to the MainActivity. File: MainActivity.kt . class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val app = application as App app.adServiceStatus.observe(this) { result -&gt; when(result) { is ResultState.Error -&gt; { showAppError(result.exception) } is ResultState.Success -&gt; { setContent { TutorialAppTheme { InlineAd() } } } } } } private fun showAppError(adError: AdError) { Toast.makeText(this, \"Initialization failed: ${adError.description}\", Toast.LENGTH_LONG).show() } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.0/create-and-display-inline-ads.html#creating-an-inline-ads",
    
    "relUrl": "/5.0.0/create-and-display-inline-ads.html#creating-an-inline-ads"
  },"92": {
    "doc": "Create and display inline ads",
    "title": "Section 2: Defining the size of the advertisement",
    "content": "Our InlineAdViewModel and InlineAd can load and display ads, but how can we understand what size the Ad should be? In this section we will deal with this question. Step 1 . As we already know, Advertisement stores advertising data. Let’s try to get it! We can obtain all possible advertising data using AdMetadata. This is the one we will use to obtain the size data. We are interested in AdMetadata.aspectRatio, which is optional. We have implemented the logic so that in cases where it is not present, we will use the 2:1 ratio. File: InlineAd.kt . @Composable fun InlineAd() { val viewModel: InlineAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { it.data.adMetadata Ad(it.data) } } } } class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f init { viewModelScope.launch { AdService.makeAdvertisement(adRequest).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 2 . Now we can add the AdMetadata.aspectRatio via the Modifier into the Ad. File: InlineAd.kt . @Composable fun InlineAd() { val viewModel: InlineAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { it.data.adMetadata Ad( it.data, modifier = Modifier.aspectRatio(viewModel.aspectRatio) ) } } } } class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f init { viewModelScope.launch { AdService.makeAdvertisement(adRequest).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Now we should see the banner on our device. Congrats! . ",
    "url": "/nextgen-adsdk-android-release/5.0.0/create-and-display-inline-ads.html#section-2-defining-the-size-of-the-advertisement",
    
    "relUrl": "/5.0.0/create-and-display-inline-ads.html#section-2-defining-the-size-of-the-advertisement"
  },"93": {
    "doc": "Create and display interstitial ad",
    "title": "Create and display interstitial ad",
    "content": "A full-screen advertisement that fills the host app’s interface is known as an interstitial ad. In this tutorial we will add an interstitial ad to our application. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.0.0/create-and-display-interstitial-ad.html",
    
    "relUrl": "/5.0.0/create-and-display-interstitial-ad.html"
  },"94": {
    "doc": "Create and display interstitial ad",
    "title": "Section 1: Prepare app for interstitial ad",
    "content": "We want to present the interstitial on a different screen and add navigation buttons for it. Step 1 . Let’s create a new MainScreen file in which we add Navigation and MainScreen. Note: At the moment you will get an error, because we have not created InterstitialScreen yet. File: MainScreen.kt . @Composable fun Navigation() { val navController = rememberNavController() NavHost(navController = navController, startDestination = \"mainScreen\") { composable(\"mainScreen\") { MainScreen(navController) } composable(\"interstitial\") { InterstitialScreen() } } } @Composable fun MainScreen(navController: NavController) { Scaffold( floatingActionButton = { ExtendedFloatingActionButton( onClick = { navController.navigate(\"interstitial\") }, content = { Text(\"Go to Interstitial\") }, ) } ) { innerPadding -&gt; Column( modifier = Modifier .fillMaxSize() .padding(innerPadding), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { InlineAd() Spacer(modifier = Modifier.height(16.dp)) } } } . Step 2 . The next step is to create our future screen for displaying interstitial ads. Create a new InterstitialScreen file and add a screen with a button to it. File: InterstitialScreen.kt . @Composable fun InterstitialScreen() { Box( modifier = Modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { Button( onClick = { }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } } } class InterstitialAdViewModel : ViewModel() { } . ",
    "url": "/nextgen-adsdk-android-release/5.0.0/create-and-display-interstitial-ad.html#section-1-prepare-app-for-interstitial-ad",
    
    "relUrl": "/5.0.0/create-and-display-interstitial-ad.html#section-1-prepare-app-for-interstitial-ad"
  },"95": {
    "doc": "Create and display interstitial ad",
    "title": "Section 2: Creating interstitial advertisements",
    "content": "We have already created an inline Advertisement on a previous chapter. In this section, we will create a interstitial ad for the future presentation. Step 1 . Interstitial ad is created in the same way as inline ads, with one difference – the placementType parameter must be AdPlacementType.INTERSTITIAL. Let’s add the logic for loading the advertisement into InterstitialAdViewModel. We’ll again use ResultState with Advertisement to identify whether the ad was created and loaded successfully. File: InterstitialScreen.kt . @Composable fun InterstitialScreen() { Box( modifier = Modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { Button( onClick = { }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = AdPlacementType.INTERSTITIAL, ).get( onSuccess = { advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 2 . We add the InterstitialAdViewModel to the InterstitialAd. File: InterstitialScreen.kt . @Composable fun InterstitialScreen() { val viewModel: InterstitialAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = AdPlacementType.INTERSTITIAL, ).get( onSuccess = { advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.0/create-and-display-interstitial-ad.html#section-2-creating-interstitial-advertisements",
    
    "relUrl": "/5.0.0/create-and-display-interstitial-ad.html#section-2-creating-interstitial-advertisements"
  },"96": {
    "doc": "Create and display interstitial ad",
    "title": "Section 3: Presenting interstitial ad",
    "content": "We learnt how to create interstitial advertisement. Now, we are ready to present our interstitial ad. In this section, we will display interstitial ad in our app. Step 1 . Our AdSDK provides AdInterstitialState to control the state of the interstitial ad presentation. Add a property for this in the InterstitialAdViewModel. File: InterstitialScreen.kt . fun InterstitialScreen() { val viewModel: InterstitialAdViewModel = viewModel() viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisement = mutableStateOf&lt;Advertisement?&gt;(null) lateinit var interstitialState: AdInterstitialState init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = PlacementType.INTERSTITIAL, adEventListener = adEventListener ).get( onSuccess = { interstitialState = AdInterstitialState(it, this) advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"AdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 2 . The next step will be adding a presentation layer. To display interstitial ads, SDK has an Interstitial composable. Add it to your InterstitialScreen and pass the state value from the InterstitialAdViewModel. File: InterstitialScreen.kt . @Composable fun InterstitialScreen(modifier: Modifier) { val viewModel: InterstitialAdViewModel = viewModel() Box( modifier = modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } Interstitial(viewModel.interstitialState) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisement = mutableStateOf&lt;Advertisement?&gt;(null) lateinit var interstitialState: AdInterstitialState init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = PlacementType.INTERSTITIAL ).get( onSuccess = { interstitialState = AdInterstitialState(it, this) advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 3 . To show an interstitial ad, you can use the AdInterstitialState.presentIfLoaded method. Note: If you don’t use the Advertisement.reload method, your Advertisement object will always be loaded, which means that the ad will be presented to the user immediately when AdInterstitialState.presentIfLoaded method called. Otherwise, the ad will be presented immediately after loading. File: InterstitialScreen.kt . fun InterstitialScreen() { val viewModel: InterstitialAdViewModel = viewModel() Box( modifier = modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { viewModel.interstitialState.presentIfLoaded() }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } Interstitial(viewModel.interstitialState) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisement = mutableStateOf&lt;Advertisement?&gt;(null) lateinit var interstitialState: AdInterstitialState init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = PlacementType.INTERSTITIAL ).get( onSuccess = { interstitialState = AdInterstitialState(it, this) advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.0/create-and-display-interstitial-ad.html#section-3-presenting-interstitial-ad",
    
    "relUrl": "/5.0.0/create-and-display-interstitial-ad.html#section-3-presenting-interstitial-ad"
  },"97": {
    "doc": "Create and display interstitial ad",
    "title": "Section 3: Hiding interstitial ad",
    "content": "We managed to successfully show the ad, but we would like to be able to close interstitial. In this section, we implement this logic. Step 1 . Let’s continue the development in our InterstitialScreen file. We could hide the ad by simply calling the AdInterstitialState.hide method, but we don’t know when to call it. In order to understand when ad should be hidden, we need to use AdEventListener. We will explain the AdEventListener in more detail in the next chapter. Let’s create an adEventListener in InterstitialAdViewModel, and then pass it to the AdService.makeAdvertisement. File: InterstitialScreen.kt . fun InterstitialScreen() { val viewModel: InterstitialAdViewModel = viewModel() Box( modifier = modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { viewModel.interstitialState.presentIfLoaded() }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } Interstitial(viewModel.interstitialState) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) lateinit var interstitialState: AdInterstitialState val adEventListener: AdEventListener = object : AdEventListener { override fun eventProcessed(adEventType: AdEventType, adMetadata: AdMetadata) { Log.d(\"InterstitialAdViewModel events\", \"Collected EVENT - $adEventType\") } } init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = AdPlacementType.INTERSTITIAL, adEventListener = adEventListener ).get( onSuccess = { interstitialState = AdInterstitialState(it, this) advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 2 . The event we are interested in is AdEventType.UnloadRequest. We need to observe it to make sure that the ad is hidden when it is needed. Note: You should not change the state from presented to hidden without using AdEventType.UnloadRequest event. The advert itself knows when it needs to be hidden and asks you to hide it using this method. File: InterstitialScreen.kt . fun InterstitialScreen() { val viewModel: InterstitialAdViewModel = viewModel() Box( modifier = modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { viewModel.advertisementState.value?.let { when(it) { is ResultState.Error -&gt; { Text(it.exception.description) } is ResultState.Success -&gt; { Button( onClick = { viewModel.interstitialState.presentIfLoaded() }, modifier = Modifier .align(Alignment.BottomCenter) .padding(26.dp) ) { Text( text = \"Show Interstitial\", ) } Interstitial(viewModel.interstitialState) } } } } } class InterstitialAdViewModel : ViewModel() { private val adRequest = AdRequest(\"5192923\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) lateinit var interstitialState: AdInterstitialState val adEventListener: AdEventListener = object : AdEventListener { override fun eventProcessed(adEventType: AdEventType, adMetadata: AdMetadata) { Log.d(\"InterstitialAdViewModel events\", \"Collected EVENT - $adEventType\") if (adEventType == AdEventType.UnloadRequest) { interstitialState.hide() } } } init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, placementType = AdPlacementType.INTERSTITIAL, adEventListener= adEventListener ).get( onSuccess = { interstitialState = AdInterstitialState(it, this) advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InterstitialAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Now, if you launch the app, you should see an interstitial ad. ",
    "url": "/nextgen-adsdk-android-release/5.0.0/create-and-display-interstitial-ad.html#section-3-hiding-interstitial-ad",
    
    "relUrl": "/5.0.0/create-and-display-interstitial-ad.html#section-3-hiding-interstitial-ad"
  },"98": {
    "doc": "First steps for working with AdSDK",
    "title": "First steps for working with AdSDK",
    "content": "This tutorial will guide you through the first steps of working with the AdSDK - creating an AdService. You can download this this project which already implements all the steps of this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.0.0/first-steps.html",
    
    "relUrl": "/5.0.0/first-steps.html"
  },"99": {
    "doc": "First steps for working with AdSDK",
    "title": "Creating an AdService",
    "content": "Creating and configuring an AdService for later ad creation and loading. Step 1 . Create a new Android project and remove any unnecessary code. Make sure you have added the correct packages from the readme. Step 2 . The entry point into the SDK is the AdService class. This is the first thing we should create, as it will be used to generate advertisements in the future. For an easy start, we will simply configure the AdService in the App class. We create a file called App and add it to the MainActivity as well. File: App.kt . class App : Application() { override fun onCreate() { super.onCreate() } } . File: MainActivity.kt . class MainActivity : ComponentActivity() { override fun onCreate() { super.onCreate() val app = application as App // ... } } // ... Remember to add this class as an entry point, so add it to the application in your Manifest. File: AndroidManifest.xml . android:name=\"com.adition.tutorial_app.App\" . Step 3 . Before using the AdService, we should first configure it. To do this, we will use the AdService.configure method in the App class. The only mandatory parameter when configuring an AdService is AdService.networkId. The network identifier is the identifier of your advertising account. The configure method is suspendable, so we should use the coroutine. To do this, we need to create a coroutineScope and add this code to the onCreate function of the App class. class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) override fun onCreate() { super.onCreate() coroutineScope.launch { AdService.configure(\"1800\", applicationContext) } } } . Step 4 . AdService.configure returns AdResult, which is our custom AdSDK implementation of Kotlin’s Result. AdResult contains AdError the only type of error which the SDK supports. We can use AdResult to check that the AdService has been successfully configured and initialised. Let us add a ResultState class to monitor the status. File: ResultState . sealed class ResultState&lt;out T&gt; { data class Success&lt;out T&gt;(val data: T) : ResultState&lt;T&gt;() data class Error&lt;T&gt;(val exception: AdError) : ResultState&lt;T&gt;() } . We can use this status in the App file. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure(\"1800\", applicationContext) initResult.get( onSuccess = { adServiceStatus.value = ResultState.Success(Unit) }, onError = { adServiceStatus.value = ResultState.Error(it) } ) } } } . Step 5 . We can now use adServiceStatus in the onCreate function of the MainActivity. File: MainActivity.kt . class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val app = application as App app.adServiceStatus.observe(this) { result -&gt; when(result) { is ResultState.Error -&gt; { // We will handle in the next step. } is ResultState.Success -&gt; { setContent { TutorialAppTheme { Greeting(name = \"AdSDK\") } } } } } } } // ... Step 6 . We could react on all the different error cases AdError contains. To keeps it easy we just show the description of the AdError. File: MainActivity.kt . class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val app = application as App app.adServiceStatus.observe(this) { result -&gt; when(result) { is ResultState.Error -&gt; { showAppError(result.exception) } is ResultState.Success -&gt; { setContent { TutorialAppTheme { Greeting(name = \"AdSDK\") } } } } } } private fun showAppError(adError: AdError) { Toast.makeText(this, \"Initialization failed: ${adError.description}\", Toast.LENGTH_LONG).show() } } // ... Now, if you’ve done everything right, you should see the greeting message when you launch the app. This completes the AdService configuration, congratulations! . ",
    "url": "/nextgen-adsdk-android-release/5.0.0/first-steps.html#creating-an-adservice",
    
    "relUrl": "/5.0.0/first-steps.html#creating-an-adservice"
  },"100": {
    "doc": "Global request parameters",
    "title": "Global request parameters",
    "content": "We already know how to create and perform AdRequest, TagRequest, and TrackingRequest. However, each of them can have additional parameters, which are called global parameters because they are specified globally for all requests. The SDK provides the ability to add global parameters once so that you don’t have to copy them when creating each request. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.0.0/global-request-parameters.html",
    
    "relUrl": "/5.0.0/global-request-parameters.html"
  },"101": {
    "doc": "Global request parameters",
    "title": "Modifying global parameters",
    "content": "In this section we’ll configure the AdRequestGlobalParameters and TrackingGlobalParameters for each AdRequest, TagRequest, and TrackingRequest we have in our application. We will also look at the possibility of removing global parameters. Step 1 . We can add global parameters using the AdService. The AdService has a AdService.setAdRequestGlobalParameter method which we will use to set the gdpr parameter for each AdRequest. Add the global parameters to the App class and a function addGlobalParameters(). Note: If we want to remove a ad request global parameter we could use the AdService.removeAdRequestGlobalParameter method. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure(\"1800\", applicationContext) initResult.get( onSuccess = { addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } private fun addGlobalParameters() { val gdpr = GDPR(consent = \"gdprconsentexample\", isRulesEnabled = true) AdService.setAdRequestGlobalParameter(AdRequestGlobalParameters::gdpr, gdpr) // AdService.removeAdRequestGlobalParameter(AdRequestGlobalParameters::gdpr) } } . Step 2 . We can also modify TrackingGlobalParameters for each TagRequest and TrackingRequest using the AdService.setTrackingGlobalParameter method. Let’s add this code to the addGlobalParameters method. Note: If we want to remove a tracking global parameter we could use the AdService.removeTrackingGlobalParameter method. File: App.kt . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) val adServiceStatus = MutableLiveData&lt;ResultState&lt;Unit&gt;&gt;() override fun onCreate() { super.onCreate() coroutineScope.launch { val initResult = AdService.configure(\"1800\", applicationContext) initResult.get( onSuccess = { addGlobalParameters() adServiceStatus.postValue(ResultState.Success(Unit)) }, onError = { adServiceStatus.postValue(ResultState.Error(it)) } ) } } private fun addGlobalParameters() { val gdpr = GDPR(consent = \"gdprconsentexample\", isRulesEnabled = true) AdService.setAdRequestGlobalParameter(AdRequestGlobalParameters::gdpr, gdpr) // AdService.removeAdRequestGlobalParameter(AdRequestGlobalParameters::gdpr) AdService.setTrackingGlobalParameter(TrackingGlobalParameters::gdpr, gdpr) // AdService.removeTrackingGlobalParameter(TrackingGlobalParameters::gdpr) } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.0/global-request-parameters.html#modifying-global-parameters",
    
    "relUrl": "/5.0.0/global-request-parameters.html#modifying-global-parameters"
  },"102": {
    "doc": "Handling the ad events",
    "title": "Monitor and process ad-related events",
    "content": "Advertisement do a lot of work under the hood and can send messages about them to the app. In turn, you can monitor and react to it in some way. In this tutorial, we’ll look at what events are handled by Advertisement and how we can interact with them. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.0.0/handling-the-ad-events.html#monitor-and-process-ad-related-events",
    
    "relUrl": "/5.0.0/handling-the-ad-events.html#monitor-and-process-ad-related-events"
  },"103": {
    "doc": "Handling the ad events",
    "title": "Section 1: Observing events",
    "content": "We will use the AdEventListener to observe the AdEventType. Since we used the AdEventListener in the interstitial tutorial, this time we will add it to the other InlineAdViewModel to observe all the AdEventType. Step 1 . Lets add an AdEventListener to the InlineAdViewModel and pass it to the AdService.makeAdvertisement. File: InlineAd.kt . // ... class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f val adEventListener: AdEventListener = object : AdEventListener { override fun eventProcessed(adEventType: AdEventType, adMetadata: AdMetadata) { Log.d(\"InlineAdViewModel events\", \"Collected EVENT - $adEventType\") } } init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, adEventListener = adEventListener ).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 2 . Here we can see the different AdEventType we can observe: . | Impression | Viewable | Tap | UnloadRequest | RendererMessageReceived | CustomTrackingEvent | . Now let us add all possible AdEventType to the AdEventListener.eventProcessed method of the adEventListener. File: InlineAd.kt . // ... class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f val adEventListener: AdEventListener = object : AdEventListener { override fun eventProcessed(adEventType: AdEventType, adMetadata: AdMetadata) { Log.d(\"InlineAdViewModel events\", \"Collected EVENT - $adEventType\") when (adEventType) { is AdEventType.Impression -&gt; {} is AdEventType.RendererMessageReceived -&gt; {} is AdEventType.CustomTrackingEvent -&gt; {} is AdEventType.Tap -&gt; {} is AdEventType.UnloadRequest -&gt; {} is AdEventType.Viewable -&gt; {} } } } init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, adEventListener = adEventListener ).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . Step 3 . We have already seen UnloadRequest in the interstitial example. Lets look at the Viewable event and monitor each VisibilityPercentage in this example. Note: Impression and Viewable can only be observed if they are configured in the ad server backend. Otherwise they are not part of the ad response. File: InlineAd.kt . // ... class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f val adEventListener: AdEventListener = object : AdEventListener { override fun eventProcessed(adEventType: AdEventType, adMetadata: AdMetadata) { Log.d(\"InlineAdViewModel events\", \"Collected EVENT - $adEventType\") when (adEventType) { is AdEventType.Impression -&gt; {} is AdEventType.RendererMessageReceived -&gt; {} is AdEventType.CustomTrackingEvent -&gt; {} is AdEventType.Tap -&gt; {} is AdEventType.UnloadRequest -&gt; {} is AdEventType.Viewable -&gt; { when (adEventType.percentage) { AdEventType.VisibilityPercentage.ONE -&gt; { Log.d(\"InlineAdViewModel events\", \"1% of my ads are now visible on the screen.\") } AdEventType.VisibilityPercentage.FIFTY -&gt; { Log.d(\"InlineAdViewModel events\", \"50% of my ads are now visible on the screen.\") } AdEventType.VisibilityPercentage.ONE_HUNDRED -&gt; { Log.d(\"InlineAdViewModel events\", \"100% of my ads are now visible on the screen.\") } } } } } } init { viewModelScope.launch { AdService.makeAdvertisement( adRequest, adEventListener = adEventListener ).get( onSuccess = { aspectRatio = it.adMetadata?.aspectRatio ?: aspectRatio advertisementState.value = ResultState.Success(it) }, onError = { Log.e(\"InlineAdViewModel\", \"Failed makeAdvertisement: ${it.description}\") advertisementState.value = ResultState.Error(it) } ) } } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.0/handling-the-ad-events.html#section-1-observing-events",
    
    "relUrl": "/5.0.0/handling-the-ad-events.html#section-1-observing-events"
  },"104": {
    "doc": "Handling the ad events",
    "title": "Handling the ad events",
    "content": " ",
    "url": "/nextgen-adsdk-android-release/5.0.0/handling-the-ad-events.html",
    
    "relUrl": "/5.0.0/handling-the-ad-events.html"
  },"105": {
    "doc": "Meet nextgen AdSDK",
    "title": "Meet nextgen AdSDK",
    "content": "Manage, display, and create your custom advertisements on Android using cutting-edge technologies such as Jetpack Compose and Coroutines based on the AdSDK. ",
    "url": "/nextgen-adsdk-android-release/5.0.0/meet-adsdk.html",
    
    "relUrl": "/5.0.0/meet-adsdk.html"
  },"106": {
    "doc": "Meet nextgen AdSDK",
    "title": "Chapter 1",
    "content": "Working with the built-in capabilities of the SDK. In this chapter, you will learn how to create, display, and manage advertisements using AdSDK. | First steps for working with AdSDK | Create and display inline ads | Create and display interstitial ad | Handling the ad events | User tagging and conversion tracking | Global request parameters | AdSDK Cache Management | . ",
    "url": "/nextgen-adsdk-android-release/5.0.0/meet-adsdk.html#chapter-1",
    
    "relUrl": "/5.0.0/meet-adsdk.html#chapter-1"
  },"107": {
    "doc": "User tagging and conversion tracking",
    "title": "User tagging and conversion tracking",
    "content": "AdSDK provides powerful functionality for user tagging and conversion tracking. In this tutorial we will explore this functionality. We will continue to build the app, so be sure to follow all the previous tutorials. You can download this project which has already implemented all steps from this tutorial. ",
    "url": "/nextgen-adsdk-android-release/5.0.0/user-tagging-conversion-tracking.html",
    
    "relUrl": "/5.0.0/user-tagging-conversion-tracking.html"
  },"108": {
    "doc": "User tagging and conversion tracking",
    "title": "Section 1: User tagging",
    "content": "The SDK provides functionality to put a user identifier, such as a cookie id, into a retargeting segment (to tag a user). This allows advertisers to create a segment of users with certain interests or affinities, and to re-advertise to this segment (retargeting). In this section, we will look at how to perform a tag request using the AdSDK. Step 1 . To tag a user we need a TagRequest, that describes the request for tagging and consists of tags with a key, a subkey, and a value. We keep it simple and just add a tagUser() method to the InlineAdViewModel and create a TagRequest with one TagRequest.Tag. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) } } . Step 2 . We pass the TagRequest to the AdService.tagUser. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request) } } . Step 3 . The AdService.tagUser method returns an AdResult, so let’s log the result. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } } . Step 4 . To make sure the user is tagged before we call AdService.makeAdvertisement, we will use the coroutines async method. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { val tagUser = async { tagUser() } tagUser.await() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.0/user-tagging-conversion-tracking.html#section-1-user-tagging",
    
    "relUrl": "/5.0.0/user-tagging-conversion-tracking.html#section-1-user-tagging"
  },"109": {
    "doc": "User tagging and conversion tracking",
    "title": "Section 2: Conversion tracking",
    "content": "The SDK allows you to track conversions. This is useful for advertisers as conversion details are available in post tracking reports via the ad server. In this section we will look at how to perform a tracking request using the AdSDK. Step 1 . A conversion tracking request is described using TrackingRequest. We add a conversionTracking() function to the InlineAdViewModel . File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() conversionTracking() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } private suspend fun conversionTracking() { val request = TrackingRequest( landingPageId = 1, trackingSpotId = 1, orderId = \"orderId\", itemNumber = \"itemNumber\", description = \"description\", quantity = 1, price = 19.99f, total = 39.98f ) } } . Step 2 . We pass the TrackingRequest to the AdService.trackingRequest. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() conversionTracking() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } private suspend fun conversionTracking() { val request = TrackingRequest( landingPageId = 1, trackingSpotId = 1, orderId = \"orderId\", itemNumber = \"itemNumber\", description = \"description\", quantity = 1, price = 19.99f, total = 39.98f ) AdService.trackingRequest(request) } } . Step 3 . The AdService.trackingRequest method also returns an AdResult, so let’s log the result. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { tagUser() conversionTracking() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } private suspend fun conversionTracking() { val request = TrackingRequest( landingPageId = 1, trackingSpotId = 1, orderId = \"orderId\", itemNumber = \"itemNumber\", description = \"description\", quantity = 1, price = 19.99f, total = 39.98f ) AdService.trackingRequest(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"Conversion tracking was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed conversion tracking: ${it.description}\") } ) } } . Step 4 . To ensure that the conversion tracking is done before we call the AdService.makeAdvertisement method, we will use the coroutines async method. File: InlineAd.kt . class InlineAdViewModel: ViewModel() { private val adRequest = AdRequest(\"4810915\") var advertisementState = mutableStateOf&lt;ResultState&lt;Advertisement&gt;?&gt;(null) var aspectRatio = 2f // ... init { viewModelScope.launch { val tagUser = async { tagUser() } val conversionTracking = async { conversionTracking() } tagUser.await() conversionTracking.await() // ... } } private suspend fun tagUser() { val tags = listOf(TagRequest.Tag(\"segments\", \"category\", \"home\")) val request = TagRequest(tags) AdService.tagUser(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"User tagging was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed user tagging: ${it.description}\") } ) } private suspend fun conversionTracking() { val request = TrackingRequest( landingPageId = 1, trackingSpotId = 1, orderId = \"orderId\", itemNumber = \"itemNumber\", description = \"description\", quantity = 1, price = 19.99f, total = 39.98f ) AdService.trackingRequest(request).get( onSuccess = { Log.d(\"InlineAdViewModel\", \"Conversion tracking was successful\") }, onError = { Log.d(\"InlineAdViewModel\", \"Failed conversion tracking: ${it.description}\") } ) } } . ",
    "url": "/nextgen-adsdk-android-release/5.0.0/user-tagging-conversion-tracking.html#section-2-conversion-tracking",
    
    "relUrl": "/5.0.0/user-tagging-conversion-tracking.html#section-2-conversion-tracking"
  },"110": {
    "doc": "Create and display inline ads",
    "title": "Create and display inline ads",
    "content": "This tutorial will guide you through creating a simple application that can load and display a list of ads. ",
    "url": "/nextgen-adsdk-android-release/4.6.0/create-and-display-inline-ads.html",
    
    "relUrl": "/4.6.0/create-and-display-inline-ads.html"
  },"111": {
    "doc": "Create and display inline ads",
    "title": "Section 1: Getting started with AdSDK",
    "content": "Add and configure the AdSDK to create and load ads. Step 1 . Let’s create a new Android project and remove all unnecessary code. Make sure you have added the correct packages from the readme. Step 2 . The entry point into the SDK is the AdService class. To make an easy start we just initialize the AdService in the onCreate method of the MainActivity. This is the first thing we should create, as it will be used to generate advertisements in the future. To do this, we will add this code: . coroutineScope.launch { val isSuccess = AdService.init(\"1800\", applicationContext, EventHandler()) Log.d(\"AdSDK\", \"Init is success: $isSuccess\") } . Lets create an App file and class to add the AdService initialisation. To do this, create this class and add the code snippet from above. The only mandatory parameter when creating AdService is the networkId. Network ID is the ID of your advertising account. Our Code should now look like this: . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) override fun onCreate() { super.onCreate() coroutineScope.launch { val isSuccess = AdService.init(\"1800\", applicationContext, EventHandler()) Log.d(\"App\", \"Init is success: $isSuccess\") } } } . Remember to add this class as an entry point, so add it to the application in your `Manifest: . android:name=\"com.adition.adsdk.App\" . Step 3 . The next step will be to create a composable, which we will display upon successful creation of AdService. On this composable, we will be creating and displaying our advertisement. @Composable fun AdView() { Text( text = \"Advertisement should be here\" ) } . Now we can call this in our composable in the MainActivity. class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { AdsdkdemoappandroidTheme { AdView() } } } } . ",
    "url": "/nextgen-adsdk-android-release/4.6.0/create-and-display-inline-ads.html#section-1-getting-started-with-adsdk",
    
    "relUrl": "/4.6.0/create-and-display-inline-ads.html#section-1-getting-started-with-adsdk"
  },"112": {
    "doc": "Create and display inline ads",
    "title": "Section 2: Loading and displaying advertisements",
    "content": "Step 1 . Before we create an Advertisement object we want to add a ViewModel: . class MainViewModel: ViewModel() { } . Step 2 . To create an Advertisement object, you need to specify parameters, two of which are required: . | contentId or learningTag | adTypes We’re going to use the contentId because it’s used more often than the learningTag. Content Unit is the unique ID of your advertising space and for ad type we use AdComposeRenderRegistry.getAllRendererNames() this will enable all available adTypes. Another important parameter is placementType. In this case, we need AdPlacementType.INLINE, which is the default, so we ignore it. All possible parameters can be found in the AdvertisementParameters documentation. | . class MainViewModel: ViewModel() { var ad: Advertisement = Advertisement( \"4810915\", AdComposeRenderRegistry.getAllRendererNames(), ) } . We can now load this advertisement using loadAdvertisement: . class MainViewModel: ViewModel() { var ad: Advertisement = Advertisement( \"4810915\", AdComposeRenderRegistry.getAllRendererNames(), ) init { viewModelScope.launch { ad.loadAdvertisement() } } } . Step 3 . We can pass this Advertisement now to the rememberAdState composable. The rememberAdState creates the AdState which we will use later. There are multiple versions of the rememberAdState. For example we could pass a content unit directly to the rememberAdState and it would create the Advertisement for us. @Composable fun AdView(viewModel: MainViewModel) { val adState = rememberAdState(advertisement = viewModel.ad) } . Step 4 . We can pass the AdState to Ad composable. The Ad is the main composable used to display the ad with provided adState. @Composable fun AdView() { val adState = rememberAdState(advertisement = viewModel.ad) Ad(adState = adState, modifier = Modifier) } . How our MainActivity should look like: . class MainActivity : ComponentActivity() { private val viewModel by viewModels&lt;MainViewModel&gt;() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { AdsdkdemoappandroidTheme { AdView(viewModel) } } } } @Composable fun AdView(viewModel: MainViewModel) { val adState = rememberAdState(advertisement = viewModel.ad) Ad(adState = adState, modifier = Modifier) } . Now we should see the Banner on our device: . ",
    "url": "/nextgen-adsdk-android-release/4.6.0/create-and-display-inline-ads.html#section-2-loading-and-displaying-advertisements",
    
    "relUrl": "/4.6.0/create-and-display-inline-ads.html#section-2-loading-and-displaying-advertisements"
  },"113": {
    "doc": "Create and display interstitial ad section",
    "title": "Create and display interstitial ad section",
    "content": "A full-screen advertisement that fills the host app’s interface is known as an interstitial ad. In this tutorial we are going to add interstitial ad into our application. ",
    "url": "/nextgen-adsdk-android-release/4.6.0/create-and-display-interstitial-ad-section.html",
    
    "relUrl": "/4.6.0/create-and-display-interstitial-ad-section.html"
  },"114": {
    "doc": "Create and display interstitial ad section",
    "title": "Section 1: Interstitial Ad Object",
    "content": "In this section we will create an interstitial Advertisement object. Step 1 . Lets change the structure of our AdsdkdemoappandroidTheme composable. We create a MainContent composable and move the AdView call over there. AdsdkdemoappandroidTheme { MainContent(viewModel) } . @Composable fun MainContent(viewModel: MainViewModel) { Box(modifier = Modifier.fillMaxSize()) { AdView(viewModel) } } . Step 2 . To create a interstitial banner we use the Advertisement class again. Only difference this time we add the different placementType INTERSTITIAL We add the interstitialAd in the MainViewModel. var interstitialAd: Advertisement = Advertisement( \"5192923\", AdComposeRenderRegistry.getAllRendererNames(), placementType = PlacementType.INTERSTITIAL ) . Step 3 . We can add now a composable for the fullscreen interstitial. @Composable fun ShowInterstitial(viewModel: MainViewModel) { var adState = rememberAdState(viewModel.interstitialAd) Box ( contentAlignment = Alignment.Center, modifier = Modifier.fillMaxSize() ){ Ad(adState = adState) } } . Step 4 . To trigger the interstitial composable we will use a button which we add at the bottom. @Composable fun BottomButton(onClick: () -&gt; Unit) { Box(modifier = Modifier.fillMaxSize()) { Button( onClick = onClick, modifier = Modifier .align(Alignment.BottomCenter) .padding(bottom = 16.dp) ) { Text(\"Show interstitial\") } } } . Step 5 . To control the interstitial presentation we will use a state value, which will be set to true if we click on the button. val showInterstitialComposable = remember { mutableStateOf(false) } BottomButton( onClick = { showInterstitialComposable.value = !showInterstitialComposable.value } ) . Step 6 . Now lets structure this all together in our MainContent composable we created above. @Composable fun MainContent(viewModel: MainViewModel) { val showInterstitialComposable = remember { mutableStateOf(false) } Box(modifier = Modifier.fillMaxSize()) { AdView(viewModel) BottomButton( onClick = { showInterstitialComposable.value = !showInterstitialComposable.value } ) if (showInterstitialComposable.value) { ShowInterstitial(viewModel) } } } . ",
    "url": "/nextgen-adsdk-android-release/4.6.0/create-and-display-interstitial-ad-section.html#section-1-interstitial-ad-object",
    
    "relUrl": "/4.6.0/create-and-display-interstitial-ad-section.html#section-1-interstitial-ad-object"
  },"115": {
    "doc": "Defining the size of the advertisement",
    "title": "Defining the size of the advertisement",
    "content": "This tutorial will teach you how to define the size of the advertisement, taking into account the aspect ratio parameter. In it, we will continue the development of the application we started in the previous section. ",
    "url": "/nextgen-adsdk-android-release/4.6.0/defining-the-size-of-the-advertisement.html",
    
    "relUrl": "/4.6.0/defining-the-size-of-the-advertisement.html"
  },"116": {
    "doc": "Defining the size of the advertisement",
    "title": "Section 1: Defining the size of the advertisement",
    "content": "Step 1 . For the the size of the advertisement we can use AdMetadata. From this object we can get the basic information after the advertising content has been loaded from the server. We will use the aspectRatio from the adMetadata. So let’s get the adMetadata from adState: . val aspectRatio = adState.adMetaData?.aspectRatio ?: 2F . Since aspectRatio is optional, we use the default value of 2:1 in this project. Step 2 . Now we can add the aspectRatio via the Modifier into the Ad composable. @Composable fun AdView(viewModel: MainViewModel) { val adState = rememberAdState(advertisement = viewModel.ad) val aspectRatio = adState.adMetaData?.aspectRatio ?: 2F Ad( adState = adState, modifier = Modifier .aspectRatio(aspectRatio) ) when (val state = adState?.state) { is AdState.State.Error -&gt; { when(state.adException.adError) { AdError.DECODING -&gt; { Log.e(\"MainActivity\", \"Decoding error: ${state.adException.exception}\") } } } is AdState.State.Loading -&gt; { // We are Caching. } is AdState.State.Caching -&gt; { // We are Caching. } is AdState.State.AdReadyToDisplay -&gt; { // Ad is ready and will be displayed. } else -&gt; {} } } . Note: In this case, we are requesting the adMetaData before the ad is successfully loaded, but when the ad is successfully loaded, the composable will be updated and we will get this data. In a real-world scenario, you would most likely use a ViewModel‘ or other state management mechanism where you could implement logic to ensure that the adMetaData’ is only requested when the ad is already loaded. ",
    "url": "/nextgen-adsdk-android-release/4.6.0/defining-the-size-of-the-advertisement.html#section-1-defining-the-size-of-the-advertisement",
    
    "relUrl": "/4.6.0/defining-the-size-of-the-advertisement.html#section-1-defining-the-size-of-the-advertisement"
  },"117": {
    "doc": "Global ad request parameters",
    "title": "Global ad request parameters",
    "content": "An ad request can have additional parameters beyond those you pass during initialization. These additional parameters are global for all ad requests. The SDK provides the ability to add global parameters once so that you don’t have to copy them when creating each ad request. ",
    "url": "/nextgen-adsdk-android-release/4.6.0/global-adRequest-parameters.html",
    
    "relUrl": "/4.6.0/global-adRequest-parameters.html"
  },"118": {
    "doc": "Global ad request parameters",
    "title": "Section 1: Modifying global parameters",
    "content": "In this section, we’ll configure the gdpr parameter for each ad request that we have in our app. In addition, we will review the possibility of removing global parameters. You can configure not only GDPR but also other parameters. You can find a list of all global parameters in the AdRequestGlobalParameters documentation. Step 1 . We can add global parameters via the AdService. The AdService has setAdRequestGlobalParameter method which we use to set the gdpr parameter. AdService.getInstance().setAdRequestGlobalParameter( AdRequestGlobalParameters::gdpr, GDPR(consent = \"gdprconsentexample\", isRulesEnabled = true) ) . Step 2 . To make it easy we will add the global parameters in the App class. class App : Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) override fun onCreate() { super.onCreate() coroutineScope.launch { val isSuccess = AdService.init(\"1800\", applicationContext, EventHandler()) Log.d(\"App\", \"Init is success: $isSuccess\") launch { AdService.getInstance().eventHandler?.events?.collect { event -&gt; Log.d(\"Events\", \"Collected EVENT - $event\") when (event.eventType) { is EventType.Tap -&gt; { // Ad got tapped. } else -&gt; {} } } } launch { AdService.getInstance().setAdRequestGlobalParameter( AdRequestGlobalParameters::gdpr, GDPR(consent = \"gdprconsentexample\", isRulesEnabled = true) ) } } } override fun onTerminate() { super.onTerminate() coroutineScope.cancel() } } . Step 3 . If we want to remove an global parameter we could use the removeAdRequestGlobalParameter method. AdService.getInstance().removeAdRequestGlobalParameter( AdRequestGlobalParameters::gdpr ) . ",
    "url": "/nextgen-adsdk-android-release/4.6.0/global-adRequest-parameters.html#section-1-modifying-global-parameters",
    
    "relUrl": "/4.6.0/global-adRequest-parameters.html#section-1-modifying-global-parameters"
  },"119": {
    "doc": "Handling the state and events of advertising",
    "title": "Handling the state and events",
    "content": "This tutorial will help you observe and respond to changes in the state and events. In it, we will continue the development of the application we started in the previous section. ",
    "url": "/nextgen-adsdk-android-release/4.6.0/handling-the-state-and-events-of-advertising.html#handling-the-state-and-events",
    
    "relUrl": "/4.6.0/handling-the-state-and-events-of-advertising.html#handling-the-state-and-events"
  },"120": {
    "doc": "Handling the state and events of advertising",
    "title": "Section 1: Observing the states",
    "content": "When we talk about state we mean the lifecycle state of the Ads composable. Step 1 . The state of an Ad is called AdState. This is an example of how we can observe the AdState: . when (val state = adState?.state) { is AdState.State.Error -&gt; { // We have an error. } is AdState.State.Loading -&gt; { // We are Caching. } is AdState.State.Caching -&gt; { // We are Caching. } is AdState.State.AdReadyToDisplay -&gt; { // Ad is ready and will be displayed. } else -&gt; {} } . Here we can see the different ad states we can observe: . | Error | Loading | Caching | ",
    "url": "/nextgen-adsdk-android-release/4.6.0/handling-the-state-and-events-of-advertising.html#section-1-observing-the-states",
    
    "relUrl": "/4.6.0/handling-the-state-and-events-of-advertising.html#section-1-observing-the-states"
  },"121": {
    "doc": "Handling the state and events of advertising",
    "title": "AdReadyToDisplay",
    "content": "Step 2 . Let’s add the code snippet from above to our AdView example: . @Composable fun AdView() { val adState = rememberAdState(advertisement = viewModel.ad) Ad(adState = adState, modifier = Modifier) when (val state = adState?.state) { is AdState.State.Error -&gt; { // We have an error. } is AdState.State.Loading -&gt; { // We are Caching. } is AdState.State.Caching -&gt; { // We are Caching. } is AdState.State.AdReadyToDisplay -&gt; { // Ad is ready and will be displayed and we could additional work } else -&gt; {} } } . We are able now to act accordingly to each AdState state. | . ",
    "url": "/nextgen-adsdk-android-release/4.6.0/handling-the-state-and-events-of-advertising.html#adreadytodisplay",
    
    "relUrl": "/4.6.0/handling-the-state-and-events-of-advertising.html#adreadytodisplay"
  },"122": {
    "doc": "Handling the state and events of advertising",
    "title": "Section 2: Handling errors during the loading and decoding",
    "content": "Sometimes it’s important for an app to be able to handle errors correctly. With the help of AdError, you can catch a specific error and implement the logic for handling it the way you need. Step 1 . We can observe errors in the AdSDK with AdException. An AdException holds the exception itself and the type of the error via AdError. With AdError we can observe different error types. For example lets catch a decoding error. when(state.adException.adError) { AdError.DECODING -&gt; { // Act accordingly e.g. repeat the request. } } . Step 2 . You can catch a number of different error types, just check AdError. Let’s just log the error and have a look how our composable should look like. @Composable fun AdView(viewModel: MainViewModel) { val adState = rememberAdState(advertisement = viewModel.ad) Ad(adState = adState, modifier = Modifier) when (val state = adState?.state) { is AdState.State.Error -&gt; { when(state.adException.adError) { AdError.DECODING -&gt; { Log.e(\"MainActivity\", \"Decoding error: ${state.adException.exception}\") } } } is AdState.State.Loading -&gt; { // We are Caching. } is AdState.State.Caching -&gt; { // We are Caching. } is AdState.State.AdReadyToDisplay -&gt; { // Ad is ready and will be displayed. } else -&gt; {} } } . ",
    "url": "/nextgen-adsdk-android-release/4.6.0/handling-the-state-and-events-of-advertising.html#section-2-handling-errors-during-the-loading-and-decoding",
    
    "relUrl": "/4.6.0/handling-the-state-and-events-of-advertising.html#section-2-handling-errors-during-the-loading-and-decoding"
  },"123": {
    "doc": "Handling the state and events of advertising",
    "title": "Section 3: Observing the advertising events",
    "content": "Observe the advertising events to respond to them in the application. The SDK can send many events related to advertisements, like impressions, visibility percentages and tap events. Step 1 . With the use of the AdService we can collect all ad Event. AdService.getInstance().eventHandler?.events?.collect { event -&gt; Log.d(\"Events\", \"Collected EVENT - $event\") } . Step 2 . Start the event observing before the composable loads if you want to make sure you get every event. For example, we could add it in the App class. class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) override fun onCreate() { super.onCreate() coroutineScope.launch { val isSuccess = AdService.init(\"1800\", applicationContext, EventHandler()) Log.d(\"App\", \"Init is success: $isSuccess\") launch { AdService.getInstance().eventHandler?.events?.collect { event -&gt; Log.d(\"Events\", \"Collected EVENT - $event\") when (event.eventType) { is EventType.Tap -&gt; { // Ad got tapped. } else -&gt; {} } } } } } } . Step 3 . You can observe the specific EventTypes you are interested in. For example, you can react to the tap on ads: . when(event.eventType) { is EventType.Tap -&gt; { // Ad got tapped. } else -&gt; {} } . Step 4 . Let’s add this to the App class as well. class App : Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) override fun onCreate() { super.onCreate() coroutineScope.launch { val isSuccess = AdService.init(\"1800\", applicationContext, EventHandler()) Log.d(\"App\", \"Init is success: $isSuccess\") launch { AdService.getInstance().eventHandler?.events?.collect { event -&gt; Log.d(\"Events\", \"Collected EVENT - $event\") when (event.eventType) { is EventType.Tap -&gt; { // Ad got tapped. } else -&gt; {} } } } } } } . Now we could act accordingly to a specific event in any way we wanted. ",
    "url": "/nextgen-adsdk-android-release/4.6.0/handling-the-state-and-events-of-advertising.html#section-3-observing-the-advertising-events",
    
    "relUrl": "/4.6.0/handling-the-state-and-events-of-advertising.html#section-3-observing-the-advertising-events"
  },"124": {
    "doc": "Handling the state and events of advertising",
    "title": "Handling the state and events of advertising",
    "content": " ",
    "url": "/nextgen-adsdk-android-release/4.6.0/handling-the-state-and-events-of-advertising.html",
    
    "relUrl": "/4.6.0/handling-the-state-and-events-of-advertising.html"
  },"125": {
    "doc": "Meet nextgen AdSDK",
    "title": "Meet nextgen AdSDK",
    "content": "Manage, display, and create your custom advertisements on Android using cutting-edge technologies such as Compose and Coroutines based on the AdSDK. ",
    "url": "/nextgen-adsdk-android-release/4.6.0/meet-adsdk.html",
    
    "relUrl": "/4.6.0/meet-adsdk.html"
  },"126": {
    "doc": "Meet nextgen AdSDK",
    "title": "Chapter 1",
    "content": "Working with the built-in capabilities of the SDK In this chapter, you will learn how to create, display, and manage advertisements using AdSDK. | Create and display inline ads | Handling the state and events of advertising | Defining the size of the advertisement | Create and display interstitial ad | Global ad request parameters | . ",
    "url": "/nextgen-adsdk-android-release/4.6.0/meet-adsdk.html#chapter-1",
    
    "relUrl": "/4.6.0/meet-adsdk.html#chapter-1"
  },"127": {
    "doc": "Create and display inline ads",
    "title": "Create and display inline ads",
    "content": "This tutorial will guide you through creating a simple application that can load and display a list of ads. ",
    "url": "/nextgen-adsdk-android-release/4.5.0/create-and-display-inline-ads.html",
    
    "relUrl": "/4.5.0/create-and-display-inline-ads.html"
  },"128": {
    "doc": "Create and display inline ads",
    "title": "Section 1: Getting started with AdSDK",
    "content": "Add and configure the AdSDK to create and load ads. Step 1 . Let’s create a new Android project and remove all unnecessary code. Make sure you have added the correct packages from the readme. Step 2 . The entry point into the SDK is the AdService class. To make an easy start we just initialize the AdService in the onCreate method of the MainActivity. This is the first thing we should create, as it will be used to generate advertisements in the future. To do this, we will add this code: . coroutineScope.launch { val isSuccess = AdService.init(\"1800\", applicationContext, EventHandler()) Log.d(\"AdSDK\", \"Init is success: $isSuccess\") } . Lets create an App file and class to add the AdService initialisation. To do this, create this class and add the code snippet from above. The only mandatory parameter when creating AdService is the networkId. Network ID is the ID of your advertising account. Our Code should now look like this: . class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) override fun onCreate() { super.onCreate() coroutineScope.launch { val isSuccess = AdService.init(\"1800\", applicationContext, EventHandler()) Log.d(\"App\", \"Init is success: $isSuccess\") } } } . Remember to add this class as an entry point, so add it to the application in your `Manifest: . android:name=\"com.adition.adsdk.App\" . Step 3 . The next step will be to create a composable, which we will display upon successful creation of AdService. On this composable, we will be creating and displaying our advertisement. @Composable fun AdView() { Text( text = \"Advertisement should be here\" ) } . Now we can call this in our composable in the MainActivity. class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { AdsdkdemoappandroidTheme { AdView() } } } } . ",
    "url": "/nextgen-adsdk-android-release/4.5.0/create-and-display-inline-ads.html#section-1-getting-started-with-adsdk",
    
    "relUrl": "/4.5.0/create-and-display-inline-ads.html#section-1-getting-started-with-adsdk"
  },"129": {
    "doc": "Create and display inline ads",
    "title": "Section 2: Loading and displaying advertisements",
    "content": "Step 1 . Before we create an Advertisement object we want to add a ViewModel: . class MainViewModel: ViewModel() { } . Step 2 . To create an Advertisement object, you need to specify parameters, two of which are required: . | contentId or learningTag | adTypes We’re going to use the contentId because it’s used more often than the learningTag. Content Unit is the unique ID of your advertising space and for ad type we use AdComposeRenderRegistry.getAllRendererNames() this will enable all available adTypes. Another important parameter is placementType. In this case, we need AdPlacementType.INLINE, which is the default, so we ignore it. All possible parameters can be found in the AdvertisementParameters documentation. | . class MainViewModel: ViewModel() { var ad: Advertisement = Advertisement( \"4810915\", AdComposeRenderRegistry.getAllRendererNames(), ) } . We can now load this advertisement using loadAdvertisement: . class MainViewModel: ViewModel() { var ad: Advertisement = Advertisement( \"4810915\", AdComposeRenderRegistry.getAllRendererNames(), ) init { viewModelScope.launch { ad.loadAdvertisement() } } } . Step 3 . We can pass this Advertisement now to the rememberAdState composable. The rememberAdState creates the AdState which we will use later. There are multiple versions of the rememberAdState. For example we could pass a content unit directly to the rememberAdState and it would create the Advertisement for us. @Composable fun AdView(viewModel: MainViewModel) { val adState = rememberAdState(advertisement = viewModel.ad) } . Step 4 . We can pass the AdState to Ad composable. The Ad is the main composable used to display the ad with provided adState. @Composable fun AdView() { val adState = rememberAdState(advertisement = viewModel.ad) Ad(adState = adState, modifier = Modifier) } . How our MainActivity should look like: . class MainActivity : ComponentActivity() { private val viewModel by viewModels&lt;MainViewModel&gt;() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { AdsdkdemoappandroidTheme { AdView(viewModel) } } } } @Composable fun AdView(viewModel: MainViewModel) { val adState = rememberAdState(advertisement = viewModel.ad) Ad(adState = adState, modifier = Modifier) } . Now we should see the Banner on our device: . ",
    "url": "/nextgen-adsdk-android-release/4.5.0/create-and-display-inline-ads.html#section-2-loading-and-displaying-advertisements",
    
    "relUrl": "/4.5.0/create-and-display-inline-ads.html#section-2-loading-and-displaying-advertisements"
  },"130": {
    "doc": "Create and display interstitial ad section",
    "title": "Create and display interstitial ad section",
    "content": "A full-screen advertisement that fills the host app’s interface is known as an interstitial ad. In this tutorial we are going to add interstitial ad into our application. ",
    "url": "/nextgen-adsdk-android-release/4.5.0/create-and-display-interstitial-ad-section.html",
    
    "relUrl": "/4.5.0/create-and-display-interstitial-ad-section.html"
  },"131": {
    "doc": "Create and display interstitial ad section",
    "title": "Section 1: Interstitial Ad Object",
    "content": "In this section we will create an interstitial Advertisement object. Step 1 . Lets change the structure of our AdsdkdemoappandroidTheme composable. We create a MainContent composable and move the AdView call over there. AdsdkdemoappandroidTheme { MainContent(viewModel) } . @Composable fun MainContent(viewModel: MainViewModel) { Box(modifier = Modifier.fillMaxSize()) { AdView(viewModel) } } . Step 2 . To create a interstitial banner we use the Advertisement class again. Only difference this time we add the different placementType INTERSTITIAL We add the interstitialAd in the MainViewModel. var interstitialAd: Advertisement = Advertisement( \"5192923\", AdComposeRenderRegistry.getAllRendererNames(), placementType = PlacementType.INTERSTITIAL ) . Step 3 . We can add now a composable for the fullscreen interstitial. @Composable fun ShowInterstitial(viewModel: MainViewModel) { var adState = rememberAdState(viewModel.interstitialAd) Box ( contentAlignment = Alignment.Center, modifier = Modifier.fillMaxSize() ){ Ad(adState = adState) } } . Step 4 . To trigger the interstitial composable we will use a button which we add at the bottom. @Composable fun BottomButton(onClick: () -&gt; Unit) { Box(modifier = Modifier.fillMaxSize()) { Button( onClick = onClick, modifier = Modifier .align(Alignment.BottomCenter) .padding(bottom = 16.dp) ) { Text(\"Show interstitial\") } } } . Step 5 . To control the interstitial presentation we will use a state value, which will be set to true if we click on the button. val showInterstitialComposable = remember { mutableStateOf(false) } BottomButton( onClick = { showInterstitialComposable.value = !showInterstitialComposable.value } ) . Step 6 . Now lets structure this all together in our MainContent composable we created above. @Composable fun MainContent(viewModel: MainViewModel) { val showInterstitialComposable = remember { mutableStateOf(false) } Box(modifier = Modifier.fillMaxSize()) { AdView(viewModel) BottomButton( onClick = { showInterstitialComposable.value = !showInterstitialComposable.value } ) if (showInterstitialComposable.value) { ShowInterstitial(viewModel) } } } . ",
    "url": "/nextgen-adsdk-android-release/4.5.0/create-and-display-interstitial-ad-section.html#section-1-interstitial-ad-object",
    
    "relUrl": "/4.5.0/create-and-display-interstitial-ad-section.html#section-1-interstitial-ad-object"
  },"132": {
    "doc": "Defining the size of the advertisement",
    "title": "Defining the size of the advertisement",
    "content": "This tutorial will teach you how to define the size of the advertisement, taking into account the aspect ratio parameter. In it, we will continue the development of the application we started in the previous section. ",
    "url": "/nextgen-adsdk-android-release/4.5.0/defining-the-size-of-the-advertisement.html",
    
    "relUrl": "/4.5.0/defining-the-size-of-the-advertisement.html"
  },"133": {
    "doc": "Defining the size of the advertisement",
    "title": "Section 1: Defining the size of the advertisement",
    "content": "Step 1 . For the the size of the advertisement we can use AdMetadata. From this object we can get the basic information after the advertising content has been loaded from the server. We will use the aspectRatio from the adMetadata. So let’s get the adMetadata from adState: . val aspectRatio = adState.adMetaData?.aspectRatio ?: 2F . Since aspectRatio is optional, we use the default value of 2:1 in this project. Step 2 . Now we can add the aspectRatio via the Modifier into the Ad composable. @Composable fun AdView(viewModel: MainViewModel) { val adState = rememberAdState(advertisement = viewModel.ad) val aspectRatio = adState.adMetaData?.aspectRatio ?: 2F Ad( adState = adState, modifier = Modifier .aspectRatio(aspectRatio) ) when (val state = adState?.state) { is AdState.State.Error -&gt; { when(state.adException.adError) { AdError.DECODING -&gt; { Log.e(\"MainActivity\", \"Decoding error: ${state.adException.exception}\") } } } is AdState.State.Loading -&gt; { // We are Caching. } is AdState.State.Caching -&gt; { // We are Caching. } is AdState.State.AdReadyToDisplay -&gt; { // Ad is ready and will be displayed. } else -&gt; {} } } . Note: In this case, we are requesting the adMetaData before the ad is successfully loaded, but when the ad is successfully loaded, the composable will be updated and we will get this data. In a real-world scenario, you would most likely use a ViewModel‘ or other state management mechanism where you could implement logic to ensure that the adMetaData’ is only requested when the ad is already loaded. ",
    "url": "/nextgen-adsdk-android-release/4.5.0/defining-the-size-of-the-advertisement.html#section-1-defining-the-size-of-the-advertisement",
    
    "relUrl": "/4.5.0/defining-the-size-of-the-advertisement.html#section-1-defining-the-size-of-the-advertisement"
  },"134": {
    "doc": "Global ad request parameters",
    "title": "Global ad request parameters",
    "content": "An ad request can have additional parameters beyond those you pass during initialization. These additional parameters are global for all ad requests. The SDK provides the ability to add global parameters once so that you don’t have to copy them when creating each ad request. ",
    "url": "/nextgen-adsdk-android-release/4.5.0/global-adRequest-parameters.html",
    
    "relUrl": "/4.5.0/global-adRequest-parameters.html"
  },"135": {
    "doc": "Global ad request parameters",
    "title": "Section 1: Modifying global parameters",
    "content": "In this section, we’ll configure the gdpr parameter for each ad request that we have in our app. In addition, we will review the possibility of removing global parameters. You can configure not only GDPR but also other parameters. You can find a list of all global parameters in the AdRequestGlobalParameters documentation. Step 1 . We can add global parameters via the AdService. The AdService has setAdRequestGlobalParameter method which we use to set the gdpr parameter. AdService.getInstance().setAdRequestGlobalParameter( AdRequestGlobalParameters::gdpr, GDPR(consent = \"gdprconsentexample\", isRulesEnabled = true) ) . Step 2 . To make it easy we will add the global parameters in the App class. class App : Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) override fun onCreate() { super.onCreate() coroutineScope.launch { val isSuccess = AdService.init(\"1800\", applicationContext, EventHandler()) Log.d(\"App\", \"Init is success: $isSuccess\") launch { AdService.getInstance().eventHandler?.events?.collect { event -&gt; Log.d(\"Events\", \"Collected EVENT - $event\") when (event.eventType) { is EventType.Tap -&gt; { // Ad got tapped. } else -&gt; {} } } } launch { AdService.getInstance().setAdRequestGlobalParameter( AdRequestGlobalParameters::gdpr, GDPR(consent = \"gdprconsentexample\", isRulesEnabled = true) ) } } } override fun onTerminate() { super.onTerminate() coroutineScope.cancel() } } . Step 3 . If we want to remove an global parameter we could use the removeAdRequestGlobalParameter method. AdService.getInstance().removeAdRequestGlobalParameter( AdRequestGlobalParameters::gdpr ) . ",
    "url": "/nextgen-adsdk-android-release/4.5.0/global-adRequest-parameters.html#section-1-modifying-global-parameters",
    
    "relUrl": "/4.5.0/global-adRequest-parameters.html#section-1-modifying-global-parameters"
  },"136": {
    "doc": "Handling the state and events of advertising",
    "title": "Handling the state and events",
    "content": "This tutorial will help you observe and respond to changes in the state and events. In it, we will continue the development of the application we started in the previous section. ",
    "url": "/nextgen-adsdk-android-release/4.5.0/handling-the-state-and-events-of-advertising.html#handling-the-state-and-events",
    
    "relUrl": "/4.5.0/handling-the-state-and-events-of-advertising.html#handling-the-state-and-events"
  },"137": {
    "doc": "Handling the state and events of advertising",
    "title": "Section 1: Observing the states",
    "content": "When we talk about state we mean the lifecycle state of the Ads composable. Step 1 . The state of an Ad is called AdState. This is an example of how we can observe the AdState: . when (val state = adState?.state) { is AdState.State.Error -&gt; { // We have an error. } is AdState.State.Loading -&gt; { // We are Caching. } is AdState.State.Caching -&gt; { // We are Caching. } is AdState.State.AdReadyToDisplay -&gt; { // Ad is ready and will be displayed. } else -&gt; {} } . Here we can see the different ad states we can observe: . | Error | Loading | Caching | ",
    "url": "/nextgen-adsdk-android-release/4.5.0/handling-the-state-and-events-of-advertising.html#section-1-observing-the-states",
    
    "relUrl": "/4.5.0/handling-the-state-and-events-of-advertising.html#section-1-observing-the-states"
  },"138": {
    "doc": "Handling the state and events of advertising",
    "title": "AdReadyToDisplay",
    "content": "Step 2 . Let’s add the code snippet from above to our AdView example: . @Composable fun AdView() { val adState = rememberAdState(advertisement = viewModel.ad) Ad(adState = adState, modifier = Modifier) when (val state = adState?.state) { is AdState.State.Error -&gt; { // We have an error. } is AdState.State.Loading -&gt; { // We are Caching. } is AdState.State.Caching -&gt; { // We are Caching. } is AdState.State.AdReadyToDisplay -&gt; { // Ad is ready and will be displayed and we could additional work } else -&gt; {} } } . We are able now to act accordingly to each AdState state. | . ",
    "url": "/nextgen-adsdk-android-release/4.5.0/handling-the-state-and-events-of-advertising.html#adreadytodisplay",
    
    "relUrl": "/4.5.0/handling-the-state-and-events-of-advertising.html#adreadytodisplay"
  },"139": {
    "doc": "Handling the state and events of advertising",
    "title": "Section 2: Handling errors during the loading and decoding",
    "content": "Sometimes it’s important for an app to be able to handle errors correctly. With the help of AdError, you can catch a specific error and implement the logic for handling it the way you need. Step 1 . We can observe errors in the AdSDK with AdException. An AdException holds the exception itself and the type of the error via AdError. With AdError we can observe different error types. For example lets catch a decoding error. when(state.adException.adError) { AdError.DECODING -&gt; { // Act accordingly e.g. repeat the request. } } . Step 2 . You can catch a number of different error types, just check AdError. Let’s just log the error and have a look how our composable should look like. @Composable fun AdView(viewModel: MainViewModel) { val adState = rememberAdState(advertisement = viewModel.ad) Ad(adState = adState, modifier = Modifier) when (val state = adState?.state) { is AdState.State.Error -&gt; { when(state.adException.adError) { AdError.DECODING -&gt; { Log.e(\"MainActivity\", \"Decoding error: ${state.adException.exception}\") } } } is AdState.State.Loading -&gt; { // We are Caching. } is AdState.State.Caching -&gt; { // We are Caching. } is AdState.State.AdReadyToDisplay -&gt; { // Ad is ready and will be displayed. } else -&gt; {} } } . ",
    "url": "/nextgen-adsdk-android-release/4.5.0/handling-the-state-and-events-of-advertising.html#section-2-handling-errors-during-the-loading-and-decoding",
    
    "relUrl": "/4.5.0/handling-the-state-and-events-of-advertising.html#section-2-handling-errors-during-the-loading-and-decoding"
  },"140": {
    "doc": "Handling the state and events of advertising",
    "title": "Section 3: Observing the advertising events",
    "content": "Observe the advertising events to respond to them in the application. The SDK can send many events related to advertisements, like impressions, visibility percentages and tap events. Step 1 . With the use of the AdService we can collect all ad Event. AdService.getInstance().eventHandler?.events?.collect { event -&gt; Log.d(\"Events\", \"Collected EVENT - $event\") } . Step 2 . Start the event observing before the composable loads if you want to make sure you get every event. For example, we could add it in the App class. class App: Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) override fun onCreate() { super.onCreate() coroutineScope.launch { val isSuccess = AdService.init(\"1800\", applicationContext, EventHandler()) Log.d(\"App\", \"Init is success: $isSuccess\") launch { AdService.getInstance().eventHandler?.events?.collect { event -&gt; Log.d(\"Events\", \"Collected EVENT - $event\") when (event.eventType) { is EventType.Tap -&gt; { // Ad got tapped. } else -&gt; {} } } } } } } . Step 3 . You can observe the specific EventTypes you are interested in. For example, you can react to the tap on ads: . when(event.eventType) { is EventType.Tap -&gt; { // Ad got tapped. } else -&gt; {} } . Step 4 . Let’s add this to the App class as well. class App : Application() { private val coroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()) override fun onCreate() { super.onCreate() coroutineScope.launch { val isSuccess = AdService.init(\"1800\", applicationContext, EventHandler()) Log.d(\"App\", \"Init is success: $isSuccess\") launch { AdService.getInstance().eventHandler?.events?.collect { event -&gt; Log.d(\"Events\", \"Collected EVENT - $event\") when (event.eventType) { is EventType.Tap -&gt; { // Ad got tapped. } else -&gt; {} } } } } } } . Now we could act accordingly to a specific event in any way we wanted. ",
    "url": "/nextgen-adsdk-android-release/4.5.0/handling-the-state-and-events-of-advertising.html#section-3-observing-the-advertising-events",
    
    "relUrl": "/4.5.0/handling-the-state-and-events-of-advertising.html#section-3-observing-the-advertising-events"
  },"141": {
    "doc": "Handling the state and events of advertising",
    "title": "Handling the state and events of advertising",
    "content": " ",
    "url": "/nextgen-adsdk-android-release/4.5.0/handling-the-state-and-events-of-advertising.html",
    
    "relUrl": "/4.5.0/handling-the-state-and-events-of-advertising.html"
  },"142": {
    "doc": "Meet nextgen AdSDK",
    "title": "Meet nextgen AdSDK",
    "content": "Manage, display, and create your custom advertisements on Android using cutting-edge technologies such as Compose and Coroutines based on the AdSDK. ",
    "url": "/nextgen-adsdk-android-release/4.5.0/meet-adsdk.html",
    
    "relUrl": "/4.5.0/meet-adsdk.html"
  },"143": {
    "doc": "Meet nextgen AdSDK",
    "title": "Chapter 1",
    "content": "Working with the built-in capabilities of the SDK In this chapter, you will learn how to create, display, and manage advertisements using AdSDK. | Create and display inline ads | Handling the state and events of advertising | Defining the size of the advertisement | Create and display interstitial ad | Global ad request parameters | . ",
    "url": "/nextgen-adsdk-android-release/4.5.0/meet-adsdk.html#chapter-1",
    
    "relUrl": "/4.5.0/meet-adsdk.html#chapter-1"
  }
}
